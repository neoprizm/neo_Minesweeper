<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>CELLULAR LIFE: GPU ULTIMATE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }
        #info-panel {
            color: #00ffcc; text-shadow: 0 0 5px #00ffcc; z-index: 10;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        .stat { font-size: 14px; margin-top: 5px; color: #aaa; }
        #stage-display { 
            font-size: 2em; font-weight: bold; color: #ff0055; margin-top: 20px; 
            text-shadow: 0 0 10px rgba(255, 0, 85, 0.5);
            transition: color 0.5s;
        }
        #timer { font-size: 1.5em; color: white; margin-top: 5px; }
        #controls-hint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: #ffffff; text-align: center; opacity: 0.7; font-size: 14px;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="info-panel">
            <h1>CELLULAR LIFE: GPU COMPUTE</h1>
            <div class="stat">System: <span id="fps">0</span> FPS | Objects: 1,000,000</div>
            <div id="timer">00:00</div>
            <div id="stage-display">SYSTEM INITIALIZED</div>
        </div>
        <div id="controls-hint">
            [L-Click] Laser Beam &nbsp;|&nbsp; [Wheel] Deep Zoom &nbsp;|&nbsp; [Drag] Rotate Orbit
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const GRID_SIZE = 100; // 100x100x100 = 1,000,000 particles
        const COUNT = GRID_SIZE * GRID_SIZE * GRID_SIZE;
        
        // --- SHADERS (GLSL) ---
        
        const vertexShader = `
            precision highp float;

            uniform float uTime;
            uniform float uExpand;    // 30s cycle expansion
            uniform float uFractal;   // 10s start (mandelbrot)
            uniform float uCollapse;  // 70s collapse
            uniform float uInfection; // 2:20 infection radius
            uniform float uExplode;   // 20s explosion
            uniform vec3 uLaserPos;
            uniform float uLaserActive;

            // Instanced Attributes
            attribute vec3 aOffset;   // Grid Position (x,y,z)
            attribute vec3 aColor;    // Base Rainbow Color
            attribute float aId;      // Unique Index

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vIsInfected;

            // --- Math Utils ---
            mat4 rotationMatrix(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                return mat4(
                    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                    0.0,                                0.0,                                0.0,                                1.0
                );
            }

            // Simple Mandelbulb-like deformation
            vec3 fractalDeform(vec3 p, float strength) {
                vec3 z = p;
                float r = length(z);
                if(r == 0.0) return p;
                float theta = acos(z.z / r) * strength;
                float phi = atan(z.y, z.x) * strength;
                float zr = pow(r, strength);
                return vec3(zr * sin(theta) * cos(phi), zr * sin(theta) * sin(phi), zr * cos(theta));
            }

            // Pseudo-random function
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            void main() {
                // 1. Center the grid
                vec3 basePos = aOffset * 1.5; // Gap between cubes

                // 2. Expansion (Breathing)
                float expandFactor = 1.0 + uExpand * 2.5; 
                vec3 currentPos = basePos * expandFactor;

                // 3. Explosion (Periodic)
                if (uExplode > 0.01) {
                    vec3 dir = normalize(currentPos);
                    currentPos += dir * uExplode * 30.0;
                    // Jitter
                    currentPos += vec3(sin(uTime*10.0 + aId), cos(uTime*10.0 + aId), sin(aId)) * uExplode * 2.0;
                }

                // 4. Fractal Deformation
                if (uFractal > 0.01) {
                    vec3 normP = normalize(currentPos);
                    // Smoothly blend into fractal shape
                    vec3 fracPos = fractalDeform(normP * 2.0, 4.0 + sin(uTime * 0.5));
                    currentPos = mix(currentPos, fracPos * 60.0, uFractal);
                }

                // 5. Collapse (Beehive Gravity Failure)
                if (uCollapse > 0.01) {
                    float noise = sin(aId * 0.1 + uTime * 2.0);
                    float drop = uCollapse * 200.0 * (0.8 + noise * 0.4);
                    
                    // Fall down but keep some x/z movement
                    currentPos.y -= drop;
                    currentPos.x += sin(drop * 0.05) * 10.0 * uCollapse;
                    currentPos.z += cos(drop * 0.05) * 10.0 * uCollapse;

                    // Floor pile-up effect
                    if (currentPos.y < -150.0) {
                        currentPos.y = -150.0 + mod(aId, 10.0) * uCollapse;
                    }
                }

                // 6. Infection Logic (Check distance)
                float distToCenter = length(currentPos);
                vIsInfected = 0.0;
                if (uInfection > 0.0) {
                    if (distToCenter < uInfection) {
                        vIsInfected = 1.0;
                        // Infected wobble
                        currentPos += vec3(random(vec2(aId, uTime)) - 0.5) * 2.0;
                    }
                }

                // 7. Individual Rotation (Earth Rotation)
                float rotSpeed = 1.0 + random(vec2(aId, 1.0));
                mat4 selfRot = rotationMatrix(normalize(vec3(1.0, 0.5, 0.2)), uTime * rotSpeed + aId);

                // 8. Laser Interaction
                if (uLaserActive > 0.0) {
                    float d = distance(currentPos, uLaserPos);
                    if (d < 20.0) {
                        currentPos *= 0.001; // Shrink to infinity
                    }
                }

                // Calculate Vertex Position
                vec4 modelViewPosition = viewMatrix * modelMatrix * vec4(currentPos, 1.0);
                
                // Apply rotation to the cube itself (vertices)
                vec4 rotatedPosition = selfRot * vec4(position, 1.0);
                rotatedPosition.xyz += currentPos; // Move to world position

                vWorldPos = rotatedPosition.xyz;
                vNormal = (selfRot * vec4(normal, 0.0)).xyz;
                vColor = aColor;

                gl_Position = projectionMatrix * viewMatrix * rotatedPosition;
            }
        `;

        const fragmentShader = `
            precision highp float;

            uniform float uTime;
            uniform vec3 uLightPositions[7];
            uniform float uInfection;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vIsInfected;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(cameraPosition - vWorldPos);

                // Base Color
                vec3 finalColor = vColor;

                // Infection Override (Black & Red)
                if (vIsInfected > 0.5) {
                    finalColor = vec3(0.02, 0.02, 0.02); // Charcoal black
                }

                // Lighting (7 Point Lights - Simple Lambert + Specular)
                vec3 lighting = vec3(0.0);
                for (int i = 0; i < 7; i++) {
                    vec3 lightDir = normalize(uLightPositions[i] - vWorldPos);
                    float diff = max(dot(normal, lightDir), 0.0);
                    float dist = distance(uLightPositions[i], vWorldPos);
                    float att = 5000.0 / (dist * dist + 100.0); // Attenuation
                    
                    // Simple Specular
                    vec3 reflectDir = reflect(-lightDir, normal);
                    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);

                    lighting += (diff + spec) * att;
                }

                // Infection Glow (Pulse)
                if (vIsInfected > 0.5) {
                    float pulse = sin(uTime * 10.0 + vWorldPos.x * 0.1) * 0.5 + 0.5;
                    lighting += vec3(0.8, 0.0, 0.0) * pulse; // Red Glow
                }

                // Fresnel Effect (Black Outline / Rim Light)
                float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                
                vec3 col = finalColor * (0.2 + lighting); // Ambient + Light
                
                // Mix Fresnel
                if (vIsInfected < 0.5) {
                    // Normal cells: Black outline
                    col = mix(col, vec3(0.0), fresnel * 0.7);
                    col += finalColor * fresnel * 0.5; // Inner glow
                } else {
                    // Infected cells: Green/Purple slime rim
                    col += vec3(0.2, 0.0, 0.2) * fresnel;
                }

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // --- MAIN INITIALIZATION ---
        
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x050510);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(200, 150, 250);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Optimization
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- GEOMETRY & ATTRIBUTES SETUP ---

        // 1. Create Base Geometry
        const baseGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        
        // 2. Convert to InstancedBufferGeometry
        const instancedGeometry = new THREE.InstancedBufferGeometry();
        instancedGeometry.index = baseGeometry.index;
        instancedGeometry.attributes.position = baseGeometry.attributes.position;
        instancedGeometry.attributes.normal = baseGeometry.attributes.normal;

        // 3. Populate Attributes (Offset, Color, ID)
        const offsets = new Float32Array(COUNT * 3);
        const colors = new Float32Array(COUNT * 3);
        const ids = new Float32Array(COUNT);

        const _color = new THREE.Color();
        const centerOffset = GRID_SIZE / 2;

        let i = 0;
        for (let x = 0; x < GRID_SIZE; x++) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    // Centered Grid Position
                    offsets[i * 3 + 0] = x - centerOffset;
                    offsets[i * 3 + 1] = y - centerOffset;
                    offsets[i * 3 + 2] = z - centerOffset;

                    // Rainbow Color based on position
                    _color.setHSL((x/GRID_SIZE + y/GRID_SIZE + z/GRID_SIZE) / 3, 0.8, 0.5);
                    colors[i * 3 + 0] = _color.r;
                    colors[i * 3 + 1] = _color.g;
                    colors[i * 3 + 2] = _color.b;

                    // Unique ID
                    ids[i] = i;

                    i++;
                }
            }
        }

        instancedGeometry.setAttribute('aOffset', new THREE.InstancedBufferAttribute(offsets, 3));
        instancedGeometry.setAttribute('aColor', new THREE.InstancedBufferAttribute(colors, 3));
        instancedGeometry.setAttribute('aId', new THREE.InstancedBufferAttribute(ids, 1));

        // --- UNIFORMS & MATERIAL ---

        const uniforms = {
            uTime: { value: 0 },
            uExpand: { value: 0 },
            uExplode: { value: 0 },
            uFractal: { value: 0 },
            uCollapse: { value: 0 },
            uInfection: { value: 0 },
            uLaserPos: { value: new THREE.Vector3() },
            uLaserActive: { value: 0 },
            uLightPositions: { value: [] } // Updated in loop
        };

        // Init Light Positions
        for(let j=0; j<7; j++) uniforms.uLightPositions.value.push(new THREE.Vector3());

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            side: THREE.DoubleSide,
            transparent: false // Opaque for performance
        });

        // 4. Create Mesh
        const mesh = new THREE.Mesh(instancedGeometry, material);
        mesh.frustumCulled = false; // Important: Prevents disappearing when expanded
        scene.add(mesh);

        // --- INTERACTION (LASER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Raycast against a virtual plane or calculate projection
            const target = new THREE.Vector3();
            raycaster.ray.at(150, target); // Aim at center depth

            uniforms.uLaserPos.value.copy(target);
            uniforms.uLaserActive.value = 1.0;

            // Simple visual beam (Optional DOM effect or secondary mesh)
            createLaserBeam(target);

            setTimeout(() => { uniforms.uLaserActive.value = 0.0; }, 150);
        });

        function createLaserBeam(target) {
            // Very simple line for visual feedback
            const points = [new THREE.Vector3(camera.position.x, camera.position.y - 10, camera.position.z), target];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ffff }));
            scene.add(line);
            setTimeout(() => scene.remove(line), 100);
        }

        // --- TIMELINE & ANIMATION LOOP ---

        const clock = new THREE.Clock();
        const fpsElem = document.getElementById('fps');
        const timerElem = document.getElementById('timer');
        const stageElem = document.getElementById('stage-display');

        let frames = 0;
        let prevTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            uniforms.uTime.value = time;

            // FPS Counter
            frames++;
            if (time - prevTime >= 1.0) {
                fpsElem.innerText = frames;
                frames = 0;
                prevTime = time;
                // Timer Text
                const m = Math.floor(time / 60);
                const s = Math.floor(time % 60);
                timerElem.innerText = `${m}:${s < 10 ? '0'+s : s}`;
            }

            // --- GAME LOGIC (TIMELINE) ---
            
            // 1. Lights Orbit
            for(let j=0; j<7; j++) {
                const t = time * 0.5 + j;
                uniforms.uLightPositions.value[j].set(
                    Math.sin(t) * 100, Math.cos(t * 0.7) * 100, Math.cos(t) * 100
                );
            }

            // 2. Expansion (30s Cycle)
            // 0~30: Expand, 30~60: Contract
            uniforms.uExpand.value = Math.sin(time * Math.PI / 30.0) * 0.5 + 0.5;

            // 3. Explosion (20s Cycle)
            // Sharp spike every 20s
            const explodeWave = Math.sin(time * Math.PI / 10.0); // 20s period sin wave mapped
            if (explodeWave > 0.95) {
                uniforms.uExplode.value = (explodeWave - 0.95) * 20.0; // Sharp scaling
            } else {
                uniforms.uExplode.value = 0.0;
            }

            // 4. Events Timeline
            let stageText = "STABLE CELLULAR GROWTH";
            stageElem.style.color = "#00ffcc";

            // FRACTAL (0:10 - 0:50)
            if (time >= 10 && time < 50) {
                if (time < 18) { // Fade In
                    uniforms.uFractal.value = (time - 10) / 8.0;
                    stageText = "MUTATION: FRACTAL GENESIS";
                } else if (time < 42) { // Sustain
                    uniforms.uFractal.value = 1.0;
                    stageText = "DIMENSION: MANDELBROT";
                    stageElem.style.color = "#cc00ff";
                } else { // Fade Out
                    uniforms.uFractal.value = 1.0 - (time - 42) / 8.0;
                    stageText = "STABILIZING...";
                }
            } else {
                uniforms.uFractal.value = 0.0;
            }

            // COLLAPSE (1:10 - 2:00)
            if (time >= 65 && time < 70) {
                stageText = "WARNING: STRUCTURAL INTEGRITY LOW";
                stageElem.style.color = "orange";
            }
            else if (time >= 70 && time < 120) {
                stageText = "EVENT: BEEHIVE COLLAPSE";
                stageElem.style.color = "red";
                // Smooth collapse transition
                uniforms.uCollapse.value = Math.min((time - 70) / 10.0, 1.0);
            }
            
            // RECOVERY (2:00 - 2:20)
            else if (time >= 120 && time < 140) {
                stageText = "EVENT: GEOMETRIC RESTORATION";
                stageElem.style.color = "#00ff00";
                // Lerp back to 0
                uniforms.uCollapse.value = Math.max(1.0 - (time - 120) / 15.0, 0.0);
            }

            // INFECTION (2:20+)
            else if (time >= 140) {
                stageText = "ALERT: VIRAL PATHOGEN DETECTED";
                stageElem.style.color = "#ff0000";
                
                // Radius expands at 10 units/sec
                uniforms.uInfection.value = (time - 140) * 10.0;
                
                if (uniforms.uInfection.value > 200) {
                    stageText = "CRITICAL: SYSTEM COMPROMISED";
                }
            }

            stageElem.innerText = stageText;

            controls.update();
            renderer.render(scene, camera);
        }

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start Loop
        animate();

    </script>
</body>
</html>