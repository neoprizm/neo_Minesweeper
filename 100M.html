<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Cycle - ë¬´í•œ ìˆœí™˜ ìš°ì£¼ 60FPS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght:400;700;900&family=Rajdhani:wght:300;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: #000000;
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at 50% 50%, #0a0520, #000000);
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        #fps {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 0 10px #00ff00;
            font-family: 'Orbitron', monospace;
        }
        
        #info {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            font-family: 'Orbitron', monospace;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: all;
        }
        
        .control-btn {
            background: rgba(0, 255, 255, 0.8);
            color: black;
            border: 2px solid cyan;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .control-btn:hover {
            background: rgba(0, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn.paused {
            background: rgba(255, 100, 0, 0.8);
            border-color: #ff6400;
            box-shadow: 0 0 10px rgba(255, 100, 0, 0.5);
        }
        
        .control-btn.paused:hover {
            background: rgba(255, 100, 0, 1);
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.8);
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: all;
        }
        
        #startScreen.hide {
            display: none;
        }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 96px;
            font-weight: 900;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient 3s ease infinite;
            margin-bottom: 30px;
        }
        
        @keyframes gradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .subtitle {
            font-size: 32px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 50px;
            letter-spacing: 8px;
            font-weight: 600;
        }
        
        .instructions {
            max-width: 800px;
            text-align: center;
            color: #ffffff;
            font-size: 12px;
            line-height: 1.6;
            margin-bottom: 40px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .start-btn {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 700;
            padding: 20px 60px;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: 4px solid #ffffff;
            color: #000000;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 5px;
            box-shadow: 0 0 40px #ff00ff, 0 0 80px #00ffff;
            transition: all 0.3s;
            animation: glow 2s infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 40px #ff00ff, 0 0 80px #00ffff; }
            50% { box-shadow: 0 0 60px #ff00ff, 0 0 120px #00ffff; }
        }
        
        .start-btn:hover {
            transform: scale(1.1) rotate(2deg);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="fps">FPS: 60</div>
        <div id="info">GPU Compute: Active<br>Cubes: 1,000,000<br>Rotation: ON ğŸŒ<br>Separation: Dynamic ğŸŒŒ<br>Fractal: Mandelbrot ğŸŒ€<br>Infection: Cellular ğŸ¦ <br>E=mcÂ²: Active âš¡<br>Rebirth: Infinite â™¾ï¸<br>Life Cycle: Active ğŸâœ¨<br><span id="timer">Time: 0:00</span></div>
        <div id="controls">
            <button class="control-btn" id="pauseBtn">â¸ PAUSE</button>
        </div>
    </div>
    
    <div id="startScreen">
        <div class="game-title">INFINITE CYCLE</div>
        <div class="subtitle">ë¬´í•œ ìˆœí™˜ ìš°ì£¼</div>
        <div class="instructions">
            ğŸš€ <strong>GPU Compute Shader ê¸°ìˆ </strong> - ëª¨ë“  ê³„ì‚°ì„ GPUì—ì„œ ë³‘ë ¬ ì²˜ë¦¬! ğŸš€<br>
            100Ã—100Ã—100 = 1,000,000ê°œ <strong>ë¬´ì§€ê°œ íë¸Œ</strong>ë¥¼ <strong>ì™„ë²½í•œ 60FPS</strong>ë¡œ ë Œë”ë§í•©ë‹ˆë‹¤.<br><br>
            ğŸŒˆ <strong>ë‹¤ì–‘í•œ ìƒ‰ìƒ</strong>: ê° íë¸Œë§ˆë‹¤ ê³ ìœ í•œ ë¬´ì§€ê°œ ìƒ‰ìƒ! ğŸ’<br>
            â¬› <strong>ê²€ì€ìƒ‰ ì™¸ê³½ì„ </strong>: Fresnel íš¨ê³¼ë¡œ íë¸Œ ê²½ê³„ê°€ ì„ ëª…í•˜ê²Œ! âœ¨<br>
            ğŸ’¡ <strong>ì‹¤ì‹œê°„ ê´‘ì›</strong>: 7ê°œ í¬ì¸íŠ¸ ë¼ì´íŠ¸ê°€ íë¸Œë¥¼ ë¹„ì¶”ë©° ê¶¤ë„ íšŒì „! âœ¨<br>
            ğŸŒ <strong>ì§€êµ¬ ìì „</strong>: ê° íë¸Œê°€ 3ì¶• íšŒì „í•˜ë©° ìì „í•©ë‹ˆë‹¤! ğŸ”„<br>
            ğŸŒŒ <strong>ê¸°í•˜ê¸‰ìˆ˜ ë¶„ë¦¬</strong>: 30ì´ˆë§ˆë‹¤ íë¸Œ ê°„ ê±°ë¦¬ê°€ 3ë°°ê¹Œì§€ ì„œì„œíˆ ì¦ê°€! ğŸ“<br>
            ğŸŒ€ <strong>ë§Œë¸ë¸Œë¡œíŠ¸ í”„ë™íƒˆ</strong>: <span style="color:#ff00ff">10ì´ˆ í›„</span> zÂ²+c ìˆ˜ì‹ìœ¼ë¡œ ë‹¤ì°¨ì› ë³€í˜•! ğŸ”®<br>
            âš¡ <strong>E=mcÂ² ìƒëŒ€ì„±ì´ë¡ </strong>: ê° íë¸Œì˜ ìš´ë™ ì—ë„ˆì§€ì™€ ìƒëŒ€ë¡ ì  ì§ˆëŸ‰ ì‹¤ì‹œê°„ ê³„ì‚°! ğŸ”¬<br>
            ğŸ” <strong>ê·¹í•œ ì¤Œì¸</strong>: íë¸Œ ë‚´ë¶€ê¹Œì§€ ë“¤ì–´ê°€ì„œ íƒí—˜ ê°€ëŠ¥! ğŸ®<br>
            ğŸ <strong>ë²Œ êµ°ì§‘ ë¶•ê´´</strong>: <span style="color:#ff0000">70ì´ˆ í›„</span> ì™„ë§Œí•˜ê²Œ ì—°ì‡„ ë¶•ê´´! âš ï¸<br>
            âœ¨ <strong>ê¸°í•˜ê¸‰ìˆ˜ ë³µêµ¬</strong>: <span style="color:#00ff00">ë¶•ê´´ ì™„ë£Œ í›„</span> í•˜ë‚˜ì”© ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ë³µêµ¬! ğŸŒ±<br>
            ğŸ¦  <strong>ì„¸í¬ ì¦ì‹ ê°ì—¼</strong>: <span style="color:#000000; background:#ff0000; padding:2px 6px;">2:20 í›„</span> ê²€ì€ íë¸Œê°€ ìê¸°ë³µì œí•˜ë©° í™•ì‚°! ğŸ’€<br>
            ğŸ’€ <strong>ì™„ì „ ì†Œë©¸</strong>: <span style="color:#000000; background:#ffffff; padding:2px 6px;">3:00 í›„</span> ëª¨ë“  íë¸Œê°€ 3ì´ˆ ì•ˆì— ì†Œë©¸! âš«<br>
            âœ¨ <strong>í™©ê¸ˆ ì¬ìƒì„±</strong>: <span style="color:#FFD700">ì†Œë©¸ í›„</span> 1ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ 100ë§Œê°œ í™©ê¸ˆìƒ‰ íë¸Œ ì¬íƒ„ìƒ! ğŸ†<br>
            ğŸ”„ <strong>ë¬´í•œ ìˆœí™˜</strong>: ì¬ìƒì„± ì™„ë£Œ í›„ ëª¨ë“  ë£¨í‹´ì´ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘! â™¾ï¸<br>
            20ì´ˆë§ˆë‹¤ ëª¨ë“  íë¸Œê°€ ë¶€ë“œëŸ½ê²Œ í­ë°œí–ˆë‹¤ê°€ ì¬ê²°í•©í•©ë‹ˆë‹¤.<br><br>
            <strong>í”„ë™íƒˆ íš¨ê³¼:</strong> ë§Œë¸ë¸Œë¡œíŠ¸ ì§‘í•©(zÂ²+c), ì¤„ë¦¬ì•„ ì§‘í•©, ë§Œë¸ë¶ˆë¸Œ(3D ë©±ìŠ¹), 8ì´ˆ í˜ì´ë“œ ì¸ â†’ 24ì´ˆ ìœ ì§€ â†’ 8ì´ˆ í˜ì´ë“œ ì•„ì›ƒ<br><br>
            <strong>E=mcÂ² ìƒëŒ€ì„±ì´ë¡ :</strong> Î³ = 1/âˆš(1-Î²Â²) ë¡œë Œì¸  ì¸ì, m = Î³mâ‚€ ìƒëŒ€ë¡ ì  ì§ˆëŸ‰, E = (Î³-1)mcÂ² ìš´ë™ ì—ë„ˆì§€<br>
            â–ª ë¹ ë¥¸ íë¸Œ: ì²­ë°±ìƒ‰ ì²´ë Œì½”í”„ ê¸€ë¡œìš°, ì§ˆëŸ‰ ì¦ê°€ â†’ ë°ê¸° ì¦ê°€, ë„í”ŒëŸ¬ íš¨ê³¼(íŒŒë€ìƒ‰ ì´ë™)<br><br>
            <strong>í™©ê¸ˆ ì¬ìƒì„±:</strong> 2ì´ˆ ë™ì•ˆ ìˆœì°¨ì  ìƒì„±, í™©ê¸ˆë¹› ê°•ë ¬í•œ ê¸€ë¡œìš°, í„ìŠ¤ íš¨ê³¼, ìƒìŠ¹ íŒŒí‹°í´<br>
            â–ª íë¸Œ #1 â†’ #1,000,000 ìˆœì„œëŒ€ë¡œ, ì¬ìƒì„± ì „ì„  í™©ê¸ˆ íŒŒë™, ì™„ë£Œ í›„ ë¬´ì§€ê°œìƒ‰ ë³µì›<br><br>
            <strong>ëª¨ë“  ë³€í™”ê°€ ë¶€ë“œëŸ½ê³  ì™„ë§Œí•˜ê²Œ ì§„í–‰ë©ë‹ˆë‹¤!</strong> í´ë¦­: ë ˆì´ì € ğŸ’¥ | ìš°ì¸¡ ìƒë‹¨: ì¼ì‹œì •ì§€ â¸<br>
            <strong>ìƒëª… ì£¼ê¸°:</strong> <span style="color:#ff00ff">0:10</span> í”„ë™íƒˆ â†’ <span style="color:#ffff00">1:05</span> ê²½ê³  â†’ <span style="color:#ff0000">1:10</span> ë¶•ê´´ â†’ <span style="color:#00ff00">2:00</span> ë³µêµ¬ â†’ <span style="color:#000000; background:#ff0000; padding:2px 6px;">2:20</span> ê°ì—¼ â†’ <span style="color:#000000; background:#ffffff; padding:2px 6px;">3:00</span> ì†Œë©¸ â†’ <span style="color:#FFD700">3:03</span> ì¬íƒ„ìƒ! ğŸŒ€ğŸğŸ¦ ğŸ’€âœ¨â™¾ï¸
        </div>
        <button class="start-btn" onclick="startGame()">ì‹œì‘</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let cubeMesh;
        let cubeData = [];
        let explosionParticles = [];
        let laserBeams = [];
        let lights = [];
        let gameStarted = false;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let raycaster, mouse;
        let mouseMoved = false;
        let gameStartTime = 0;
        
        // ì¼ì‹œì •ì§€ ì‹œìŠ¤í…œ
        let isPaused = false;
        let pausedTime = 0;
        let totalPausedDuration = 0;
        
        // í­ë°œ ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
        let explosionCycle = 0;
        let lastExplosionTime = 0;
        const EXPLOSION_INTERVAL = 20000; // 20ì´ˆ
        const EXPLOSION_DURATION = 5000; // 5ì´ˆ
        
        // íšŒì „ ë° ë¶„ë¦¬ ì• ë‹ˆë©”ì´ì…˜
        let rotationTime = 0;
        let separationCycle = 0;
        let lastSeparationTime = 0;
        const SEPARATION_INTERVAL = 30000; // 30ì´ˆë§ˆë‹¤ ë¶„ë¦¬/ì¬ê²°í•©
        const SEPARATION_DURATION = 10000; // 10ì´ˆ ë™ì•ˆ ë¶„ë¦¬
        
        // ë²Œ êµ°ì§‘ ë¶•ê´´
        let collapseStartTime = -1;
        let collapseTriggered = false;
        const COLLAPSE_TRIGGER_TIME = 70000; // 70ì´ˆë¡œ ë³€ê²½ (ë” ëŠ¦ê²Œ)
        const COLLAPSE_DURATION = 50000; // 50ì´ˆ ë™ì•ˆ ë¶•ê´´ (ë” ê¸¸ê²Œ)
        
        // êµ°ì§‘ ë³µêµ¬
        let recoveryStartTime = -1;
        let recoveryTriggered = false;
        const RECOVERY_DURATION = 40000; // 40ì´ˆ ë™ì•ˆ ë³µêµ¬ (ë” ê¸¸ê²Œ)
        
        // í”„ë™íƒˆ ë³€í˜•
        let fractalIntensity = 0;
        let fractalTriggered = false;
        const FRACTAL_TRIGGER_TIME = 10000; // 10ì´ˆ í›„ í”„ë™íƒˆ ì‹œì‘
        const FRACTAL_CYCLE_DURATION = 40000; // 40ì´ˆ í”„ë™íƒˆ ì‚¬ì´í´ (ë” ê¸¸ê²Œ)
        const FRACTAL_FADE_IN = 8000; // 8ì´ˆ í˜ì´ë“œ ì¸
        const FRACTAL_FADE_OUT = 8000; // 8ì´ˆ í˜ì´ë“œ ì•„ì›ƒ
        
        // ì„¸í¬ ì¦ì‹ ê°ì—¼ ì‹œìŠ¤í…œ
        let infectionStartTime = -1;
        let infectionTriggered = false;
        let infectionOrigin = new THREE.Vector3(0, 0, 0);
        const INFECTION_TRIGGER_TIME = 140000; // 140ì´ˆ (2ë¶„ 20ì´ˆ) í›„ ê°ì—¼ ì‹œì‘
        const INFECTION_DURATION = 40000; // 40ì´ˆ ë™ì•ˆ ê°ì—¼ í™•ì‚°
        
        // ì¬ìƒì„± ì‹œìŠ¤í…œ (3ë¶„ í›„)
        let extinctionStartTime = -1;
        let extinctionTriggered = false;
        let regenerationStartTime = -1;
        let regenerationTriggered = false;
        let regenerationProgress = 0;
        const EXTINCTION_TRIGGER_TIME = 180000; // 180ì´ˆ (3ë¶„) í›„ ì†Œë©¸
        const EXTINCTION_DURATION = 3000; // 3ì´ˆ ë™ì•ˆ ì†Œë©¸
        const REGENERATION_DURATION = 2000; // 2ì´ˆ ë™ì•ˆ ì¬ìƒì„± (ë¹ ë¥´ê²Œ)
        
        // íë¸Œ ì„¤ì •
        const GRID_SIZE = 100;
        const CUBE_SIZE = 0.9;
        const CUBE_GAP = 1.2;
        const TOTAL_CUBES = GRID_SIZE * GRID_SIZE * GRID_SIZE;
        
        // FPS ì¸¡ì •
        let lastTime = performance.now();
        let frames = 0;
        let fps = 60;
        
        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜ (ì „ì—­ìœ¼ë¡œ ì¦‰ì‹œ ë…¸ì¶œ)
        function startGame() {
            document.getElementById('startScreen').classList.add('hide');
            gameStarted = true;
            gameStartTime = Date.now();
            lastExplosionTime = Date.now();
            lastSeparationTime = Date.now();
        }
        
        // ì „ì—­ window ê°ì²´ì— í• ë‹¹
        window.startGame = startGame;
        
        // GPU Compute Shaderìš© Vertex Shader
        const vertexShader = `
            // ì¸ìŠ¤í„´ìŠ¤ë³„ ì†ì„±
            attribute vec3 basePosition;
            attribute vec3 explosionDirection;
            attribute float cubeIndex;
            attribute vec3 cubeColor;
            
            // ìœ ë‹ˆí¼ ë³€ìˆ˜
            uniform float time;
            uniform float explosionCycle;
            uniform float explosionDistance;
            uniform float rotationTime;
            uniform float separationFactor;
            uniform float collapseStartTime;
            uniform float recoveryStartTime;
            uniform float currentTime;
            uniform float fractalIntensity;
            uniform vec2 fractalCenter;
            uniform float infectionStartTime;
            uniform vec3 infectionOrigin;
            uniform float infectionRadius;
            uniform float extinctionStartTime;
            uniform float regenerationStartTime;
            uniform float regenerationProgress;
            
            // Fragment Shaderë¡œ ì „ë‹¬
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vExplosion;
            varying vec3 vColor;
            varying vec3 vViewPosition;
            varying float vOpacity;
            varying float vCubeIndex;
            varying float vFractalDepth;
            varying float vInfectionLevel;
            varying float vKineticEnergy;
            varying float vRelativisticMass;
            varying vec3 vVelocity;
            varying float vRegenerationGlow;
            
            // íšŒì „ í–‰ë ¬ ìƒì„± í•¨ìˆ˜
            mat3 rotateY(float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return mat3(
                    c, 0.0, s,
                    0.0, 1.0, 0.0,
                    -s, 0.0, c
                );
            }
            
            mat3 rotateX(float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return mat3(
                    1.0, 0.0, 0.0,
                    0.0, c, -s,
                    0.0, s, c
                );
            }
            
            mat3 rotateZ(float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return mat3(
                    c, -s, 0.0,
                    s, c, 0.0,
                    0.0, 0.0, 1.0
                );
            }
            
            // ì†Œë©¸ ê³„ì‚°
            float calculateExtinction(float startTime, float currentT) {
                if (startTime < 0.0) return 1.0; // ì†Œë©¸ ì „ = ì •ìƒ
                
                float timeSinceExtinction = currentT - startTime;
                if (timeSinceExtinction < 0.0) return 1.0;
                
                // 3ì´ˆ ë™ì•ˆ ë¹ ë¥´ê²Œ ì‚¬ë¼ì§
                float progress = timeSinceExtinction / 3.0;
                progress = min(progress, 1.0);
                
                // ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œ ì•„ì›ƒ
                return 1.0 - smoothstep(0.0, 1.0, progress);
            }
            
            // ì¬ìƒì„± ê³„ì‚° (ìˆœì°¨ì )
            float calculateRegeneration(float cubeIdx, float progress) {
                if (progress <= 0.0) return 0.0;
                if (progress >= 1.0) return 1.0;
                
                // íë¸Œ ì¸ë±ìŠ¤ë¥¼ 0~1ë¡œ ì •ê·œí™”
                float normalizedIndex = cubeIdx / 1000000.0;
                
                // ìˆœì°¨ì  ë“±ì¥ (progressê°€ normalizedIndexë¥¼ ì§€ë‚˜ê°€ë©´ ë“±ì¥)
                float appearThreshold = normalizedIndex;
                
                if (progress < appearThreshold) {
                    return 0.0; // ì•„ì§ ë“±ì¥ ì•ˆí•¨
                }
                
                // ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ (0.01ì´ˆ ë™ì•ˆ)
                float localProgress = (progress - appearThreshold) / 0.01;
                localProgress = clamp(localProgress, 0.0, 1.0);
                
                return smoothstep(0.0, 1.0, localProgress);
            }
            
            // E=MCÂ² ìƒëŒ€ì„±ì´ë¡  ê³„ì‚°
            // E = mcÂ² (ì—ë„ˆì§€ = ì§ˆëŸ‰ Ã— ê´‘ì†Â²)
            vec3 calculateRelativisticPhysics(
                vec3 currentPos, 
                vec3 previousPos, 
                float deltaTime,
                float restMass,
                out float kineticEnergy,
                out float relativisticMass
            ) {
                // ê´‘ì† (ì„ì˜ ë‹¨ìœ„, ì‹œë®¬ë ˆì´ì…˜ ìŠ¤ì¼€ì¼)
                float c = 100.0;
                float c2 = c * c;
                
                // ì†ë„ ê³„ì‚° (v = Î”x / Î”t)
                vec3 velocity = (currentPos - previousPos) / max(deltaTime, 0.001);
                float v = length(velocity);
                
                // ì†ë„ ì œí•œ (ê´‘ì† ì´í•˜)
                v = min(v, c * 0.99);
                
                // ë² íƒ€ (Î² = v/c)
                float beta = v / c;
                float beta2 = beta * beta;
                
                // ë¡œë Œì¸  ì¸ì (Î³ = 1 / âˆš(1 - Î²Â²))
                float lorentzFactor = 1.0 / sqrt(1.0 - beta2);
                
                // ìƒëŒ€ë¡ ì  ì§ˆëŸ‰ (m = Î³mâ‚€)
                relativisticMass = lorentzFactor * restMass;
                
                // ìš´ë™ ì—ë„ˆì§€ (E_k = (Î³ - 1)mcÂ²)
                kineticEnergy = (lorentzFactor - 1.0) * restMass * c2;
                
                // ì •ê·œí™”ëœ ì—ë„ˆì§€ (ì‹œê°í™”ìš©)
                kineticEnergy = kineticEnergy / (restMass * c2);
                
                return velocity;
            }
            
            // ê°ì—¼ ê³„ì‚° (ì„¸í¬ ì¦ì‹ ì‹œë®¬ë ˆì´ì…˜)
            float calculateInfection(vec3 cubePos, vec3 origin, float startTime, float currentT, float radius) {
                if (startTime < 0.0) return 0.0; // ê°ì—¼ ì‹œì‘ ì „
                
                float timeSinceInfection = currentT - startTime;
                if (timeSinceInfection < 0.0) return 0.0;
                
                // ê°ì—¼ì›ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬
                float distance = length(cubePos - origin);
                
                // ê°ì—¼ í™•ì‚° ì†ë„ (ì´ˆë‹¹ 10 ìœ ë‹›)
                float infectionSpeed = 10.0;
                float currentRadius = timeSinceInfection * infectionSpeed;
                
                // ê°ì—¼ ì „ì„ ì˜ ë‘ê»˜
                float infectionFrontWidth = 15.0;
                
                // ì´ë¯¸ ê°ì—¼ëœ ì˜ì—­ì¸ì§€ í™•ì¸
                if (distance < currentRadius - infectionFrontWidth) {
                    return 1.0; // ì™„ì „ ê°ì—¼
                }
                
                // ê°ì—¼ ì „ì„  (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
                if (distance < currentRadius) {
                    float frontPosition = (currentRadius - distance) / infectionFrontWidth;
                    return smoothstep(0.0, 1.0, frontPosition);
                }
                
                return 0.0; // ì•„ì§ ê°ì—¼ ì•ˆë¨
            }
            
            // ë³µì†Œìˆ˜ ê³±ì…ˆ
            vec2 complexMul(vec2 a, vec2 b) {
                return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
            }
            
            // ë§Œë¸ë¸Œë¡œíŠ¸ ì§‘í•© ê³„ì‚°
            // z(n+1) = z(n)^2 + c
            float mandelbrot(vec2 c, int maxIter) {
                vec2 z = vec2(0.0, 0.0);
                float iter = 0.0;
                
                for (int i = 0; i < 20; i++) {
                    if (i >= maxIter) break;
                    
                    // z^2
                    z = complexMul(z, z);
                    // z^2 + c
                    z += c;
                    
                    // íƒˆì¶œ ì¡°ê±´
                    if (length(z) > 2.0) {
                        return iter / float(maxIter);
                    }
                    
                    iter += 1.0;
                }
                
                return 1.0; // ì§‘í•© ë‚´ë¶€
            }
            
            // 4D ë§Œë¸ë¸Œë¡œíŠ¸ ë³€í˜• (ì¿¼í„°ë‹ˆì–¸)
            vec4 quaternionMul(vec4 a, vec4 b) {
                return vec4(
                    a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                    a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
                    a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
                    a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
                );
            }
            
            // 4D ë§Œë¸ë¸Œë¡œíŠ¸ (ë§Œë¸ë¶ˆë¸Œ)
            float mandelbulb(vec3 pos, float power) {
                vec3 z = pos;
                float dr = 1.0;
                float r = 0.0;
                
                for (int i = 0; i < 8; i++) {
                    r = length(z);
                    
                    if (r > 2.0) break;
                    
                    // êµ¬ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                    float theta = acos(z.z / r);
                    float phi = atan(z.y, z.x);
                    dr = pow(r, power - 1.0) * power * dr + 1.0;
                    
                    // ë©±ìŠ¹ ì ìš©
                    float zr = pow(r, power);
                    theta = theta * power;
                    phi = phi * power;
                    
                    // ë°ì¹´ë¥´íŠ¸ ì¢Œí‘œë¡œ ë³µê·€
                    z = zr * vec3(
                        sin(theta) * cos(phi),
                        sin(theta) * sin(phi),
                        cos(theta)
                    );
                    z += pos;
                }
                
                return 0.5 * log(r) * r / dr;
            }
            
            // ì¤„ë¦¬ì•„ ì§‘í•© ê³„ì‚°
            float julia(vec2 z, vec2 c, int maxIter) {
                float iter = 0.0;
                
                for (int i = 0; i < 20; i++) {
                    if (i >= maxIter) break;
                    
                    z = complexMul(z, z) + c;
                    
                    if (length(z) > 2.0) {
                        return iter / float(maxIter);
                    }
                    
                    iter += 1.0;
                }
                
                return 1.0;
            }
            
            // ë¶•ê´´ ê³„ì‚° (ë„ë¯¸ë…¸ íš¨ê³¼ - ë” ì™„ë§Œí•˜ê²Œ)
            float calculateCollapse(float cubeIdx, float collapseStart, float currentT) {
                if (collapseStart < 0.0) return 1.0; // ë¶•ê´´ ì‹œì‘ ì „
                
                float timeSinceCollapse = currentT - collapseStart;
                if (timeSinceCollapse < 0.0) return 1.0;
                
                // íŒŒë™ì²˜ëŸ¼ í¼ì§€ëŠ” ë¶•ê´´ (ì¤‘ì‹¬ì—ì„œ ì™¸ê³½ìœ¼ë¡œ) - ë” ëŠë¦¬ê²Œ
                float wave1 = sin(cubeIdx * 0.00008 + timeSinceCollapse * 0.3) * 0.5 + 0.5;
                float wave2 = sin(cubeIdx * 0.00012 - timeSinceCollapse * 0.2) * 0.5 + 0.5;
                float wave3 = sin(cubeIdx * 0.0001 + timeSinceCollapse * 0.4) * 0.5 + 0.5;
                
                // ë³µí•© íŒŒë™
                float wavePattern = (wave1 + wave2 + wave3) / 3.0;
                
                // ì‹œê°„ì— ë”°ë¥¸ ì „ì²´ì  ê°ì†Œ - ë” ì™„ë§Œí•˜ê²Œ
                float globalDecay = 1.0 - smoothstep(0.0, 50.0, timeSinceCollapse);
                
                // ë¬´ì‘ìœ„ì„± ì¶”ê°€ (ë²Œ êµ°ì§‘ ë¶•ê´´ì²˜ëŸ¼) - ë” ë¶€ë“œëŸ½ê²Œ
                float randomFactor = fract(sin(cubeIdx * 12.9898) * 43758.5453);
                float randomDecay = smoothstep(randomFactor * 35.0, randomFactor * 35.0 + 10.0, timeSinceCollapse);
                
                // ìµœì†Œê°’ ë³´ì¥ (ì™„ì „íˆ ì‚¬ë¼ì§€ì§€ ì•ŠìŒ)
                float minOpacity = 0.05;
                return max(minOpacity, globalDecay * (1.0 - randomDecay * 0.95) * wavePattern);
            }
            
            // ë³µêµ¬ ê³„ì‚° (ê¸°í•˜ê¸‰ìˆ˜ì  ì¬ìƒ - ë” ì™„ë§Œí•˜ê²Œ)
            float calculateRecovery(float cubeIdx, float recoveryStart, float currentT) {
                if (recoveryStart < 0.0) return 0.0; // ë³µêµ¬ ì‹œì‘ ì „
                
                float timeSinceRecovery = currentT - recoveryStart;
                if (timeSinceRecovery < 0.0) return 0.0;
                
                // ê¸°í•˜ê¸‰ìˆ˜ì  ì¦ê°€ (exponential growth) - ë” ëŠë¦¬ê²Œ
                float baseGrowth = 1.0 - exp(-timeSinceRecovery * 0.05);
                
                // íŒŒë™ íŒ¨í„´ (ë¶•ê´´ì™€ ë°˜ëŒ€ ë°©í–¥) - ë” ë¶€ë“œëŸ½ê²Œ
                float wave1 = sin(cubeIdx * 0.00008 - timeSinceRecovery * 0.4) * 0.5 + 0.5;
                float wave2 = sin(cubeIdx * 0.00012 + timeSinceRecovery * 0.3) * 0.5 + 0.5;
                float wave3 = sin(cubeIdx * 0.0001 - timeSinceRecovery * 0.5) * 0.5 + 0.5;
                
                float wavePattern = (wave1 + wave2 + wave3) / 3.0;
                
                // ë¬´ì‘ìœ„ ë³µêµ¬ íƒ€ì´ë° - ë” ë¹ ë¥´ê²Œ ì‹œì‘
                float randomFactor = fract(sin(cubeIdx * 78.233) * 43758.5453);
                float randomStart = randomFactor * 20.0; // 0~20ì´ˆ ì‚¬ì´ ë¬´ì‘ìœ„ ì‹œì‘
                float randomGrowth = smoothstep(randomStart, randomStart + 12.0, timeSinceRecovery);
                
                return baseGrowth * randomGrowth * wavePattern;
            }
            
            void main() {
                // ì†Œë©¸ íš¨ê³¼ ê³„ì‚°
                float extinctionFactor = calculateExtinction(extinctionStartTime, currentTime);
                
                // ì¬ìƒì„± íš¨ê³¼ ê³„ì‚°
                float regenerationFactor = calculateRegeneration(cubeIndex, regenerationProgress);
                
                // ì¬ìƒì„± ê¸€ë¡œìš°
                vRegenerationGlow = 0.0;
                if (regenerationProgress > 0.0 && regenerationProgress < 1.0) {
                    float normalizedIndex = cubeIndex / 1000000.0;
                    float distance = abs(regenerationProgress - normalizedIndex);
                    if (distance < 0.02) {
                        vRegenerationGlow = (1.0 - distance / 0.02) * 2.0;
                    }
                }
                
                // ë¶•ê´´ íˆ¬ëª…ë„ ê³„ì‚°
                float collapseFactor = calculateCollapse(cubeIndex, collapseStartTime, currentTime);
                
                // ë³µêµ¬ íˆ¬ëª…ë„ ê³„ì‚°
                float recoveryFactor = calculateRecovery(cubeIndex, recoveryStartTime, currentTime);
                
                // ìµœì¢… íˆ¬ëª…ë„: ë¶•ê´´ í›„ ë³µêµ¬
                // ë³µêµ¬ê°€ ì‹œì‘ë˜ë©´ collapseFactorëŠ” ê±°ì˜ 0, recoveryFactorê°€ ì¦ê°€
                vOpacity = collapseFactor + recoveryFactor * (1.0 - collapseFactor);
                vOpacity = clamp(vOpacity, 0.0, 1.0);
                
                // ì†Œë©¸ íš¨ê³¼ ì ìš©
                vOpacity *= extinctionFactor;
                
                // ì¬ìƒì„± ì¤‘ì´ë©´ ì¬ìƒì„± íˆ¬ëª…ë„ë§Œ ì‚¬ìš©
                if (regenerationProgress > 0.0 && regenerationProgress < 1.0) {
                    vOpacity = regenerationFactor;
                } else if (regenerationProgress >= 1.0) {
                    // ì¬ìƒì„± ì™„ë£Œ í›„ ì •ìƒ íˆ¬ëª…ë„
                    vOpacity = 1.0;
                }
                
                vCubeIndex = cubeIndex;
                
                // ê¸°í•˜ê¸‰ìˆ˜ì  ê±°ë¦¬ ì¦ê°€ (1 ~ 3ë°°)
                float distanceMultiplier = 1.0 + separationFactor * 2.0;
                vec3 separatedPosition = basePosition * distanceMultiplier;
                
                // ê°ì—¼ ë ˆë²¨ ê³„ì‚°
                vInfectionLevel = calculateInfection(
                    basePosition, 
                    infectionOrigin, 
                    infectionStartTime, 
                    currentTime, 
                    infectionRadius
                );
                
                // ê°ì—¼ëœ íë¸ŒëŠ” íˆ¬ëª…ë„ ê°ì†Œ
                if (vInfectionLevel > 0.1) {
                    vOpacity *= (1.0 - vInfectionLevel * 0.9);
                }
                
                // í­ë°œ ì˜¤í”„ì…‹ ê³„ì‚°
                vec3 offset = explosionDirection * explosionDistance * explosionCycle;
                
                // ë¶•ê´´ ì‹œ ì•„ë˜ë¡œ ë–¨ì–´ì§€ëŠ” íš¨ê³¼ - ë” ì™„ë§Œí•˜ê²Œ
                float collapseFall = (1.0 - collapseFactor) * 30.0;
                
                // ë³µêµ¬ ì‹œ ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ì˜¤ëŠ” íš¨ê³¼ - ë” ì™„ë§Œí•˜ê²Œ
                float recoveryRise = recoveryFactor * 30.0 * (1.0 - collapseFactor);
                
                offset.y -= collapseFall;
                offset.y += recoveryRise;
                
                vec3 finalPosition = separatedPosition + offset;
                
                // E=MCÂ² ìƒëŒ€ì„±ì´ë¡  ì ìš©
                // ì´ì „ í”„ë ˆì„ ìœ„ì¹˜ ê³„ì‚° (ì‹œê°„ ì—­ì¶”ì )
                float prevTime = currentTime - 0.016; // 60fps ê¸°ì¤€
                vec3 prevOffset = explosionDirection * explosionDistance * explosionCycle;
                vec3 prevPosition = separatedPosition + prevOffset;
                
                // ì •ì§€ ì§ˆëŸ‰ (ê° íë¸Œë§ˆë‹¤ ê³ ìœ )
                float restMass = 1.0 + sin(cubeIndex * 0.01) * 0.2;
                
                // ìƒëŒ€ë¡ ì  ë¬¼ë¦¬ ê³„ì‚°
                float kineticEnergy, relativisticMass;
                vVelocity = calculateRelativisticPhysics(
                    finalPosition,
                    prevPosition,
                    0.016,
                    restMass,
                    kineticEnergy,
                    relativisticMass
                );
                
                vKineticEnergy = kineticEnergy;
                vRelativisticMass = relativisticMass / restMass; // ì •ê·œí™”
                
                // ì—ë„ˆì§€ì— ë”°ë¥¸ ìœ„ì¹˜ ë³€í˜• (ë†’ì€ ì—ë„ˆì§€ = ë” í° ì›€ì§ì„)
                float energyFactor = 1.0 + kineticEnergy * 0.1;
                finalPosition *= energyFactor;
                
                // í”„ë™íƒˆ ë³€í˜• ì ìš© (ë¶€ë“œëŸ½ê²Œ)
                if (fractalIntensity > 0.01) {
                    // 3D ìœ„ì¹˜ë¥¼ ë³µì†Œ í‰ë©´ì— ë§¤í•‘
                    vec2 complexPos = vec2(
                        finalPosition.x * 0.008 + fractalCenter.x,
                        finalPosition.z * 0.008 + fractalCenter.y
                    );
                    
                    // ì‹œê°„ì— ë”°ë¼ ë³€í™”í•˜ëŠ” ì¤„ë¦¬ì•„ ì§‘í•© íŒŒë¼ë¯¸í„°
                    vec2 juliaC = vec2(
                        -0.7 + sin(currentTime * 0.2) * 0.2,
                        0.27015 + cos(currentTime * 0.15) * 0.15
                    );
                    
                    // ë§Œë¸ë¸Œë¡œíŠ¸ ê³„ì‚°
                    float mandel = mandelbrot(complexPos, 12);
                    
                    // ì¤„ë¦¬ì•„ ê³„ì‚°
                    float juliaValue = julia(complexPos, juliaC, 12);
                    
                    // 3D ë§Œë¸ë¶ˆë¸Œ ê³„ì‚°
                    vec3 bulbPos = finalPosition * 0.015;
                    float bulbPower = 3.0 + sin(currentTime * 0.3) * 3.0;
                    float bulb = mandelbulb(bulbPos, bulbPower);
                    
                    // í”„ë™íƒˆ ê¹Šì´ ì €ì¥
                    vFractalDepth = mandel * juliaValue;
                    
                    // í”„ë™íƒˆì— ë”°ë¥¸ ìœ„ì¹˜ ë³€í˜• - ë” ë¶€ë“œëŸ½ê²Œ
                    float warp = (1.0 - mandel) * 8.0 * fractalIntensity;
                    float juliaWarp = (1.0 - juliaValue) * 6.0 * fractalIntensity;
                    float bulbWarp = bulb * 3.0 * fractalIntensity;
                    
                    // ë‹¤ì°¨ì›ì  ë³€í˜• - ì§„í­ ê°ì†Œ
                    finalPosition.x += sin(warp + currentTime * 0.5) * (warp + juliaWarp) * 0.8;
                    finalPosition.y += cos(warp * 1.2 - currentTime * 0.4) * (warp + bulbWarp) * 0.8;
                    finalPosition.z += sin(warp * 0.8 + currentTime * 0.3) * (juliaWarp + bulbWarp) * 0.8;
                    
                    // íšŒì „ íš¨ê³¼ ì¶”ê°€ - ë” ëŠë¦¬ê²Œ
                    float angle = mandel * 3.14159 * fractalIntensity * 0.5;
                    float c = cos(angle);
                    float s = sin(angle);
                    float x = finalPosition.x;
                    float z = finalPosition.z;
                    finalPosition.x = x * c - z * s;
                    finalPosition.z = x * s + z * c;
                    
                    // ìŠ¤ì¼€ì¼ ë³€í˜• - ë” ë¯¸ë¬˜í•˜ê²Œ
                    float scale = 1.0 + (1.0 - mandel) * 0.3 * fractalIntensity;
                    finalPosition *= scale;
                } else {
                    vFractalDepth = 0.5;
                }
                
                // ì§€êµ¬ ìì „ì²˜ëŸ¼ íšŒì „ (ê° íë¸Œë§ˆë‹¤ ë‹¤ë¥¸ ì†ë„)
                float rotationSpeed = 1.0 + sin(cubeIndex * 0.001) * 0.5;
                
                // ë¶•ê´´ ì‹œ íšŒì „ ê°€ì† - ë” ì™„ë§Œí•˜ê²Œ
                float collapseRotationBoost = (1.0 - collapseFactor) * 2.0;
                
                // ë³µêµ¬ ì‹œ íšŒì „ ê°ì† (ë¶€ë“œëŸ½ê²Œ ì •ìƒìœ¼ë¡œ) - ë” ì™„ë§Œí•˜ê²Œ
                float recoveryRotationDamping = recoveryFactor * 1.0;
                
                rotationSpeed *= (1.0 + collapseRotationBoost - recoveryRotationDamping);
                rotationSpeed = max(rotationSpeed, 0.3); // ìµœì†Œ ì†ë„ ë³´ì¥
                
                float angleY = rotationTime * rotationSpeed;
                float angleX = rotationTime * rotationSpeed * 0.7;
                float angleZ = rotationTime * rotationSpeed * 0.3;
                
                // íšŒì „ í–‰ë ¬ ì ìš©
                mat3 rotation = rotateY(angleY) * rotateX(angleX) * rotateZ(angleZ);
                vec3 rotatedPosition = rotation * position;
                
                // ìµœì¢… ë³€í™˜
                vec3 transformed = rotatedPosition + finalPosition;
                
                // ì›”ë“œ ì¢Œí‘œ
                vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);
                vPosition = worldPosition.xyz;
                
                // ë·° ì¢Œí‘œ (ì¹´ë©”ë¼ ê¸°ì¤€)
                vec4 viewPosition = viewMatrix * worldPosition;
                vViewPosition = viewPosition.xyz;
                
                // íšŒì „ëœ ë²•ì„ 
                vNormal = normalize(normalMatrix * rotation * normal);
                
                // í­ë°œ ê°•ë„
                vExplosion = explosionCycle;
                
                // ìƒ‰ìƒ ì „ë‹¬
                vColor = cubeColor;
                
                // ìµœì¢… ìœ„ì¹˜
                gl_Position = projectionMatrix * viewPosition;
            }
        `;
        
        // Fragment Shader - ì‹¤ì œ ì¡°ëª… ê³„ì‚° + ì™¸ê³½ì„  + ë¶•ê´´
        const fragmentShader = `
            uniform vec3 baseColor;
            uniform float time;
            uniform vec3 lightPositions[7];
            uniform vec3 lightColors[7];
            uniform float lightIntensities[7];
            uniform float fractalIntensity;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vExplosion;
            varying vec3 vColor;
            varying vec3 vViewPosition;
            varying float vOpacity;
            varying float vCubeIndex;
            varying float vFractalDepth;
            varying float vInfectionLevel;
            varying float vKineticEnergy;
            varying float vRelativisticMass;
            varying vec3 vVelocity;
            varying float vRegenerationGlow;
            
            void main() {
                // ë¶•ê´´ ì‹œ ë²„ë¦¬ê¸° ì¡°ê±´ ì™„í™” (ê±°ì˜ ì‚¬ë¼ì§€ì§€ ì•ŠìŒ)
                if (vOpacity < 0.02) discard;
                
                vec3 finalColor = vec3(0.0);
                
                // Ambient ê¸°ë³¸ ì¡°ëª…
                vec3 ambient = vColor * 0.3;
                
                // ê° í¬ì¸íŠ¸ ë¼ì´íŠ¸ ê³„ì‚°
                for (int i = 0; i < 7; i++) {
                    vec3 lightDir = normalize(lightPositions[i] - vPosition);
                    float distance = length(lightPositions[i] - vPosition);
                    
                    // Diffuse
                    float diff = max(dot(vNormal, lightDir), 0.0);
                    
                    // Attenuation (ê±°ë¦¬ ê°ì‡ )
                    float attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0001 * distance * distance);
                    
                    // ë¼ì´íŠ¸ ê¸°ì—¬ë„
                    vec3 diffuse = lightColors[i] * diff * lightIntensities[i] * attenuation;
                    finalColor += diffuse;
                }
                
                // í­ë°œ ì‹œ ê¸€ë¡œìš° íš¨ê³¼
                float glow = vExplosion * 0.5;
                finalColor += vec3(0.0, glow, glow);
                
                // ë¶•ê´´ ì‹œ ê¸€ë¡œìš° (ì‚¬ë¼ì§€ëŠ” ë¹› - ì‹œì•ˆ)
                float collapseFactor = 1.0 - vOpacity;
                if (vOpacity < 0.5) {
                    float collapseGlow = collapseFactor * 0.8;
                    finalColor += vec3(collapseGlow * 0.5, collapseGlow * 0.8, collapseGlow);
                }
                
                // ë³µêµ¬ ì‹œ ê¸€ë¡œìš° (ìƒì„±ë˜ëŠ” ë¹› - ì´ˆë¡)
                if (vOpacity > 0.1 && vOpacity < 0.8) {
                    float recoveryGlow = vOpacity * 0.6;
                    finalColor += vec3(recoveryGlow * 0.3, recoveryGlow, recoveryGlow * 0.3);
                }
                
                // ìµœì¢… ìƒ‰ìƒ
                finalColor = (ambient + finalColor) * vColor;
                
                // ì¬ìƒì„± í™©ê¸ˆìƒ‰ íš¨ê³¼
                if (vRegenerationGlow > 0.01) {
                    // í™©ê¸ˆìƒ‰ (ê³¨ë“œ)
                    vec3 goldenColor = vec3(1.0, 0.84, 0.0);
                    
                    // ê°•ë ¬í•œ í™©ê¸ˆë¹› ê¸€ë¡œìš°
                    vec3 goldenGlow = goldenColor * vRegenerationGlow * 3.0;
                    
                    // ì¬ìƒì„± ì „ì„ ì—ì„œ ë¹›ë‚¨
                    finalColor = mix(finalColor, goldenColor, vRegenerationGlow * 0.8);
                    finalColor += goldenGlow;
                    
                    // í„ìŠ¤ íš¨ê³¼
                    float pulse = sin(time * 10.0) * 0.3 + 0.7;
                    finalColor *= pulse;
                }
                
                // E=MCÂ² ì—ë„ˆì§€ ì‹œê°í™”
                if (vKineticEnergy > 0.01) {
                    // ë†’ì€ ìš´ë™ ì—ë„ˆì§€ = ë°ì€ ê¸€ë¡œìš°
                    float energyGlow = vKineticEnergy * 2.0;
                    
                    // ì²­ë°±ìƒ‰ ê¸€ë¡œìš° (ì²´ë Œì½”í”„ ë³µì‚¬)
                    vec3 cherenkovColor = vec3(0.3, 0.6, 1.0) * energyGlow;
                    finalColor += cherenkovColor;
                    
                    // ì†ë„ ë°©í–¥ì— ë”°ë¥¸ ìƒ‰ìƒ ì´ë™ (ë„í”ŒëŸ¬ íš¨ê³¼)
                    float velocityFactor = length(vVelocity) / 100.0;
                    if (velocityFactor > 0.1) {
                        // ë¹ ë¥¸ íë¸ŒëŠ” íŒŒë€ìƒ‰ìœ¼ë¡œ ì´ë™
                        finalColor.b += velocityFactor * 0.5;
                        finalColor.r -= velocityFactor * 0.2;
                    }
                    
                    // ì§ˆëŸ‰ ì¦ê°€ íš¨ê³¼ (ë°ê¸° ì¦ê°€)
                    float massIncrease = (vRelativisticMass - 1.0);
                    if (massIncrease > 0.01) {
                        finalColor *= (1.0 + massIncrease * 0.5);
                    }
                }
                
                // ê°ì—¼ íš¨ê³¼ (ê²€ì€ íë¸Œë¡œ ë³€í•¨)
                if (vInfectionLevel > 0.01) {
                    // ê°ì—¼ ì „ì„  ê¸€ë¡œìš° (ë¶‰ì€ë¹›)
                    float infectionFrontGlow = 0.0;
                    if (vInfectionLevel > 0.05 && vInfectionLevel < 0.95) {
                        // ì „ì„  ê°ì§€
                        float frontStrength = sin(vInfectionLevel * 3.14159);
                        infectionFrontGlow = frontStrength * 0.8;
                        
                        // ë¶‰ì€ ê¸€ë¡œìš° + í„ìŠ¤ íš¨ê³¼
                        vec3 infectionGlow = vec3(1.0, 0.1, 0.0) * infectionFrontGlow;
                        infectionGlow *= (1.0 + sin(time * 5.0) * 0.3);
                        finalColor += infectionGlow;
                    }
                    
                    // ê°ì—¼ëœ ë¶€ë¶„ì€ ê²€ì€ìƒ‰ìœ¼ë¡œ (ì„œì„œíˆ)
                    vec3 infectedColor = vec3(0.05, 0.05, 0.05); // ê±°ì˜ ê²€ì€ìƒ‰
                    finalColor = mix(finalColor, infectedColor, vInfectionLevel);
                    
                    // ê°ì—¼ ì§„í–‰ì— ë”°ë¥¸ ì–´ë‘ìš´ í„ìŠ¤
                    float darkPulse = sin(time * 3.0 + vCubeIndex * 0.01) * 0.05;
                    finalColor *= (1.0 - vInfectionLevel * 0.5 + darkPulse);
                }
                
                // í”„ë™íƒˆ ìƒ‰ìƒ ë³€ì¡° (ë” ë¯¸ë¬˜í•˜ê²Œ)
                if (fractalIntensity > 0.01) {
                    // í”„ë™íƒˆ ê¹Šì´ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€í™”
                    float hueShift = vFractalDepth * 0.2;
                    vec3 fractalColor = vec3(
                        0.5 + 0.5 * sin(vFractalDepth * 6.28 + time * 0.5),
                        0.5 + 0.5 * sin(vFractalDepth * 6.28 + time * 0.5 + 2.09),
                        0.5 + 0.5 * sin(vFractalDepth * 6.28 + time * 0.5 + 4.18)
                    );
                    
                    // í”„ë™íƒˆ ê¸€ë¡œìš° - ë” ë¯¸ë¬˜í•˜ê²Œ
                    float fractalGlow = (1.0 - vFractalDepth) * fractalIntensity * 0.4;
                    finalColor += fractalColor * fractalGlow;
                    
                    // ê°€ì¥ìë¦¬ ê°•ì¡° - ë” ë¶€ë“œëŸ½ê²Œ
                    if (vFractalDepth < 0.3) {
                        float edgeGlow = (0.3 - vFractalDepth) * 2.0 * fractalIntensity;
                        finalColor += vec3(1.0, 0.5, 1.0) * edgeGlow;
                    }
                    
                    // ìƒ‰ìƒ í˜¼í•© - ë” ë¯¸ë¬˜í•˜ê²Œ
                    finalColor = mix(finalColor, fractalColor, fractalIntensity * 0.15);
                }
                
                // ì™¸ê³½ì„  íš¨ê³¼ (Fresnel/Rim Lighting)
                vec3 viewDir = normalize(-vViewPosition);
                float rimFactor = 1.0 - max(dot(vNormal, viewDir), 0.0);
                rimFactor = pow(rimFactor, 3.0);
                
                // ê°€ì¥ìë¦¬ë¥¼ ê²€ì€ìƒ‰ìœ¼ë¡œ
                vec3 edgeColor = vec3(0.0, 0.0, 0.0);
                float edgeWidth = 0.3;
                
                if (rimFactor > (1.0 - edgeWidth)) {
                    float edgeStrength = (rimFactor - (1.0 - edgeWidth)) / edgeWidth;
                    finalColor = mix(finalColor, edgeColor, edgeStrength);
                }
                
                gl_FragColor = vec4(finalColor, vOpacity);
            }
        `;
        
        // Three.js ì´ˆê¸°í™”
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // ì•ˆê°œ ë†ë„ ê°ì†Œ
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 2000);
            camera.position.set(120, 120, 120); // ë” ë©€ë¦¬ì„œ ì‹œì‘
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: false, // ì„±ëŠ¥ì„ ìœ„í•´ ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ë”
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setClearColor(0x000000, 1);
            
            // ë ˆì´ìºìŠ¤í„° ì´ˆê¸°í™”
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 6ê°œ í¬ì¸íŠ¸ ë¼ì´íŠ¸
            const lightColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0080, 0x00ff80, 0xff8000];
            const lightPositions = [
                [80, 80, 80], [-80, -80, -80], [80, -80, -80], 
                [-80, 80, 80], [0, 100, 0], [0, -100, 0]
            ];
            
            for (let i = 0; i < 6; i++) {
                const light = new THREE.PointLight(lightColors[i], 5, 500); // 300 -> 500
                light.position.set(...lightPositions[i]);
                light.userData = {
                    baseIntensity: 5,
                    basePosition: new THREE.Vector3(...lightPositions[i]),
                    orbitSpeed: 0.2 + Math.random() * 0.3,
                    orbitRadius: 15,
                    orbitPhase: Math.random() * Math.PI * 2
                };
                scene.add(light);
                lights.push(light);
            }
            
            // ì¤‘ì•™ ê¸€ë¡œìš°
            const centerLight = new THREE.PointLight(0x00ffff, 5, 300); // 200 -> 300
            centerLight.position.set(0, 0, 0);
            centerLight.userData = {
                baseIntensity: 5,
                isCenterGlow: true
            };
            scene.add(centerLight);
            lights.push(centerLight);
            
            // GPU ê¸°ë°˜ InstancedMesh ìƒì„±
            createGPUInstancedCubes();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            window.addEventListener('resize', onWindowResize);
            document.getElementById('gameCanvas').addEventListener('mousedown', onMouseDown);
            document.getElementById('gameCanvas').addEventListener('mousemove', onMouseMove);
            document.getElementById('gameCanvas').addEventListener('mouseup', onMouseUp);
            document.getElementById('gameCanvas').addEventListener('click', onClick);
            document.getElementById('gameCanvas').addEventListener('wheel', onWheel);
            
            // ì¼ì‹œì •ì§€ ë²„íŠ¼
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            
            // í„°ì¹˜ ì´ë²¤íŠ¸
            document.getElementById('gameCanvas').addEventListener('touchstart', onTouchStart, { passive: false });
            document.getElementById('gameCanvas').addEventListener('touchmove', onTouchMove, { passive: false });
            document.getElementById('gameCanvas').addEventListener('touchend', onTouchEnd, { passive: false });
            
            animate();
        }
        
        // GPU ê¸°ë°˜ InstancedMesh ìƒì„±
        function createGPUInstancedCubes() {
            console.log('Creating 1,000,000 cubes with GPU Compute...');
            
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            
            // Custom Shader Material
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    explosionCycle: { value: 0 },
                    explosionDistance: { value: 80.0 },
                    baseColor: { value: new THREE.Color(0x00ffff) },
                    lightPositions: { value: [] },
                    lightColors: { value: [] },
                    lightIntensities: { value: [] },
                    rotationTime: { value: 0 },
                    separationFactor: { value: 0 },
                    collapseStartTime: { value: -1 },
                    recoveryStartTime: { value: -1 },
                    currentTime: { value: 0 },
                    fractalIntensity: { value: 0 },
                    fractalCenter: { value: new THREE.Vector2(0, 0) },
                    infectionStartTime: { value: -1 },
                    infectionOrigin: { value: new THREE.Vector3(0, 0, 0) },
                    infectionRadius: { value: 0 },
                    extinctionStartTime: { value: -1 },
                    regenerationStartTime: { value: -1 },
                    regenerationProgress: { value: 0 }
                },
                transparent: true,
                side: THREE.DoubleSide
            });
            
            cubeMesh = new THREE.InstancedMesh(geometry, material, TOTAL_CUBES);
            
            // ì¸ìŠ¤í„´ìŠ¤ë³„ ì†ì„± ì¤€ë¹„
            const basePositions = new Float32Array(TOTAL_CUBES * 3);
            const explosionDirections = new Float32Array(TOTAL_CUBES * 3);
            const cubeIndices = new Float32Array(TOTAL_CUBES);
            const cubeColors = new Float32Array(TOTAL_CUBES * 3);
            
            let index = 0;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let z = 0; z < GRID_SIZE; z++) {
                        const posX = (x - GRID_SIZE / 2) * CUBE_GAP;
                        const posY = (y - GRID_SIZE / 2) * CUBE_GAP;
                        const posZ = (z - GRID_SIZE / 2) * CUBE_GAP;
                        
                        // ê¸°ë³¸ ìœ„ì¹˜
                        basePositions[index * 3] = posX;
                        basePositions[index * 3 + 1] = posY;
                        basePositions[index * 3 + 2] = posZ;
                        
                        // í­ë°œ ë°©í–¥ (ì •ê·œí™”)
                        const length = Math.sqrt(posX * posX + posY * posY + posZ * posZ);
                        if (length > 0) {
                            explosionDirections[index * 3] = posX / length;
                            explosionDirections[index * 3 + 1] = posY / length;
                            explosionDirections[index * 3 + 2] = posZ / length;
                        }
                        
                        cubeIndices[index] = index;
                        
                        // ë‹¤ì–‘í•œ ìƒ‰ìƒ (ë¬´ì§€ê°œ ê·¸ë¼ë°ì´ì…˜)
                        const hue = (x / GRID_SIZE + y / GRID_SIZE * 0.5 + z / GRID_SIZE * 0.3) % 1.0;
                        const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                        cubeColors[index * 3] = color.r;
                        cubeColors[index * 3 + 1] = color.g;
                        cubeColors[index * 3 + 2] = color.b;
                        
                        // ëª¨ë“  íë¸Œ ìœ„ì¹˜ ì €ì¥ (ì •í™•í•œ ì¶©ëŒ ê°ì§€ìš©)
                        cubeData.push({
                            x, y, z,
                            index: index,
                            position: new THREE.Vector3(posX, posY, posZ),
                            basePosition: new THREE.Vector3(posX, posY, posZ),
                            explosionDirection: new THREE.Vector3(
                                length > 0 ? posX / length : 0,
                                length > 0 ? posY / length : 0,
                                length > 0 ? posZ / length : 0
                            ),
                            active: true
                        });
                        
                        index++;
                    }
                }
            }
            
            // BufferAttributeë¡œ GPUì— ì „ì†¡
            geometry.setAttribute('basePosition', new THREE.InstancedBufferAttribute(basePositions, 3));
            geometry.setAttribute('explosionDirection', new THREE.InstancedBufferAttribute(explosionDirections, 3));
            geometry.setAttribute('cubeIndex', new THREE.InstancedBufferAttribute(cubeIndices, 1));
            geometry.setAttribute('cubeColor', new THREE.InstancedBufferAttribute(cubeColors, 3));
            
            scene.add(cubeMesh);
            
            console.log('âœ… GPU Compute setup complete! 1,000,000 cubes with rainbow colors ready.');
        }
        
        // ì¼ì‹œì •ì§€/ì¬ê°œ
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pausedTime = Date.now();
                btn.textContent = 'â–¶ RESUME';
                btn.classList.add('paused');
            } else {
                const pauseDuration = Date.now() - pausedTime;
                totalPausedDuration += pauseDuration;
                
                // ëª¨ë“  ì‹œê°„ ê¸°ì¤€ì ì„ ì¡°ì •
                gameStartTime += pauseDuration;
                lastExplosionTime += pauseDuration;
                lastSeparationTime += pauseDuration;
                
                btn.textContent = 'â¸ PAUSE';
                btn.classList.remove('paused');
            }
        }
        
        // ë¶•ê´´ íŒŒí‹°í´ ìƒì„±
        function createCollapseParticles() {
            if (!collapseTriggered || recoveryTriggered) return;
            
            // ëœë¤í•˜ê²Œ ëª‡ ê°œ ìœ„ì¹˜ì—ì„œ íŒŒí‹°í´ ìƒì„±
            for (let i = 0; i < 5; i++) {
                const randomCube = cubeData[Math.floor(Math.random() * cubeData.length)];
                if (!randomCube) continue;
                
                const position = randomCube.position.clone();
                
                // ì‘ì€ íŒŒí‹°í´ë“¤
                for (let j = 0; j < 3; j++) {
                    const geometry = new THREE.SphereGeometry(0.08, 3, 3);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.15, 0.8, 0.5), // ì£¼í™©ìƒ‰ (ê²½ê³ )
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    particle.position.copy(position);
                    particle.position.x += (Math.random() - 0.5) * 2;
                    particle.position.y += (Math.random() - 0.5) * 2;
                    particle.position.z += (Math.random() - 0.5) * 2;
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.3,
                            Math.random() * 0.5 - 0.8, // ì£¼ë¡œ ì•„ë˜ë¡œ
                            (Math.random() - 0.5) * 0.3
                        ),
                        life: 40,
                        maxLife: 40
                    };
                    
                    scene.add(particle);
                    explosionParticles.push(particle);
                }
            }
        }
        
        // ë³µêµ¬ íŒŒí‹°í´ ìƒì„±
        function createRecoveryParticles() {
            if (!recoveryTriggered) return;
            
            // ëœë¤í•˜ê²Œ ëª‡ ê°œ ìœ„ì¹˜ì—ì„œ íŒŒí‹°í´ ìƒì„±
            for (let i = 0; i < 8; i++) {
                const randomCube = cubeData[Math.floor(Math.random() * cubeData.length)];
                if (!randomCube) continue;
                
                const position = randomCube.position.clone();
                
                // ì´ˆë¡ìƒ‰ ìƒëª… íŒŒí‹°í´ë“¤
                for (let j = 0; j < 4; j++) {
                    const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.35, 0.9, 0.6), // ì´ˆë¡ìƒ‰ (ìƒëª…)
                        transparent: true,
                        opacity: 0.9
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    particle.position.copy(position);
                    particle.position.x += (Math.random() - 0.5) * 3;
                    particle.position.y += (Math.random() - 0.5) * 3 - 10; // ì•„ë˜ì—ì„œ ì‹œì‘
                    particle.position.z += (Math.random() - 0.5) * 3;
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            Math.random() * 0.5 + 0.6, // ì£¼ë¡œ ìœ„ë¡œ
                            (Math.random() - 0.5) * 0.2
                        ),
                        life: 50,
                        maxLife: 50,
                        hue: 0.35
                    };
                    
                    scene.add(particle);
                    explosionParticles.push(particle);
                }
            }
        }
        
        // ê°ì—¼ íŒŒí‹°í´ ìƒì„±
        function createInfectionParticles() {
            if (!infectionTriggered) return;
            
            // ê°ì—¼ ì „ì„ ì—ì„œ íŒŒí‹°í´ ìƒì„±
            const timeSinceInfection = (Date.now() - gameStartTime - INFECTION_TRIGGER_TIME) / 1000;
            const currentRadius = timeSinceInfection * 10; // í™•ì‚° ì†ë„
            
            // êµ¬ í‘œë©´ì—ì„œ ëœë¤ ìœ„ì¹˜
            for (let i = 0; i < 12; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const position = new THREE.Vector3(
                    infectionOrigin.x + currentRadius * Math.sin(phi) * Math.cos(theta),
                    infectionOrigin.y + currentRadius * Math.sin(phi) * Math.sin(theta),
                    infectionOrigin.z + currentRadius * Math.cos(phi)
                );
                
                // ê²€ì€ íŒŒí‹°í´ë“¤ (ê°ì—¼)
                const geometry = new THREE.SphereGeometry(0.12, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(0.1, 0.0, 0.0), // ì–´ë‘ìš´ ë¹¨ê°•
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                
                // ë°”ê¹¥ìª½ìœ¼ë¡œ í¼ì ¸ë‚˜ê°
                const direction = position.clone().sub(infectionOrigin).normalize();
                
                particle.userData = {
                    velocity: direction.multiplyScalar(0.3),
                    life: 30,
                    maxLife: 30
                };
                
                scene.add(particle);
                explosionParticles.push(particle);
            }
        }
        
        // í™©ê¸ˆ ì¬ìƒì„± íŒŒí‹°í´ ìƒì„±
        function createRegenerationParticles() {
            if (!regenerationTriggered || regenerationProgress >= 1.0) return;
            
            // ì¬ìƒì„± ì „ì„ ì—ì„œ í™©ê¸ˆ íŒŒí‹°í´ ìƒì„±
            const regeneratedCubes = Math.floor(regenerationProgress * TOTAL_CUBES);
            
            // ëœë¤í•˜ê²Œ ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ìƒì„±
            for (let i = 0; i < 20; i++) {
                const randomIndex = Math.floor(Math.random() * regeneratedCubes);
                if (randomIndex >= cubeData.length) continue;
                
                const randomCube = cubeData[randomIndex];
                if (!randomCube) continue;
                
                const position = randomCube.position.clone();
                
                // í™©ê¸ˆìƒ‰ íŒŒí‹°í´ë“¤
                const geometry = new THREE.SphereGeometry(0.15, 6, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(1.0, 0.84, 0.0), // ìˆœê¸ˆìƒ‰
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.position.x += (Math.random() - 0.5) * 2;
                particle.position.y += (Math.random() - 0.5) * 2;
                particle.position.z += (Math.random() - 0.5) * 2;
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.8 + 0.5, // ìœ„ë¡œ ìƒìŠ¹
                        (Math.random() - 0.5) * 0.5
                    ),
                    life: 40,
                    maxLife: 40,
                    isGolden: true
                };
                
                scene.add(particle);
                explosionParticles.push(particle);
            }
        }
        
        // í­ë°œ ì´í™íŠ¸ ê°•í™” - í™”ë ¤í•œ íš¨ê³¼
        function createFastExplosion(position) {
            const particleCount = 20; // 15ì—ì„œ 20ìœ¼ë¡œ ì¦ê°€
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.15, 4, 4);
                
                // ë‹¤ì–‘í•œ ìƒ‰ìƒ (ì‹œì•ˆ, ë§ˆì  íƒ€, ì˜ë¡œìš°)
                const hue = 0.5 + Math.random() * 0.3; // ì‹œì•ˆ~ë§ˆì  íƒ€ ë²”ìœ„
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 1.0, 0.7),
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 1.0 + Math.random() * 0.6;
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.sin(phi) * Math.sin(theta) * speed,
                        Math.cos(phi) * speed
                    ),
                    life: 35,
                    maxLife: 35,
                    hue: hue
                };
                
                scene.add(particle);
                explosionParticles.push(particle);
            }
            
            // í­ë°œ í”Œë˜ì‹œ ë¼ì´íŠ¸ - ë” ë°ê³  í™”ë ¤í•˜ê²Œ
            const colors = [0x00ffff, 0xff00ff, 0xffff00];
            colors.forEach((color, idx) => {
                setTimeout(() => {
                    const explosionLight = new THREE.PointLight(color, 25, 60);
                    explosionLight.position.copy(position);
                    scene.add(explosionLight);
                    
                    let lightLife = 8;
                    const lightInterval = setInterval(() => {
                        lightLife--;
                        explosionLight.intensity = (lightLife / 8) * 25;
                        if (lightLife <= 0) {
                            clearInterval(lightInterval);
                            scene.remove(explosionLight);
                        }
                    }, 20);
                }, idx * 30);
            });
        }
        
        // ë ˆì´ì € ë°œì‚¬ - ì¶©ëŒ ê°ì§€ ê°œì„ 
        function fireLaser(clickPoint) {
            const origin = camera.position.clone();
            const direction = clickPoint.clone().sub(origin).normalize();
            
            // ë ˆì´ì € ë¹” - ë” êµµê³  ë°ê²Œ
            const laserGeometry = new THREE.CylinderGeometry(0.4, 0.4, 200, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.95
            });
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            
            laser.position.copy(origin).add(direction.clone().multiplyScalar(100));
            laser.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
            
            laser.userData = { life: 20 };
            scene.add(laser);
            laserBeams.push(laser);
            
            // ë ˆì´ì € ë°œì‚¬ í”Œë˜ì‹œ ë¼ì´íŠ¸
            const flashLight = new THREE.PointLight(0x00ffff, 30, 150);
            flashLight.position.copy(origin).add(direction.clone().multiplyScalar(50));
            scene.add(flashLight);
            
            setTimeout(() => scene.remove(flashLight), 150);
            
            // ì¶©ëŒ ê²€ì‚¬ - ë ˆì´ ê¸°ë°˜ ì •í™•í•œ ê²€ì‚¬
            raycaster.set(origin, direction);
            
            const hitCubes = [];
            const checkDistance = 200; // ê²€ì‚¬ ê±°ë¦¬
            const hitRadius = 3.0; // íˆíŠ¸ ë°˜ê²½
            
            // ìƒ˜í”Œë§ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™” (10ê°œ ì¤‘ 1ê°œë§Œ ê²€ì‚¬)
            for (let i = 0; i < cubeData.length; i += 10) {
                const cube = cubeData[i];
                if (!cube.active) continue;
                
                // ë ˆì´ì™€ íë¸Œ ì¤‘ì‹¬ì˜ ê±°ë¦¬ ê³„ì‚°
                const distance = raycaster.ray.distanceToPoint(cube.position);
                const distanceFromCamera = origin.distanceTo(cube.position);
                
                if (distance < hitRadius && distanceFromCamera < checkDistance) {
                    hitCubes.push(cube);
                }
            }
            
            // ê±°ë¦¬ìˆœ ì •ë ¬
            hitCubes.sort((a, b) => {
                return origin.distanceTo(a.position) - origin.distanceTo(b.position);
            });
            
            // ìµœëŒ€ 100ê°œë§Œ í­ë°œ
            const explosionCount = Math.min(hitCubes.length, 100);
            
            // í­ë°œ íš¨ê³¼
            for (let i = 0; i < explosionCount; i++) {
                const cube = hitCubes[i];
                createFastExplosion(cube.position.clone());
                cube.active = false;
            }
            
            // íˆíŠ¸ ìˆ˜ í‘œì‹œ
            console.log(`ğŸ¯ ë ˆì´ì € íˆíŠ¸: ${explosionCount}ê°œ íë¸Œ íŒŒê´´! (ê²€ì‚¬: ${Math.floor(cubeData.length / 10)}ê°œ)`);
        }
        
        // í´ë¦­ ì´ë²¤íŠ¸
        function onClick(event) {
            if (!gameStarted || mouseMoved) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const clickPoint = new THREE.Vector3();
            raycaster.ray.at(20, clickPoint);
            
            fireLaser(clickPoint);
        }
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        function onMouseDown(event) {
            isDragging = true;
            mouseMoved = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    mouseMoved = true;
                }
                
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                
                const axis = new THREE.Vector3(1, 0, 0);
                axis.applyQuaternion(camera.quaternion);
                camera.position.applyAxisAngle(axis, deltaY * 0.005);
                
                camera.lookAt(0, 0, 0);
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onWheel(event) {
            event.preventDefault();
            const delta = event.deltaY * 0.02;
            const direction = camera.position.clone().normalize();
            camera.position.add(direction.multiplyScalar(delta));
            
            const distance = camera.position.length();
            // ìµœì†Œ ê±°ë¦¬ 0.5ë¡œ ì„¤ì • (íë¸Œ ë‚´ë¶€ ì§„ì… ê°€ëŠ¥)
            // ìµœëŒ€ ê±°ë¦¬ 400ìœ¼ë¡œ í™•ì¥ (ë¶„ë¦¬ ì‹œ ì „ì²´ ì¡°ë§)
            if (distance < 0.5) camera.position.normalize().multiplyScalar(0.5);
            else if (distance > 400) camera.position.normalize().multiplyScalar(400);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // í„°ì¹˜ ì´ë²¤íŠ¸
        let touchStartPos = { x: 0, y: 0 };
        let touchStartDistance = 0;
        let touchMoved = false;
        
        function onTouchStart(event) {
            touchMoved = false;
            if (event.touches.length === 1) {
                touchStartPos = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                isDragging = false;
            } else if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            touchMoved = true;
            
            if (event.touches.length === 1) {
                isDragging = true;
                const deltaX = event.touches[0].clientX - touchStartPos.x;
                const deltaY = event.touches[0].clientY - touchStartPos.y;
                
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                
                const axis = new THREE.Vector3(1, 0, 0);
                axis.applyQuaternion(camera.quaternion);
                camera.position.applyAxisAngle(axis, deltaY * 0.005);
                
                camera.lookAt(0, 0, 0);
                
                touchStartPos = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            } else if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const delta = (distance - touchStartDistance) * 0.05;
                
                const direction = camera.position.clone().normalize();
                camera.position.add(direction.multiplyScalar(-delta));
                
                const cameraDistance = camera.position.length();
                // í„°ì¹˜ ì¤Œë„ ë™ì¼í•˜ê²Œ 0.5 ~ 400
                if (cameraDistance < 0.5) camera.position.normalize().multiplyScalar(0.5);
                else if (cameraDistance > 400) camera.position.normalize().multiplyScalar(400);
                
                touchStartDistance = distance;
            }
        }
        
        function onTouchEnd(event) {
            if (event.touches.length === 0) isDragging = false;
            
            if (event.changedTouches.length === 1 && gameStarted && !touchMoved) {
                const touch = event.changedTouches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                const clickPoint = new THREE.Vector3();
                raycaster.ray.at(20, clickPoint);
                
                fireLaser(clickPoint);
            }
            
            touchMoved = false;
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            
            // ì¼ì‹œì •ì§€ ì‹œ ë Œë”ë§ë§Œ ìˆ˜í–‰
            if (isPaused) {
                renderer.render(scene, camera);
                return;
            }
            
            // FPS ì¸¡ì •
            frames++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frames * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frames = 0;
                lastTime = currentTime;
                
                // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
                if (gameStarted) {
                    const elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    const timerText = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (regenerationTriggered) {
                        const percent = Math.floor(regenerationProgress * 100);
                        document.getElementById('timer').innerHTML = `<span style="color:#FFD700; background:#000000; padding:2px 8px;">âœ¨ REBIRTH ${percent}%! ${timerText}</span>`;
                    } else if (extinctionTriggered) {
                        document.getElementById('timer').innerHTML = `<span style="color:#000000; background:#ffffff; padding:2px 8px;">ğŸ’€ EXTINCTION! ${timerText}</span>`;
                    } else if (infectionTriggered) {
                        document.getElementById('timer').innerHTML = `<span style="color:#000000; background:#ff0000; padding:2px 8px;">ğŸ¦  INFECTION! ${timerText}</span>`;
                    } else if (recoveryTriggered) {
                        document.getElementById('timer').innerHTML = `<span style="color:#00ff00">âœ¨ RECOVERY! ${timerText}</span>`;
                    } else if (collapseTriggered) {
                        document.getElementById('timer').innerHTML = `<span style="color:#ff0000">âš ï¸ COLLAPSE! ${timerText}</span>`;
                    } else if (fractalTriggered && fractalIntensity > 0.1) {
                        document.getElementById('timer').innerHTML = `<span style="color:#ff00ff">ğŸŒ€ FRACTAL! ${timerText}</span>`;
                    } else if (elapsedSeconds >= 65) {
                        document.getElementById('timer').innerHTML = `<span style="color:#ffff00">âš ï¸ ${timerText}</span>`;
                    } else {
                        document.getElementById('timer').textContent = timerText;
                    }
                }
            }
            
            const time = Date.now() * 0.001;
            const currentGameTime = Date.now();
            
            // 10ì´ˆ í›„ í”„ë™íƒˆ ì‹œì‘
            if (!fractalTriggered && gameStarted) {
                const timeSinceStart = currentGameTime - gameStartTime;
                if (timeSinceStart >= FRACTAL_TRIGGER_TIME) {
                    fractalTriggered = true;
                    console.log('ğŸŒ€ í”„ë™íƒˆ ë³€í˜• ì‹œì‘! Fractal transformation initiated!');
                }
            }
            
            // í”„ë™íƒˆ ê°•ë„ ê³„ì‚° (ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œ ì¸/ì•„ì›ƒ)
            if (fractalTriggered) {
                const timeSinceFractal = currentGameTime - gameStartTime - FRACTAL_TRIGGER_TIME;
                const cycleDuration = FRACTAL_CYCLE_DURATION;
                const cycleTime = timeSinceFractal % cycleDuration;
                
                if (cycleTime < FRACTAL_FADE_IN) {
                    // í˜ì´ë“œ ì¸ (0 -> 1)
                    const progress = cycleTime / FRACTAL_FADE_IN;
                    fractalIntensity = progress * progress * (3 - 2 * progress); // smoothstep
                } else if (cycleTime < cycleDuration - FRACTAL_FADE_OUT) {
                    // ìµœëŒ€ ìœ ì§€
                    fractalIntensity = 1.0;
                } else {
                    // í˜ì´ë“œ ì•„ì›ƒ (1 -> 0)
                    const fadeOutStart = cycleDuration - FRACTAL_FADE_OUT;
                    const progress = (cycleTime - fadeOutStart) / FRACTAL_FADE_OUT;
                    fractalIntensity = 1.0 - progress * progress * (3 - 2 * progress); // smoothstep
                }
            }
            
            // 50ì´ˆ í›„ ë¶•ê´´ ì‹œì‘
            if (!collapseTriggered && gameStarted) {
                const timeSinceStart = currentGameTime - gameStartTime;
                if (timeSinceStart >= COLLAPSE_TRIGGER_TIME) {
                    collapseTriggered = true;
                    collapseStartTime = time;
                    console.log('ğŸ ë²Œ êµ°ì§‘ ë¶•ê´´ ì‹œì‘! Colony Collapse Disorder triggered!');
                }
            }
            
            // ë¶•ê´´ ì™„ë£Œ í›„ ë³µêµ¬ ì‹œì‘ (ë¶•ê´´ ì‹œì‘ 60ì´ˆ í›„)
            if (collapseTriggered && !recoveryTriggered && gameStarted) {
                const timeSinceCollapse = currentGameTime - gameStartTime - COLLAPSE_TRIGGER_TIME;
                if (timeSinceCollapse >= COLLAPSE_DURATION) {
                    recoveryTriggered = true;
                    recoveryStartTime = time;
                    console.log('âœ¨ êµ°ì§‘ ë³µêµ¬ ì‹œì‘! Colony Recovery initiated!');
                }
            }
            
            // 140ì´ˆ í›„ ê°ì—¼ ì‹œì‘
            if (!infectionTriggered && gameStarted) {
                const timeSinceStart = currentGameTime - gameStartTime;
                if (timeSinceStart >= INFECTION_TRIGGER_TIME) {
                    infectionTriggered = true;
                    infectionStartTime = time;
                    
                    // ë¬´ì‘ìœ„ ìœ„ì¹˜ì—ì„œ ê°ì—¼ ì‹œì‘
                    infectionOrigin.set(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );
                    
                    console.log('ğŸ¦  ì„¸í¬ ì¦ì‹ ê°ì—¼ ì‹œì‘! Cellular infection initiated!', infectionOrigin);
                }
            }
            
            // 180ì´ˆ í›„ ì†Œë©¸ ì‹œì‘
            if (!extinctionTriggered && gameStarted) {
                const timeSinceStart = currentGameTime - gameStartTime;
                if (timeSinceStart >= EXTINCTION_TRIGGER_TIME) {
                    extinctionTriggered = true;
                    extinctionStartTime = time;
                    console.log('ğŸ’€ ì™„ì „ ì†Œë©¸ ì‹œì‘! Total extinction initiated!');
                }
            }
            
            // ì†Œë©¸ ì™„ë£Œ í›„ ì¬ìƒì„± ì‹œì‘
            if (extinctionTriggered && !regenerationTriggered && gameStarted) {
                const timeSinceExtinction = currentGameTime - gameStartTime - EXTINCTION_TRIGGER_TIME;
                if (timeSinceExtinction >= EXTINCTION_DURATION) {
                    regenerationTriggered = true;
                    regenerationStartTime = time;
                    regenerationProgress = 0;
                    console.log('âœ¨ í™©ê¸ˆ ì¬ìƒì„± ì‹œì‘! Golden regeneration initiated!');
                }
            }
            
            // ì¬ìƒì„± ì§„í–‰ë„ ì—…ë°ì´íŠ¸
            if (regenerationTriggered && gameStarted) {
                const timeSinceRegeneration = currentGameTime - gameStartTime - EXTINCTION_TRIGGER_TIME - EXTINCTION_DURATION;
                regenerationProgress = Math.min(timeSinceRegeneration / REGENERATION_DURATION, 1.0);
                
                // ì¬ìƒì„± ì™„ë£Œ í›„ ëª¨ë“  ìƒíƒœ ë¦¬ì…‹
                if (regenerationProgress >= 1.0 && timeSinceRegeneration >= REGENERATION_DURATION + 1000) {
                    console.log('ğŸ”„ ìˆœí™˜ ì™„ë£Œ! ìƒˆë¡œìš´ ì‚¬ì´í´ ì‹œì‘! Cycle complete! New cycle starting!');
                    
                    // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
                    gameStartTime = Date.now();
                    lastExplosionTime = Date.now();
                    lastSeparationTime = Date.now();
                    
                    collapseTriggered = false;
                    collapseStartTime = -1;
                    recoveryTriggered = false;
                    recoveryStartTime = -1;
                    
                    infectionTriggered = false;
                    infectionStartTime = -1;
                    
                    extinctionTriggered = false;
                    extinctionStartTime = -1;
                    
                    regenerationTriggered = false;
                    regenerationStartTime = -1;
                    regenerationProgress = 0;
                    
                    fractalTriggered = false;
                    fractalIntensity = 0;
                }
            }
            
            // íšŒì „ ì‹œê°„ (ê³„ì† ì¦ê°€)
            rotationTime += 0.01;
            
            // ë¶„ë¦¬ ì‚¬ì´í´ ê³„ì‚° (30ì´ˆë§ˆë‹¤)
            const separationCurrentTime = Date.now();
            const timeSinceLastSeparation = separationCurrentTime - lastSeparationTime;
            
            if (timeSinceLastSeparation >= SEPARATION_INTERVAL) {
                lastSeparationTime = separationCurrentTime;
            }
            
            const separationCycleTime = timeSinceLastSeparation % SEPARATION_INTERVAL;
            
            if (separationCycleTime < SEPARATION_DURATION) {
                // ë¶„ë¦¬ ì¤‘ (0 -> 1) - smoothstep
                const progress = separationCycleTime / SEPARATION_DURATION;
                separationCycle = progress * progress * (3 - 2 * progress);
            } else if (separationCycleTime < SEPARATION_DURATION * 2) {
                // ì¬ê²°í•© ì¤‘ (1 -> 0) - smoothstep
                const progress = (separationCycleTime - SEPARATION_DURATION) / SEPARATION_DURATION;
                separationCycle = 1.0 - progress * progress * (3 - 2 * progress);
            } else {
                separationCycle = 0;
            }
            
            // í­ë°œ ì‚¬ì´í´ ê³„ì‚°
            const explosionCurrentTime = Date.now();
            const timeSinceLastExplosion = explosionCurrentTime - lastExplosionTime;
            
            if (timeSinceLastExplosion >= EXPLOSION_INTERVAL) {
                lastExplosionTime = explosionCurrentTime;
            }
            
            const cycleTime = timeSinceLastExplosion % EXPLOSION_INTERVAL;
            
            if (cycleTime < EXPLOSION_DURATION) {
                const progress = cycleTime / EXPLOSION_DURATION;
                // smoothstepìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ ì¦ê°€/ê°ì†Œ
                if (progress < 0.5) {
                    const t = progress * 2;
                    explosionCycle = t * t * (3 - 2 * t);
                } else {
                    const t = (progress - 0.5) * 2;
                    explosionCycle = 1.0 - t * t * (3 - 2 * t);
                }
            } else {
                explosionCycle = 0;
            }
            
            // GPU Uniform ì—…ë°ì´íŠ¸
            if (cubeMesh && cubeMesh.material.uniforms) {
                cubeMesh.material.uniforms.time.value = time;
                cubeMesh.material.uniforms.explosionCycle.value = explosionCycle;
                cubeMesh.material.uniforms.rotationTime.value = rotationTime;
                cubeMesh.material.uniforms.separationFactor.value = separationCycle;
                cubeMesh.material.uniforms.collapseStartTime.value = collapseStartTime;
                cubeMesh.material.uniforms.recoveryStartTime.value = recoveryStartTime;
                cubeMesh.material.uniforms.currentTime.value = time;
                cubeMesh.material.uniforms.fractalIntensity.value = fractalIntensity;
                
                // í”„ë™íƒˆ ì¤‘ì‹¬ì„ ì‹œê°„ì— ë”°ë¼ ì´ë™
                cubeMesh.material.uniforms.fractalCenter.value.set(
                    Math.sin(time * 0.1) * 0.5,
                    Math.cos(time * 0.15) * 0.5
                );
                
                // ê°ì—¼ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
                cubeMesh.material.uniforms.infectionStartTime.value = infectionStartTime;
                cubeMesh.material.uniforms.infectionOrigin.value.copy(infectionOrigin);
                
                // ê°ì—¼ ë°˜ê²½ ê³„ì‚°
                if (infectionTriggered) {
                    const timeSinceInfection = currentGameTime - gameStartTime - INFECTION_TRIGGER_TIME;
                    cubeMesh.material.uniforms.infectionRadius.value = timeSinceInfection / 100; // í™•ì‚° ì†ë„
                }
                
                // ì†Œë©¸/ì¬ìƒì„± ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
                cubeMesh.material.uniforms.extinctionStartTime.value = extinctionStartTime;
                cubeMesh.material.uniforms.regenerationStartTime.value = regenerationStartTime;
                cubeMesh.material.uniforms.regenerationProgress.value = regenerationProgress;
                
                // ì¡°ëª… ì •ë³´ ì—…ë°ì´íŠ¸
                const lightPos = [];
                const lightCol = [];
                const lightInt = [];
                
                for (let i = 0; i < lights.length; i++) {
                    lightPos.push(lights[i].position);
                    lightCol.push(new THREE.Vector3(
                        lights[i].color.r,
                        lights[i].color.g,
                        lights[i].color.b
                    ));
                    lightInt.push(lights[i].intensity);
                }
                
                cubeMesh.material.uniforms.lightPositions.value = lightPos;
                cubeMesh.material.uniforms.lightColors.value = lightCol;
                cubeMesh.material.uniforms.lightIntensities.value = lightInt;
            }
            
            // íë¸Œ ìœ„ì¹˜ ë™ê¸°í™” (ì¶©ëŒ ê°ì§€ìš©)
            const explosionDistance = 80;
            const distanceMultiplier = 1.0 + separationCycle * 2.0;
            
            for (let i = 0; i < cubeData.length; i++) {
                const cube = cubeData[i];
                if (!cube.active) continue;
                
                // ë¶„ë¦¬ ì ìš©
                const separatedBase = cube.basePosition.clone().multiplyScalar(distanceMultiplier);
                
                // í­ë°œ ì˜¤í”„ì…‹
                const offset = cube.explosionDirection.clone().multiplyScalar(explosionDistance * explosionCycle);
                
                cube.position.copy(separatedBase).add(offset);
            }
            
            // ì¡°ëª… ì• ë‹ˆë©”ì´ì…˜
            for (let i = 0; i < lights.length; i++) {
                const light = lights[i];
                
                if (light.userData.isCenterGlow) {
                    // ì¤‘ì•™ ê¸€ë¡œìš° - í­ë°œ ì‹œ ê°•í•˜ê²Œ
                    light.intensity = light.userData.baseIntensity + explosionCycle * 15;
                } else if (light.userData.basePosition) {
                    // ê¶¤ë„ íšŒì „ ë¼ì´íŠ¸
                    const orbitAngle = time * light.userData.orbitSpeed + light.userData.orbitPhase;
                    const orbitX = Math.cos(orbitAngle) * light.userData.orbitRadius;
                    const orbitZ = Math.sin(orbitAngle) * light.userData.orbitRadius;
                    
                    light.position.x = light.userData.basePosition.x + orbitX;
                    light.position.z = light.userData.basePosition.z + orbitZ;
                    
                    // í­ë°œ ì‹œ ê°•ë„ ì¦ê°€
                    light.intensity = light.userData.baseIntensity * (1 + explosionCycle * 2);
                }
            }
            
            // í­ë°œ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                particle.userData.life--;
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                    continue;
                }
                
                particle.position.add(particle.userData.velocity);
                
                const lifeRatio = particle.userData.life / particle.userData.maxLife;
                particle.material.opacity = lifeRatio;
                
                // ìƒ‰ìƒ ë³€í™” - ì‹œê°„ì— ë”°ë¼ ë³€í•¨
                if (particle.userData.hue !== undefined) {
                    particle.userData.hue = (particle.userData.hue + 0.01) % 1.0;
                    particle.material.color.setHSL(particle.userData.hue, 1.0, 0.7);
                }
            }
            
            // ë¶•ê´´ íŒŒí‹°í´ ìƒì„± (1ì´ˆì— í•œ ë²ˆ)
            if (collapseTriggered && !recoveryTriggered && frames % 60 === 0) {
                createCollapseParticles();
            }
            
            // ë³µêµ¬ íŒŒí‹°í´ ìƒì„± (0.5ì´ˆì— í•œ ë²ˆ)
            if (recoveryTriggered && frames % 30 === 0) {
                createRecoveryParticles();
            }
            
            // ê°ì—¼ íŒŒí‹°í´ ìƒì„± (0.3ì´ˆì— í•œ ë²ˆ)
            if (infectionTriggered && frames % 18 === 0) {
                createInfectionParticles();
            }
            
            // í™©ê¸ˆ ì¬ìƒì„± íŒŒí‹°í´ ìƒì„± (0.1ì´ˆì— í•œ ë²ˆ, ë§¤ìš° ë¹ ë¥´ê²Œ)
            if (regenerationTriggered && regenerationProgress < 1.0 && frames % 6 === 0) {
                createRegenerationParticles();
            }
            
            // ë ˆì´ì € ë¹” ì—…ë°ì´íŠ¸
            for (let i = laserBeams.length - 1; i >= 0; i--) {
                const laser = laserBeams[i];
                laser.userData.life--;
                
                if (laser.userData.life <= 0) {
                    scene.remove(laser);
                    laserBeams.splice(i, 1);
                } else {
                    laser.material.opacity = laser.userData.life / 20;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // ì´ˆê¸°í™”
        init();
    </script>
</body>
</html>
