<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Celeste ëŠë‚Œ í”Œë«í¬ë¨¸ (í¼ì¦ êµ¬ê°„/ì •ì±… í† ê¸€/ê½ƒë¹„+í­ì£½)</title>
  <style>
    :root{
      --bg:#bfe4ff;
      --ink:#1d1d1f;
      --shadow: rgba(0,0,0,.18);
      --hud: rgba(255,255,255,.78);
      --hud2: rgba(255,255,255,.55);
    }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; touch-action:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif; }
    #wrap{ position:fixed; inset:0; }
    canvas{ width:100%; height:100%; display:block; }

    #hud{
      position:fixed; inset:0;
      pointer-events:none;
      color:var(--ink);
      text-shadow: 0 2px 0 rgba(0,0,0,.08);
    }
    #hud .row{
      position:absolute; left:0; right:0;
      display:flex; justify-content:space-between; align-items:center;
      padding: 14px 16px;
      gap: 12px;
    }
    #hud .left, #hud .right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill{
      background: var(--hud);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 999px;
      padding: 8px 12px;
      display:inline-flex; align-items:center; gap:8px;
      backdrop-filter: blur(8px);
    }
    .small{ font-size:12px; opacity:.85; }
    .kbd{
      display:inline-block;
      min-width: 18px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 2px 0 rgba(0,0,0,.08);
      font-weight: 700;
      font-size: 12px;
      line-height: 1.4;
      margin: 0 2px;
    }
    .clickable{
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
    }
    .onTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(35, 199, 99, .18);
      border: 1px solid rgba(35, 199, 99, .25);
    }
    .offTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255, 99, 99, .18);
      border: 1px solid rgba(255, 99, 99, .25);
    }

    #subtitle{
      position:absolute;
      left: 16px;
      right: 16px;
      bottom: 16px;
      background: var(--hud2);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      font-size: 12px;
      line-height: 1.55;
      opacity: 1;
      transform: translateY(0);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
    }
    #subtitle.subHidden{
      opacity:0;
      transform: translateY(10px);
    }
    #infoPill{
      display:none;
      width: 36px; height: 36px;
      padding: 0;
      justify-content:center;
      font-size: 16px;
    }
    #toast{
      position:absolute;
      left:50%; top: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      color:white;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 18px;
      opacity:0;
      transition: opacity .12s ease;
      white-space:nowrap;
      pointer-events:none;
    }

    #bigMsg{
      position:fixed;
      left:50%; top:38%;
      transform: translate(-50%,-50%);
      padding: 18px 22px;
      border-radius: 18px;
      background: rgba(253, 47, 143, .71); //rgba(253, 47, 143, 0.71)
      color: #fff;
      font-weight: 700;
      font-size: 30px;
      letter-spacing: .5px;
      box-shadow: 0 18px 60px rgba(0,0,0,.25);
      opacity: 0;
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
      text-align:center;
      white-space:nowrap;
    }
    #bigMsg.on{
      opacity: 1;
      transform: translate(-50%,-50%) scale(1.02);
    }

    #touch{ position:fixed; inset:0; pointer-events:none; display:none; }
    #touch .btn{
      pointer-events:auto;
      width: 64px; height: 64px;
      border-radius: 18px;
      background: rgba(255,255,255,.70);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      backdrop-filter: blur(8px);
    }
    #touch .cluster{ position:absolute; bottom: 16px; display:flex; gap: 10px; }
    #touch .leftCluster{ left: 16px; }
    #touch .rightCluster{ right: 16px; }
    #touch .col{ display:flex; flex-direction:column; gap:10px; }
  
    /* ë¡œë”© ì˜¤ë²„ë ˆì´ */
    #loader{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(10,12,18,.70);
      z-index:9999;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    #loader .panel{
      width:min(420px, 86vw);
      padding:18px 18px 14px;
      border-radius:16px;
      background:rgba(255,255,255,.92);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.10);
    }
    #loader .title{
      font-weight:900;
      letter-spacing:.4px;
      text-align:center;
      margin-bottom:12px;
    }
    #loader .bar{
      height:12px;
      border-radius:999px;
      background:rgba(0,0,0,.10);
      overflow:hidden;
    }
    #barFill{
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg, rgba(0,255,200,.95), rgba(120,220,255,.95), rgba(180,120,255,.95));
      transition: width .12s ease;
    }


    /* ëª¨ë°”ì¼ ê°€ë³€ UI */
    @media (max-width: 768px){
      #hud .row{
        padding: calc(10px + env(safe-area-inset-top)) 12px 10px;
        gap: 10px;
      }
      .pill{ padding: 7px 10px; }
      #touch .cluster{ bottom: calc(14px + env(safe-area-inset-bottom)); }
      #touch .leftCluster{ left: calc(14px + env(safe-area-inset-left)); }
      #touch .rightCluster{ right: calc(14px + env(safe-area-inset-right)); }
      #touch .btn{
        width: clamp(52px, 11vw, 82px);
        height: clamp(52px, 11vw, 82px);
        border-radius: clamp(14px, 3.8vw, 22px);
        font-size: clamp(18px, 4.8vw, 30px);
      }
      /* ëª¨ë°”ì¼ì—ì„œëŠ” ë„ì›€ë§ì´ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ì„ ê°€ë¦¬ì§€ ì•Šë„ë¡ ìœ„ë¡œ ì˜¬ë¦¼ */
      #subtitle{ bottom: calc(118px + env(safe-area-inset-bottom)); }
      #infoPill{ width: 34px; height: 34px; font-size: 16px; }
    }
    @media (orientation: landscape) and (max-height: 480px){
      #touch .cluster{ bottom: calc(10px + env(safe-area-inset-bottom)); }
      #subtitle{ bottom: calc(96px + env(safe-area-inset-bottom)); font-size: 11px; }
    }
    @media (max-width: 420px){
      #subtitle{ bottom: calc(138px + env(safe-area-inset-bottom)); }
    }

</style>
</head>

<body>
  <div id="wrap"></div>

  <!-- ë¡œë”© ì˜¤ë²„ë ˆì´: ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„ ì‹œì‘ -->
  <div id="loader" aria-label="ë¡œë”©">
    <div class="panel">
      <div class="title">Loading...</div>
      <div class="bar"><div id="barFill"></div></div>
      <div id="loadText" class="small" style="opacity:.85; text-align:center; margin-top:10px;">ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘</div>
    </div>
  </div>

  <div id="hud">
    <div class="row">
      <div class="left">
        <div class="pill">
          <span style="font-weight:900">ğŸª™</span>
          <span id="coinText" style="font-weight:900">0</span>
        </div>
        <div class="pill small" id="stageText">ë ˆë²¨ 1</div>

        <div class="pill small clickable" id="policyPill" title="í´ë¦­í•´ì„œ í† ê¸€ (ë‹¨ì¶•í‚¤: H/C)" style="display:none">
          <span style="font-weight:900">ì •ì±…</span>
          <span>HP</span><span id="hpPolicyTag" class="onTag">ìœ ì§€</span>
          <span>ì½”ì¸</span><span id="coinPolicyTag" class="onTag">ìœ ì§€</span>
        </div>

        <div class="pill small">
          <span style="font-weight:900">ëŒ€ì‹œ</span>
          <span id="dashText">1/1</span>
        </div>
        <div class="pill small" id="bossHpWrap" style="display:none">
          <span style="font-weight:900">BOSS</span>
          <span id="bossHpText" style="font-weight:900">â– â– â– â– â– </span>
          <span id="bossLvText" class="small" style="opacity:.75">Lv1</span>
        </div>
        <div class="pill small clickable" id="soundPill" title="ì‚¬ìš´ë“œ í† ê¸€: í´ë¦­=ì „ì²´ ON/OFF, M=ë®¤ì§, N=SFX, +/-=ë³¼ë¥¨">
          <span id="soundIcon" style="font-weight:900">ğŸ”Š</span>
          <span id="soundLabel" style="font-weight:900">ON</span>
          <span id="soundVolText" class="small" style="opacity:.75">85%</span>
        </div>
      </div>

      <div class="right">
        <div class="pill clickable" id="infoPill" title="ì¡°ì‘/ì„¤ëª… ë³´ê¸°">â„¹ï¸</div>
        <div class="pill" id="heartWrap" aria-label="ìƒëª…">
          <span id="hearts" style="color:red">â¤â¤â¤â¤â¤â¤</span>
        </div>
      </div>
    </div>

    <div id="toast">ì¤€ë¹„!</div>

    <div id="subtitle">
      ì´ë™ <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">â†</span><span class="kbd">â†’</span> Â·
      ì í”„ <span class="kbd">Space</span> Â·
      ìˆ™ì´ê¸° <span class="kbd">S</span>/<span class="kbd">â†“</span> (ì¶©ëŒ ë°•ìŠ¤â†“) Â·
      ëŒ€ì‹œ <span class="kbd">X</span> (ëŒ€ì²´: <span class="kbd">K</span>, 8ë°©í–¥, ê³µì¤‘ 1íšŒ) Â·
      ìŠ¬ë¼ì´ë“œ <span class="kbd">â†“</span>+<span class="kbd">X</span> Â·
      ë²½ìŠ¬ë¼ì´ë“œ(ë²½ì— ë¶™ìœ¼ë©´) â†’ <span class="kbd">Space</span> ë²½ì í”„ Â·
      ì‚¬ë‹¤ë¦¬ <span class="kbd">W</span><span class="kbd">S</span> / <span class="kbd">â†‘</span><span class="kbd">â†“</span> Â·
      ì •ì±… í† ê¸€ <span class="kbd">H</span>(HP) <span class="kbd">C</span>(ì½”ì¸) Â· ì¬ì‹œì‘ <span class="kbd">R</span> Â· ì‚¬ìš´ë“œ <span class="kbd">M</span>(ë®¤ì§) <span class="kbd">N</span>(SFX) <span class="kbd">+</span>/<span class="kbd">-</span>(ë³¼ë¥¨)
    </div>
  </div>

  <div id="bigMsg">Congratuation !!</div>

  <div id="touch">
    <div class="cluster leftCluster">
      <div class="btn" id="tLeft">â—€</div>
      <div class="btn" id="tRight">â–¶</div>
    </div>

    <div class="cluster rightCluster">
      <div class="col">
        <div class="btn" id="tUp">â–²</div>
        <div class="btn" id="tDown">â–¼</div>
      </div>
      <div class="col">
        <div class="btn" id="tJump">â¤´</div>
        <div class="btn" id="tDash">âŸ¶</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // ----------------------------
    // ê²Œì„ ìƒíƒœ
    // ----------------------------
    // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§ ë¦¬ìŠ¤í° ë”œë ˆì´: 1.5ì´ˆ
    const RESPAWN_DELAY = 3.5;
    // ì‹œì‘/ë¦¬ìŠ¤í° ì‹œ "ë¿…" ë“±ì¥ ëª¨ì…˜
    const SPAWN_DUR = 2.82;

    const game = {
      level: 1,
      levelSeed: 1,
      difficulty: 1.0,
      bossDifficulty: 1,
      pendingNextLevel: 2,
      respawnBoss: false,
      // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§í•˜ë©´ ë¬´ì¡°ê±´ HP 5ë¡œ íšŒë³µ
      forceFullHP: false,
      state: "play",     // play | celebrate | bossIntro | boss | bossDefeat | next | respawn
      t: 0,
      // ì—°ì¶œ ìŠ¤í° íƒ€ì´ë¨¸
      flowerRainT: 0,
      fireworkT: 0,
    };
	
	
	// ----------------------------
    // ìœ í‹¸
    // ----------------------------

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const sign = (v)=> (v>0)-(v<0);

    // ì´ì§•(ë“±ì¥/ì‚¬ë§ ì—°ì¶œ)
    const easeOutCubic = (t)=>1 - Math.pow(1-t, 3);
    const easeOutBack = (t)=>{
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
    };

    // ----------------------------
    // ë‚œìˆ˜(ì‹œë“œ ê¸°ë°˜)
    //  - "ë‚˜ë…¸ì´ˆ" ì •ë°€ë„ëŠ” ë¸Œë¼ìš°ì €/í™˜ê²½ì— ë”°ë¼ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
    //  - performance.timeOrigin + performance.now()ë¥¼ ns(í™˜ì‚°)ë¡œ ë³´ê³  32bit ì‹œë“œë¥¼ ë§Œë“­ë‹ˆë‹¤.
    // ----------------------------
    let RNG_SEED = 1 >>> 0;

    function seedFromNano(extra = 0){
      const tMs = (performance.timeOrigin || 0) + performance.now(); // ms

      // ns(í™˜ì‚°) ì •ë°€ë„ëŠ” í™˜ê²½ì— ë”°ë¼ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
      // BigInt ì—†ì´ë„ ë™ì‘í•˜ë„ë¡, ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ì¼€ì¼/ì†Œìˆ˜ë¶€ë¥¼ ì„ì–´ 32bit ì‹œë“œë¥¼ ë§Œë“­ë‹ˆë‹¤.
      const a = (tMs * 1000) | 0;      // us-ish
      const b = (tMs * 1000000) | 0;   // ns-ish (í•˜ìœ„ë¹„íŠ¸ ìœ„ì£¼)
      let s = (a ^ (b << 11) ^ (b >>> 7) ^ (extra >>> 0)) >>> 0;

      // xorshift ë¯¹ì‹±
      s ^= (s << 13) >>> 0;
      s ^= (s >>> 17) >>> 0;
      s ^= (s << 5) >>> 0;
      RNG_SEED = (s >>> 0) || 1;
      return RNG_SEED;
    }


    function seedRng(seed){
      RNG_SEED = (seed >>> 0) || 1;
    }

    function rng(){
      // xorshift32
      let x = RNG_SEED >>> 0;
      x ^= (x << 13) >>> 0;
      x ^= (x >>> 17) >>> 0;
      x ^= (x << 5) >>> 0;
      RNG_SEED = x >>> 0;
      return RNG_SEED / 4294967296;
    }

    const rand = (a,b)=>a + rng()*(b-a);
    const choice = (arr)=>arr[(rng()*arr.length)|0];


    function moveTowards(current, target, maxDelta){
      const d = target - current;
      if(Math.abs(d) <= maxDelta) return target;
      return current + Math.sign(d) * maxDelta;
    }
	function aabbIntersect(ax,ay,aw,ah, bx,by,bw,bh, eps=1e-5){
	  return ax < bx + bw - eps &&
			 ax + aw > bx + eps &&
			 ay < by + bh - eps &&
			 ay + ah > by + eps;
	}


    // ----------------------------
    // HUD
    // ----------------------------
    const $coinText = document.getElementById("coinText");
    const $hearts = document.getElementById("hearts");
    const $toast = document.getElementById("toast");
    const $stageText = document.getElementById("stageText");
    const $bigMsg = document.getElementById("bigMsg");
    const $dashText = document.getElementById("dashText");
    const $bossHpWrap = document.getElementById("bossHpWrap");
    const $bossHpText = document.getElementById("bossHpText");
    const $bossLvText = document.getElementById("bossLvText");

    const $soundPill = document.getElementById("soundPill");
    const $soundIcon = document.getElementById("soundIcon");
    const $soundLabel = document.getElementById("soundLabel");
    const $soundVolText = document.getElementById("soundVolText");


    const $policyPill = document.getElementById("policyPill");
    const $hpPolicyTag = document.getElementById("hpPolicyTag");
    const $coinPolicyTag = document.getElementById("coinPolicyTag");

    let toastT = 0;
    function showToast(msg, ms=1000){
      $toast.textContent = msg;
      toastT = ms/1000;
      $toast.style.opacity = "1";
    }
    function showBigMsg(on, msg=null){
      if(msg != null) $bigMsg.textContent = msg;
      if(on) $bigMsg.classList.add("on");
      else $bigMsg.classList.remove("on");
    }

    // ----------------------------
    // ì •ì±…(ìœ ì§€/ë¦¬ì…‹)
    // ----------------------------
    const policy = {
      keepHP: true,
      keepCoins: true,
    };
    function syncPolicyUI(){
      $hpPolicyTag.className = policy.keepHP ? "onTag" : "offTag";
      $hpPolicyTag.textContent = policy.keepHP ? "ìœ ì§€" : "ë¦¬ì…‹";
      $coinPolicyTag.className = policy.keepCoins ? "onTag" : "offTag";
      $coinPolicyTag.textContent = policy.keepCoins ? "ìœ ì§€" : "ë¦¬ì…‹";
      showToast(`ì •ì±…: HP ${policy.keepHP?"ìœ ì§€":"ë¦¬ì…‹"} / ì½”ì¸ ${policy.keepCoins?"ìœ ì§€":"ë¦¬ì…‹"}`, 900);
    }
    $policyPill.addEventListener("click", ()=>{
      // í´ë¦­ì€ ë‘˜ ë‹¤ í† ê¸€
      policy.keepHP = !policy.keepHP;
      policy.keepCoins = !policy.keepCoins;
      syncPolicyUI();

    
    });

// ----------------------------
    // ì‚¬ìš´ë“œ(ë¸Œë¼ìš°ì € ì œì•½: ì²« ì…ë ¥ í›„ ì‹œì‘)
    // - BGM/SFXëŠ” WebAudioë¡œ "ì§ì ‘ í•©ì„±"(ì €ì‘ê¶Œ ì´ìŠˆ ì—†ìŒ)
    // ----------------------------
    const sound = {
      enabled: true,
      musicEnabled: true,
      sfxEnabled: true,
      masterVol: 0.85,
      musicVol: 0.45,
      sfxVol: 0.85,

      ctx: null,
      master: null,
      musicBus: null,
      sfxBus: null,
      comp: null,
      convolver: null,
      noiseBuf: null,

      started: false,
      bgmTimer: null,
      bgmNextT: 0,
      bgmStep: 0,
      bpm: 124,
      rng: null,

      last: Object.create(null),
    };

    // ë¡œì»¬ ì €ì¥(ì„ íƒ)
    (function loadSoundSettings(){
      try{
        const v = JSON.parse(localStorage.getItem("pm_sound_v1") || "null");
        if(v){
          sound.enabled = !!v.enabled;
          sound.musicEnabled = !!v.musicEnabled;
          sound.sfxEnabled = !!v.sfxEnabled;
          sound.masterVol = clamp(+v.masterVol || 0.85, 0, 1);
          sound.musicVol = clamp(+v.musicVol || 0.45, 0, 1);
          sound.sfxVol   = clamp(+v.sfxVol   || 0.85, 0, 1);
        }
      }catch(_){}
    })();

    function saveSoundSettings(){
      try{
        localStorage.setItem("pm_sound_v1", JSON.stringify({
          enabled: sound.enabled,
          musicEnabled: sound.musicEnabled,
          sfxEnabled: sound.sfxEnabled,
          masterVol: sound.masterVol,
          musicVol: sound.musicVol,
          sfxVol: sound.sfxVol,
        }));
      }catch(_){}
    }

    function syncSoundUI(){
      if(!$soundPill) return;
      const on = sound.enabled;
      const icon = on ? "ğŸ”Š" : "ğŸ”‡";
      $soundIcon.textContent = icon;
      $soundLabel.textContent = on ? "ON" : "OFF";
      const pct = Math.round(sound.masterVol*100);
      $soundVolText.textContent = pct + "%";
      $soundPill.style.opacity = on ? "1" : "0.65";
    }

    function nowNanoSeed32(){
      // "ë‚˜ë…¸ì´ˆ"ëŠ” ë¸Œë¼ìš°ì €/OSì— ë”°ë¼ ì •ë°€ë„ê°€ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
      // ëŒ€ì‹  Date.now(ms) + performance.now(ì„œë¸Œms)ë¥¼ ì„ì–´ 32ë¹„íŠ¸ ì‹œë“œë¡œ ì‚¬ìš©.
      const epochMs = BigInt(Date.now());
      const perf = performance.now();
      const fracNs = BigInt(Math.floor((perf - Math.floor(perf)) * 1e6)); // 0~999,999ns ê·¼ì‚¬
      const ns = epochMs * 1000000n + fracNs; // epoch ê¸°ì¤€ ns(ê·¼ì‚¬)
      let x = Number(ns & 0xffffffffn) >>> 0;
      x ^= x << 13; x >>>= 0;
      x ^= x >>> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return x >>> 0;
    }

    function mulberry32(a){
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

    function makeImpulse(ctx, dur=1.2, decay=2.4){
      const rate = ctx.sampleRate;
      const len = Math.floor(rate * dur);
      const buf = ctx.createBuffer(2, len, rate);
      for(let c=0;c<2;c++){
        const data = buf.getChannelData(c);
        for(let i=0;i<len;i++){
          const t = i/len;
          const amp = Math.pow(1 - t, decay);
          data[i] = (Math.random()*2-1) * amp;
        }
      }
      return buf;
    }

    function makeNoiseBuffer(ctx){
      const len = Math.floor(ctx.sampleRate * 1.2);
      const buf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i] = Math.random()*2 - 1;
      return buf;
    }

    function applySoundGains(){
      // âœ… MP3 BGM ë³¼ë¥¨/í† ê¸€(ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì—†ì´ë„ ì ìš©)
      if(sound.bgmEl){
        const v = (sound.enabled && sound.musicEnabled) ? clamp(sound.masterVol * sound.musicVol, 0, 1) : 0;
        try{ sound.bgmEl.volume = v; }catch(_){}
        if(v <= 0.0001){
          try{ sound.bgmEl.pause(); }catch(_){}
        }else if(sound.started){
          // autoplay ì •ì±…: ì²« ì…ë ¥ ì´í›„(sound.started)ë§Œ ì¬ìƒ ì‹œë„
          sound.bgmEl.play().catch(()=>{});
        }
      }

      // SFXëŠ” WebAudio ë²„ìŠ¤ì— ì ìš©
      if(sound.ctx){
        sound.master.gain.setTargetAtTime(sound.enabled ? sound.masterVol : 0, sound.ctx.currentTime, 0.02);
        sound.musicBus.gain.setTargetAtTime((sound.enabled && sound.musicEnabled) ? sound.musicVol : 0, sound.ctx.currentTime, 0.02);
        sound.sfxBus.gain.setTargetAtTime((sound.enabled && sound.sfxEnabled) ? sound.sfxVol : 0, sound.ctx.currentTime, 0.02);
      }

      syncSoundUI();
      saveSoundSettings();
    }


    function ensureAudio(){
      if(sound.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if(!Ctx) return;

      const ctx = new Ctx();
      sound.ctx = ctx;

      sound.master = ctx.createGain();
      sound.musicBus = ctx.createGain();
      sound.sfxBus = ctx.createGain();

      sound.master.gain.value = sound.masterVol;
      sound.musicBus.gain.value = sound.musicVol;
      sound.sfxBus.gain.value = sound.sfxVol;

      // ë¦¬ë¯¸í„°/ì»´í”„ë ˆì„œë¡œ "ê²½ì¾Œ+ê³ ìŒì§ˆ" ëŠë‚Œ(í´ë¦¬í•‘ ë°©ì§€)
      sound.comp = ctx.createDynamicsCompressor();
      sound.comp.threshold.value = -18;
      sound.comp.knee.value = 18;
      sound.comp.ratio.value = 4.2;
      sound.comp.attack.value = 0.006;
      sound.comp.release.value = 0.14;

      // ë¦¬ë²„ë¸Œ(ê°€ë²¼ìš´ ê³µê°„ê°)
      sound.convolver = ctx.createConvolver();
      sound.convolver.buffer = makeImpulse(ctx, 1.15, 2.2);
      const rv = ctx.createGain();
      rv.gain.value = 0.22;

      // ë¼ìš°íŒ…
      sound.musicBus.connect(rv);
      rv.connect(sound.convolver);
      sound.convolver.connect(sound.master);

      sound.musicBus.connect(sound.master);
      sound.sfxBus.connect(sound.master);

      sound.master.connect(sound.comp);
      sound.comp.connect(ctx.destination);

      sound.noiseBuf = makeNoiseBuffer(ctx);

      // BGMìš© RNG(ë ˆë²¨ë§ˆë‹¤ seed ê°±ì‹  ê°€ëŠ¥)
      sound.rng = mulberry32(nowNanoSeed32());

      applySoundGains();
        syncSoundUI();
        saveSoundSettings();
      syncSoundUI();
    }

    function unlockAudio(){
      if(!sound.enabled) return;
      ensureAudio();
      if(!sound.ctx) return;
      if(sound.ctx.state === "suspended"){
        sound.ctx.resume().catch(()=>{});
      }
      if(!sound.started){
        startBGM();
        sound.started = true;
      }
    }

    // --- ì•…ê¸° ê¸°ë³¸ ---
    function envGain(g, t, a=0.004, d=0.08, s=0.0, r=0.06, peak=1.0){
      g.gain.cancelScheduledValues(t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(peak, t+a);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, peak*(0.25+s)), t+a+d);
      g.gain.exponentialRampToValueAtTime(0.0001, t+a+d+r);
    }

    function playOsc({t,freq=440,dur=0.12,type="triangle",gain=0.22,detune=0,slideTo=null,slideTime=0.06,filterHz=null,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const out = bus || sound.musicBus;

      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      if(slideTo){
        o.frequency.exponentialRampToValueAtTime(Math.max(20, slideTo), t + slideTime);
      }
      if(detune) o.detune.setValueAtTime(detune, t);

      let node = o;
      if(filterHz){
        const f = ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.setValueAtTime(filterHz, t);
        node.connect(f);
        node = f;
      }else{
        o.connect(g);
        node = g;
      }
      if(filterHz){
        node.connect(g);
      }
      g.connect(out);

      envGain(g, t, 0.004, dur*0.45, 0.0, dur*0.55, gain);

      o.start(t);
      o.stop(t + dur + 0.12);
    }

    function playNoise({t,dur=0.09,gain=0.22,band="high",hz=6000,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const src = ctx.createBufferSource();
      src.buffer = sound.noiseBuf;
      const f = ctx.createBiquadFilter();
      const g = ctx.createGain();

      if(band==="high"){ f.type="highpass"; f.frequency.setValueAtTime(hz, t); }
      else if(band==="band"){ f.type="bandpass"; f.frequency.setValueAtTime(hz, t); f.Q.setValueAtTime(1.2, t); }
      else { f.type="lowpass"; f.frequency.setValueAtTime(hz, t); }

      src.connect(f);
      f.connect(g);
      g.connect(bus || sound.sfxBus);

      envGain(g, t, 0.002, dur*0.25, 0.0, dur*0.65, gain);

      src.start(t);
      src.stop(t + dur + 0.05);
    }

    function limit(name, sec){
      if(!sound.ctx) return false;
      const t = sound.ctx.currentTime;
      const last = sound.last[name] || -999;
      if(t - last < sec) return true;
      sound.last[name] = t;
      return false;
    }

    // --- BGM(ë°ê³  ê²½ì¾Œí•œ ìºì£¼ì–¼) ---
    function startBGM(){
      // âœ… MP3 BGM ì¬ìƒ (WebAudio í•©ì„± BGM ì œê±°)
      if(!sound.bgmEl) return;
      if(!sound.enabled || !sound.musicEnabled) return;
      const v = clamp(sound.masterVol * sound.musicVol, 0, 1);
      try{ sound.bgmEl.volume = v; }catch(_){}
      // autoplay ì •ì±…: unlockAudio(ì²« ì…ë ¥) ì´í›„ì—ë§Œ ì •ìƒ ì¬ìƒë©ë‹ˆë‹¤.
      sound.bgmEl.play().catch(()=>{});
    }

    function stopBGM(){
      if(sound.bgmEl){
        try{ sound.bgmEl.pause(); }catch(_){}
      }
    }

    function scheduleBgmStep(t, s){
      const step = s % 64;            // 4ë§ˆë””(16*4)
      const bar = Math.floor(step/16);
      const pos = step % 16;

      // ì½”ë“œ ì§„í–‰: C - G - Am - F (ë°ê³  ìµìˆ™)
      const prog = [
        {root: 60, type:"maj"}, // C
        {root: 67, type:"maj"}, // G
        {root: 69, type:"min"}, // A
        {root: 65, type:"maj"}, // F
      ];
      const ch = prog[bar];

      // ë“œëŸ¼(ê°€ë²¼ìš´ í‚¥/ìŠ¤ë„¤ì–´/í•˜ì´í–‡)
      if(pos===0 || pos===8){
        // kick
        playOsc({ t, freq: 120, slideTo: 48, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.32, bus: sound.musicBus });
      }
      if(pos===4 || pos===12){
        // snare
        playNoise({ t, dur: 0.10, gain: 0.20, band:"band", hz: 1800, bus: sound.musicBus });
        playOsc({ t, freq: 220, dur: 0.08, type:"triangle", gain: 0.10, bus: sound.musicBus });
      }
      if(pos%2===0){
        // hat
        playNoise({ t, dur: 0.045, gain: 0.10, band:"high", hz: 6500, bus: sound.musicBus });
      }

      // ë² ì´ìŠ¤(ì¿¼í„°)
      if(pos%4===0){
        const bassMidi = (ch.root - 24); // ì €ì—­
        playOsc({ t, freq: midiToFreq(bassMidi), dur: 0.14, type:"triangle", gain: 0.20, filterHz: 700, bus: sound.musicBus });
      }

      // íŒ¨ë“œ(ë§ˆë”” ì‹œì‘)
      if(pos===0){
        const tri = (ch.type==="maj") ? [0,4,7] : [0,3,7];
        for(let i=0;i<3;i++){
          const m = ch.root + tri[i];
          playOsc({ t, freq: midiToFreq(m), dur: 0.55, type:"sawtooth", gain: 0.055, filterHz: 1400, detune: (i-1)*6, bus: sound.musicBus });
        }
      }

      // ë¦¬ë“œ(ì‹±ì½”í˜ì´ì…˜ + íœíƒ€í† ë‹‰)
      const leadSlots = [2,6,10,14];
      if(leadSlots.includes(pos)){
        const scale = [0,2,4,7,9]; // major pentatonic
        const pick = scale[Math.floor((sound.rng ? sound.rng() : Math.random()) * scale.length)];
        const base = ch.root + 12; // í•œ ì˜¥íƒ€ë¸Œ ìœ„
        const m = base + pick + (pos===14 ? 12 : 0)*( (sound.rng ? sound.rng() : Math.random())>0.85 ? 1:0);
        const f = midiToFreq(m);
        playOsc({ t, freq: f, dur: 0.13, type:"square", gain: 0.12, filterHz: 2600, detune: (sound.rng ? (sound.rng()-0.5)*8 : (Math.random()-0.5)*8), bus: sound.musicBus });
        // ì‘ì€ í•˜ëª¨ë‹ˆ(ê°€ë”)
        if((sound.rng ? sound.rng() : Math.random()) > 0.72){
          playOsc({ t, freq: midiToFreq(m-12), dur: 0.12, type:"triangle", gain: 0.06, filterHz: 2400, bus: sound.musicBus });
        }
      }
    }

    // --- SFX(ê²½ì¾Œ + ê³ ìŒì§ˆ) ---
    const SFX = {
      jump(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("jump", 0.03)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 420, slideTo: 860, slideTime: 0.06, dur: 0.10, type:"triangle", gain: 0.22, filterHz: 3200, bus: sound.sfxBus });
        playNoise({ t, dur: 0.045, gain: 0.06, band:"high", hz: 7000, bus: sound.sfxBus });
      },
      coin(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("coin", 0.02)) return;
        const t = sound.ctx.currentTime;
        const base = 880;
        playOsc({ t, freq: base, dur: 0.08, type:"sine", gain: 0.16, bus: sound.sfxBus });
        playOsc({ t: t+0.035, freq: base*1.25, dur: 0.08, type:"sine", gain: 0.14, bus: sound.sfxBus });
        playOsc({ t: t+0.070, freq: base*1.50, dur: 0.09, type:"triangle", gain: 0.10, bus: sound.sfxBus });
      },
      dash(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("dash", 0.06)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.11, gain: 0.16, band:"band", hz: 1300, bus: sound.sfxBus });
        playOsc({ t, freq: 220, slideTo: 90, slideTime: 0.10, dur: 0.12, type:"sawtooth", gain: 0.10, filterHz: 900, bus: sound.sfxBus });
      },
      spring(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spring", 0.06)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 260, slideTo: 980, slideTime: 0.08, dur: 0.14, type:"square", gain: 0.18, filterHz: 2600, bus: sound.sfxBus });
      },
      stomp(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("stomp", 0.05)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 140, slideTo: 70, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.24, bus: sound.sfxBus });
        playNoise({ t, dur: 0.06, gain: 0.10, band:"band", hz: 900, bus: sound.sfxBus });
      },
      hurt(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("hurt", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 520, slideTo: 220, slideTime: 0.11, dur: 0.16, type:"sawtooth", gain: 0.18, filterHz: 1600, bus: sound.sfxBus });
        playNoise({ t, dur: 0.10, gain: 0.14, band:"band", hz: 700, bus: sound.sfxBus });
      },
      pop(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("pop", 0.12)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 380, slideTo: 110, slideTime: 0.06, dur: 0.12, type:"triangle", gain: 0.20, bus: sound.sfxBus });
        playNoise({ t, dur: 0.09, gain: 0.12, band:"high", hz: 5200, bus: sound.sfxBus });
        // sparkle
        for(let i=0;i<3;i++){
          const dt = 0.02*i;
          playOsc({ t: t+dt, freq: 1200 + i*320, dur: 0.06, type:"sine", gain: 0.06, bus: sound.sfxBus });
        }
      },
      spawn(){
        // ë¦¬ìŠ¤í°/ì‹œì‘ "ë¿…"(ê°€ë²¼ìš´ ë°˜ì§)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spawn", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 880, slideTo: 1320, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.11, bus: sound.sfxBus });
        playOsc({ t: t+0.03, freq: 1760, dur: 0.08, type:"triangle", gain: 0.06, bus: sound.sfxBus });
      },
      death(){
        // ì‚¬ë§ "ì‚ìš© ì‚ìš© ì‚ìš©~" (ì•„ì‰¬ìš´ í†¤)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("death", 0.30)) return;
        const t = sound.ctx.currentTime;
        const seq = [780, 640, 520];
        for(let i=0;i<3;i++){
          playOsc({ t: t+i*0.11, freq: seq[i], slideTo: seq[i]*0.72, slideTime: 0.14, dur: 0.24, type:"triangle", gain: 0.16, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.05, band:"high", hz: 5200, bus: sound.sfxBus });
      },
      clear(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("clear", 0.35)) return;
        const t = sound.ctx.currentTime;
        // ì‘ì€ íŒ¬í˜ì–´(ê²½ì¾Œ)
        const notes = [880, 1108, 1318, 1760];
        for(let i=0;i<notes.length;i++){
          playOsc({ t: t+i*0.08, freq: notes[i], dur: 0.18, type:"square", gain: 0.11, filterHz: 3200, bus: sound.sfxBus });
          playOsc({ t: t+i*0.08, freq: notes[i]*0.5, dur: 0.18, type:"triangle", gain: 0.06, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.08, band:"high", hz: 7600, bus: sound.sfxBus });
      },
      firework(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("fw", 0.08)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.10, gain: 0.10, band:"high", hz: 6800, bus: sound.sfxBus });
        playOsc({ t, freq: 980, slideTo: 420, slideTime: 0.09, dur: 0.14, type:"sine", gain: 0.09, bus: sound.sfxBus });
      }
    };

    // UI/ë‹¨ì¶•í‚¤
    syncSoundUI();
    if($soundPill){
      $soundPill.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        unlockAudio();
        sound.enabled = !sound.enabled;
        applySoundGains();
        showToast(sound.enabled ? "ì‚¬ìš´ë“œ ON" : "ì‚¬ìš´ë“œ OFF", 800);
      });
    }

    // ----------------------------
    // ì…ë ¥
    // ----------------------------
    const input = {
      left:false, right:false, up:false, down:false,
      jump:false, jumpPressed:false, jumpReleased:false,
      dash:false, dashPressed:false,
      faceLock:false
    };

   const keyMap = {
      "ArrowLeft":"left","KeyA":"left",
      "ArrowRight":"right","KeyD":"right",
      "ArrowUp":"up","KeyW":"up",
      "ArrowDown":"down","KeyS":"down",
      "Space":"jump",
      // âœ… Windows 'ê³ ì •í‚¤(Sticky Keys)' íŒì—…ì„ ê·¼ë³¸ì ìœ¼ë¡œ í”¼í•˜ë ¤ë©´
      //    'Shift' ê°™ì€ ëª¨ë””íŒŒì´ì–´ í‚¤ë¥¼ ëŒ€ì‹œë¡œ ì“°ì§€ ì•ŠëŠ” ê²Œ ê°€ì¥ í™•ì‹¤í•©ë‹ˆë‹¤.
      //    ê¸°ë³¸ ëŒ€ì‹œ í‚¤: X (ëŒ€ì²´: K)
      "KeyX":"dash",
      "KeyK":"dash",
      "AltLeft":"faceLock","AltRight":"faceLock",
      "KeyR":"restart",
	  "KeyZ":"boss"
    };

    // Shift í‚¤ë¥¼ ì—°íƒ€/ê¸¸ê²Œ ëˆ„ë¥¼ ë•Œ Windows ê³ ì •í‚¤/í•„í„°í‚¤ íŒì—…ì´ ëœ° ìˆ˜ ìˆì–´ì„œ,
    // ê²Œì„ ë‚´ì—ì„œëŠ” Shiftë¥¼ 'ëŒ€ì‹œ'ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì°¨ë‹¨í•˜ê³  ì•ˆë‚´ í† ìŠ¤íŠ¸ë§Œ ë„ì›ë‹ˆë‹¤.
    let _shiftWarned = false;    
	
	
	
    addEventListener("keydown", (e)=>{
      // ë””ë²„ê·¸ í† ê¸€: ` (Backquote)
		if(e.code === "Backquote"){
		  debug.enabled = !debug.enabled;
		  showToast(debug.enabled ? "ë””ë²„ê·¸ ON (`)" : "ë””ë²„ê·¸ OFF (`)", 900);
		  // ë°”ë¡œ ë°˜ì˜
		  if(!debug.enabled){
			resetDebugPool();
			if(debug.velLine) debug.velLine.visible = false;
		  }
		  return;
		}

	  // âœ… Shift ì°¨ë‹¨(ìœˆë„ìš° ê³ ì •í‚¤/í•„í„°í‚¤ íŒì—… ë°©ì§€)
	  // ë¸Œë¼ìš°ì € ì½”ë“œë¡œ OS íŒì—… ìì²´ë¥¼ 'ì™„ì „ ì°¨ë‹¨'í•  ìˆ˜ëŠ” ì—†ì–´ì„œ(Windows ê¸°ëŠ¥),
	  // ê²Œì„ ì¡°ì‘ì—ì„œëŠ” Shiftë¥¼ ì“°ì§€ ì•Šê³  X/Kë¡œ ëŒ€ì‹œí•˜ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤.
	  if(e.code === "ShiftLeft" || e.code === "ShiftRight"){
		if(!_shiftWarned){
		  showToast("ìœˆë„ìš° ê³ ì •í‚¤ íŒì—… ë°©ì§€: ëŒ€ì‹œëŠ” X(ë˜ëŠ” K) í‚¤!", 1600);
		  _shiftWarned = true;
		}
		e.preventDefault();
		return;
	  }

      // ì‚¬ìš´ë“œ(ì²« ì…ë ¥ ì‹œ ì˜¤ë””ì˜¤ ì–¸ë½)

      if(sound.enabled) unlockAudio();

      // ì‚¬ìš´ë“œ ë‹¨ì¶•í‚¤
      if(e.code === "KeyM"){
        sound.musicEnabled = !sound.musicEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.musicEnabled ? "BGM ON" : "BGM OFF", 800);
        return;
      }
      if(e.code === "KeyN"){
        sound.sfxEnabled = !sound.sfxEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.sfxEnabled ? "SFX ON" : "SFX OFF", 800);
        return;
      }
      if(e.code === "Equal" || e.code === "NumpadAdd"){
        sound.masterVol = clamp(sound.masterVol + 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("ë³¼ë¥¨ " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }
      if(e.code === "Minus" || e.code === "NumpadSubtract"){
        sound.masterVol = clamp(sound.masterVol - 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("ë³¼ë¥¨ " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }

// ì •ì±… ë‹¨ì¶•í‚¤
      if(e.code==="KeyH"){
        policy.keepHP = !policy.keepHP;
        syncPolicyUI();
        return;
      }
      if(e.code==="KeyC"){
        policy.keepCoins = !policy.keepCoins;
        syncPolicyUI();
        return;
      }
	  
	  if(e.code==="KeyZ"){
        jumpGoal();
        return;
      }

      const k = keyMap[e.code];
      if(!k) return;

      if(k==="restart"){
        startLevel(1, true);
        showToast("ë¦¬ì…‹!", 800);
        return;
      }

      if(k==="jump"){ if(!input.jump) input.jumpPressed=true; input.jump=true; return; }
      if(k==="dash"){ if(!input.dash) input.dashPressed=true; input.dash=true; return; }

      input[k] = true;
    });

    addEventListener("keyup", (e)=>{
      const k = keyMap[e.code];
      if(!k) return;

      if(k==="jump"){ input.jump=false; input.jumpReleased=true; return; }
      if(k==="dash"){ input.dash=false; return; }

      input[k] = false;
    });

    // ëª¨ë°”ì¼ ë„ì›€ë§(Info ë²„íŠ¼)
    // - ëª¨ë°”ì¼ì—ì„œëŠ” ì„¤ëª…ì„ ê¸°ë³¸ ìˆ¨ê¹€
    // - â„¹ï¸ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ 5ì´ˆê°„ í‘œì‹œ í›„ ìë™ ìˆ¨ê¹€
    const $subtitle = document.getElementById("subtitle");
    const $infoPill = document.getElementById("infoPill");
    let infoTimer = null;

    function hideHelp(){
      if(!$subtitle) return;
      $subtitle.classList.add("subHidden");
    }
    function showHelp(){
      if(!$subtitle) return;
      $subtitle.classList.remove("subHidden");
      if(infoTimer) clearTimeout(infoTimer);
      infoTimer = setTimeout(()=>{ hideHelp(); }, 5000);
    }

    // í„°ì¹˜(ëª¨ë°”ì¼)
    const touch = ("ontouchstart" in window) || (navigator.maxTouchPoints>0);
    const $touch = document.getElementById("touch");
    if(touch){
      $touch.style.display="block";
      // ëª¨ë°”ì¼: ë„ì›€ë§ì€ â„¹ï¸ë¡œë§Œ ë…¸ì¶œ
      if($infoPill) $infoPill.style.display = "inline-flex";
      hideHelp();
      if($infoPill){
        $infoPill.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); showHelp(); });
      }

      const bind = (id, key)=>{
        const el = document.getElementById(id);
        const down = (ev)=>{ ev.preventDefault();
        if(sound.enabled) unlockAudio(); input[key]=true; if(key==="jump") input.jumpPressed=true; if(key==="dash") input.dashPressed=true; };
        const up   = (ev)=>{ ev.preventDefault(); input[key]=false; if(key==="jump") input.jumpReleased=true; };
        el.addEventListener("pointerdown", down);
        addEventListener("pointerup", up);
        el.addEventListener("pointercancel", up);
        el.addEventListener("pointerleave", up);
      };
      bind("tLeft","left");
      bind("tRight","right");
      bind("tUp","up");
      bind("tDown","down");
      bind("tJump","jump");
      bind("tDash","dash");
    }else{
      // ë°ìŠ¤í¬í†±ì—ì„œëŠ” ê¸°ë³¸ ì„¤ëª…ì„ í•­ìƒ ë³´ì—¬ì£¼ê³ , â„¹ï¸ëŠ” ìˆ¨ê¹€
      if($infoPill) $infoPill.style.display = "none";
    }

    // ----------------------------
    // Three ê¸°ë³¸ ì„¸íŒ…
    // ----------------------------

    const wrap = document.getElementById("wrap");

    // ----------------------------
    // ë¡œë”© UI (ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„ ì‹œì‘)
    // ----------------------------
    const $loader = document.getElementById("loader");
    const $barFill = document.getElementById("barFill");
    const $loadText = document.getElementById("loadText");
    function setLoading(done, total, label){
      const pct = total > 0 ? Math.round((done/total)*100) : 0;
      if($barFill) $barFill.style.width = pct + "%";
      if($loadText) $loadText.textContent = `${label || "ë¡œë”© ì¤‘"}  (${done}/${total})`;
    }
    function hideLoader(){
      if($loader) $loader.style.display = "none";
    }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfe4ff);

    const camera = new THREE.OrthographicCamera(-10, 10, 6, -6, 0.01, 100);
    camera.position.set(0, 0, 10);
    camera.zoom = 1.0;
    camera.updateProjectionMatrix();
    scene.add(camera);
	
	// ----------------------------
	// ë””ë²„ê·¸ ì˜¤ë²„ë ˆì´(AABB/ë²¡í„°) - ` í‚¤ë¡œ í† ê¸€
	// ----------------------------
	const debug = {
	  enabled: false,
	  group: new THREE.Group(),
	  pool: [],
	  velLine: null,
	};
	debug.group.position.z = 9;
	scene.add(debug.group);

	function makeLine(color, opacity=0.95){
	  return new THREE.LineBasicMaterial({ color, transparent:true, opacity, depthTest:false });
	}

	const MAT_PLAYER  = makeLine(0x00e5ff, 0.95);
	const MAT_SOLID   = makeLine(0x00ff7f, 0.55);
	const MAT_LADDER  = makeLine(0xffcc3d, 0.85);
	const MAT_COIN    = makeLine(0xff66cc, 0.80);
	const MAT_ENEMY   = makeLine(0xff3b3b, 0.85);
	const MAT_GOAL    = makeLine(0xb46bff, 0.90);
	const MAT_VEL     = makeLine(0xffffff, 0.85);

	function allocRect(material){
	  // LineLoop(5ì : ì‚¬ê°í˜• ë‹«í˜)
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(5 * 3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));
	  const line = new THREE.Line(geo, material);
	  line.frustumCulled = false;
	  line.visible = false;
	  debug.group.add(line);
	  return { line, arr, inUse:false };
	}

	function getRect(material){
	  let r = debug.pool.find(o => !o.inUse && o.line.material === material);
	  if(!r){
		r = allocRect(material);
		debug.pool.push(r);
	  }
	  r.inUse = true;
	  r.line.visible = debug.enabled;
	  return r;
	}

	function setRect(r, x, y, w, h, z=9){
	  // x,y = bottom-left
	  const a = r.arr;
	  const x0=x, y0=y, x1=x+w, y1=y+h;
	  a[0]=x0; a[1]=y0; a[2]=z;
	  a[3]=x1; a[4]=y0; a[5]=z;
	  a[6]=x1; a[7]=y1; a[8]=z;
	  a[9]=x0; a[10]=y1; a[11]=z;
	  a[12]=x0; a[13]=y0; a[14]=z;
	  r.line.geometry.attributes.position.needsUpdate = true;
	}

	function resetDebugPool(){
	  for(const r of debug.pool){
		r.inUse = false;
		r.line.visible = false;
	  }
	}

	function ensureVelLine(){
	  if(debug.velLine) return;
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(2*3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr,3));
	  debug.velLine = new THREE.Line(geo, MAT_VEL);
	  debug.velLine.frustumCulled = false;
	  debug.velLine.visible = false;
	  debug.group.add(debug.velLine);
	}

	function setVelLine(x0,y0,x1,y1,z=9){
	  ensureVelLine();
	  const pos = debug.velLine.geometry.attributes.position.array;
	  pos[0]=x0; pos[1]=y0; pos[2]=z;
	  pos[3]=x1; pos[4]=y1; pos[5]=z;
	  debug.velLine.geometry.attributes.position.needsUpdate = true;
	  debug.velLine.visible = debug.enabled;
	}

    function resize(){
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w,h, false);

      const viewH = 12;
      const aspect = w/h;
      const viewW = viewH * aspect;
      camera.left   = -viewW/2;
      camera.right  =  viewW/2;
      camera.top    =  viewH/2;
      camera.bottom = -viewH/2;
      camera.updateProjectionMatrix();
    }
    addEventListener("resize", resize);
    resize();

    // ----------------------------
    // í…ìŠ¤ì²˜ ë¡œë”©
    // ----------------------------
    const loader = new THREE.TextureLoader();

    const required = [
      "background_color_mushrooms.png",
      "character_green_idle.png",
      "character_green_walk_a.png",
      "character_green_walk_b.png",
      "character_green_walk_a_back.png",
      "character_green_walk_b_back.png",
      "character_green_jump.png",
      "character_green_jump_back.png",
      "character_green_hit.png",
      // ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸(3í”„ë ˆì„)
      "character_green_down.png",
      "character_green_duck.png",
      "character_green_front.png",
      "character_green_climb_a.png",
      "character_green_climb_b.png",
      "hud_coin.png",
      "slime_normal_flat.png",
      "slime_normal_rest.png",
      "slime_normal_walk_a.png",
	  "slime_normal_walk_b.png",
      "boss_whale_image.png"
    ];

    // âœ… BGM: ì²¨ë¶€ MP3 ì‚¬ìš©(íŒŒì¼ëª… ë³€ê²½ ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •)
    const BGM_URL = encodeURI("ë°˜ì§ì´ëŠ” ëª¨í—˜.mp3");

    let _loadDone = 0;
    const _loadTotal = required.length + 1; // + BGM
    setLoading(_loadDone, _loadTotal, "ì´ˆê¸° ë¦¬ì†ŒìŠ¤ ì¤€ë¹„...");

    function markLoaded(label){
      _loadDone++;
      setLoading(_loadDone, _loadTotal, label);
    }

    const loadTex = (url)=>new Promise((resolve,reject)=>{
      loader.load(url, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        markLoaded(url);
        resolve(t);
      }, undefined, (e)=>reject(e));
    });

    function loadBGM(url){
      return new Promise((resolve, reject)=>{
        const a = new Audio();
        a.preload = "auto";
        a.loop = true;
        a.src = url;

        const done = ()=>{
          cleanup();
          markLoaded("BGM");
          resolve(a);
        };
        const fail = ()=>{
          cleanup();
          reject(new Error("BGM ë¡œë”© ì‹¤íŒ¨: MP3 íŒŒì¼(ë°˜ì§ì´ëŠ” ëª¨í—˜.mp3)ì´ index.htmlê³¼ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."));
        };
        const cleanup = ()=>{
          a.removeEventListener("canplaythrough", done);
          a.removeEventListener("loadeddata", done);
          a.removeEventListener("error", fail);
        };

        // ì¼ë¶€ í™˜ê²½ì—ì„œ canplaythroughê°€ ì•ˆ ëœ¨ëŠ” ê²½ìš°ê°€ ìˆì–´ loadeddataë„ ê°™ì´ ë°›ìŠµë‹ˆë‹¤.
        a.addEventListener("canplaythrough", done, { once:true });
        a.addEventListener("loadeddata", done, { once:true });
        a.addEventListener("error", fail, { once:true });

        try{ a.load(); }catch(_){}
      });
    }

    let TEX = {};
    let BOSS_TEX = {};
    let PLAYER_DOWN = { frames:[], fw:0, fh:0 };
    try{
      const texPs = required.map(loadTex);
      const bgmEl = await loadBGM(BGM_URL);
      const [bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale] = await Promise.all(texPs);

      TEX = { bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale };

      // ----------------------------
      // ë³´ìŠ¤(ê³ ë˜) ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ë¶„í• (4x4, íƒ€ì¼ 256px)
      //  - íŒŒì¼: boss_whale_image.png (index.htmlê³¼ ê°™ì€ í´ë”ì— ë‘ì„¸ìš”)
      // ----------------------------
      function sliceSheet(sheet, col, row, tile=256){
        const c = document.createElement("canvas");
        c.width = tile; c.height = tile;
        const g = c.getContext("2d");
        // row=0ì´ ì´ë¯¸ì§€ ìµœìƒë‹¨
        g.clearRect(0,0,tile,tile);
        g.drawImage(sheet.image, col*tile, row*tile, tile, tile, 0,0, tile, tile);
        const t = new THREE.CanvasTexture(c);
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        return t;
      }

      BOSS_TEX = {
        idleA:  sliceSheet(bossWhale, 0, 0),
        attackA:sliceSheet(bossWhale, 1, 0),
        attackB:sliceSheet(bossWhale, 2, 0),
        idleB:  sliceSheet(bossWhale, 3, 0),

        tailA:  sliceSheet(bossWhale, 0, 1),
        tailB:  sliceSheet(bossWhale, 1, 1),
        charge: sliceSheet(bossWhale, 2, 1),
        tailC:  sliceSheet(bossWhale, 3, 1),

        eyeA:   sliceSheet(bossWhale, 0, 2),
        smile:  sliceSheet(bossWhale, 1, 2),
        hurt:   sliceSheet(bossWhale, 2, 2),
        eyeB:   sliceSheet(bossWhale, 3, 2),
      };

      // ----------------------------
      // í”Œë ˆì´ì–´ ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸(ê°€ë¡œ 3í”„ë ˆì„)
      //  - íŒŒì¼: character_green_down.png
      // ----------------------------
      function sliceStrip(sheet, frames=3){
        const img = sheet.image;
        const fw = Math.floor(img.width / frames);
        const fh = img.height;
        const out = [];
        for(let i=0;i<frames;i++){
          const c = document.createElement("canvas");
          c.width = fw; c.height = fh;
          const g = c.getContext("2d");
          g.clearRect(0,0,fw,fh);
          g.drawImage(img, i*fw, 0, fw, fh, 0, 0, fw, fh);
          const t = new THREE.CanvasTexture(c);
          t.colorSpace = THREE.SRGBColorSpace;
          t.needsUpdate = true;
          out.push(t);
        }
        return { frames: out, fw, fh };
      }
      PLAYER_DOWN = sliceStrip(downSheet, 3);


      // ì‚¬ìš´ë“œì— BGM MP3 ì£¼ì…
      sound.bgmEl = bgmEl;
      try{ applySoundGains(); }catch(_){}

      hideLoader();
    }catch(err){
      console.error(err);
      if($loadText) $loadText.textContent = "ë¡œë”© ì‹¤íŒ¨: íŒŒì¼ ëˆ„ë½/ê²½ë¡œ ë¬¸ì œ";
      showToast((err && err.message) ? err.message : "ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹¤íŒ¨", 4000);
      throw err;
    }


    // ----------------------------
    // CanvasTexture ìƒì„±ê¸°
    // ----------------------------
    function makeCanvasTexture(drawFn, w=256, h=256){
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const g = canvas.getContext("2d");
      drawFn(g, w, h);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ----------------------------
    // ë°°ê²½
    // ----------------------------
    const bgTex = TEX.bg;
    bgTex.wrapS = bgTex.wrapT = THREE.RepeatWrapping;
    bgTex.repeat.set(8, 4);

    const bgPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(260, 92),
      new THREE.MeshBasicMaterial({ map: bgTex })
    );
    bgPlane.position.set(0, 6, -5);
    scene.add(bgPlane);

    const waterTex = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle = "rgba(120,190,255,.85)";
      g.fillRect(0, h*0.30, w, h*0.70);
      g.strokeStyle = "rgba(255,255,255,.55)";
      g.lineWidth = 10; g.lineCap = "round";
      for(let i=0;i<8;i++){
        const y = h*0.32 + i*22;
        g.beginPath();
        for(let x=-40;x<=w+40;x+=40){
          g.lineTo(x, y + Math.sin((x+i*10)*0.08)*8);
        }
        g.stroke();
      }
    }, 512, 256);
    waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
    waterTex.repeat.set(10, 2);

    const water = new THREE.Mesh(
      new THREE.PlaneGeometry(280, 16),
      new THREE.MeshBasicMaterial({ map: waterTex, transparent:true, opacity:.92 })
    );
    water.position.set(0, -6.7, -2.8);
    scene.add(water);

    // ----------------------------
    // ì›”ë“œ ë°ì´í„°
    // ----------------------------
    const world = {
      platforms: [],
      coins: [],
      enemies: [],
      springs: [],
      ladders: [],
      particles: [],
      afterimages: [],
      bossBullets: [],
      boss: null,
      goal: null,

      totalCoinsLevel: 0,
      collectedCoinsLevel: 0,

      // ì½”ì¸ ìœ ì§€ ì •ì±…ìš©
      totalCoinsRun: 0,
      totalCoinsRunAtLevelStart: 0,

      // ì¹´ë©”ë¼/ì¶”ë½ íŒì •ìš©(ë ˆë²¨ ìƒì„± ì‹œ ê°±ì‹ )
      groundTop: -0.6,
      killY: -12,
    };

    // ----------------------------
    // ì›”ë“œ í…ìŠ¤ì²˜
    // ----------------------------
    const texPlatform = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const grd = g.createLinearGradient(0,0,0,h);
      grd.addColorStop(0, "#f3a66c");
      grd.addColorStop(1, "#cf6b3e");
      g.fillStyle = grd;
      g.fillRect(0,0,w,h);

      g.fillStyle = "#41c85f";
      g.fillRect(0,0,w, 64);
      g.fillStyle = "#2aa44a";
      for(let x=0;x<w;x+=22){
        g.beginPath();
        g.arc(x+10, 62, 8, 0, Math.PI*2);
        g.fill();
      }

      g.globalAlpha = .18;
      g.fillStyle = "#000";
      for(let y=90;y<h;y+=56) g.fillRect(0, y, w, 8);
      g.globalAlpha = 1;
    });

    const texCoin = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2, r=90;

      g.fillStyle="#f7d34c";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();

      const grd = g.createRadialGradient(cx-30, cy-30, 10, cx, cy, r);
      grd.addColorStop(0, "#fff2a8");
      grd.addColorStop(1, "#e0a600");
      g.fillStyle=grd;
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.fill();

      g.globalAlpha=.35;
      g.fillStyle="#b56b00";
      g.beginPath(); g.arc(cx,cy, r*0.35,0,Math.PI*2); g.fill();
      g.globalAlpha=1;

      g.lineWidth = 18;
      g.strokeStyle = "rgba(0,0,0,.30)";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.stroke();

      g.lineWidth = 10;
      g.strokeStyle = "rgba(255,255,255,.22)";
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.stroke();
    });

    const texSlimeFlat = TEX.slimeFlat;
    const texSlimeRest = TEX.slimeRest;
    const texSlimeWalkA = TEX.slimeWalkA;
	const texSlimeWalkB = TEX.slimeWalkB;
    // ê¸°ë³¸ ìŠ¬ë¼ì„ í…ìŠ¤ì³
    const texSlime = texSlimeRest;

    const texSpring = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle = "#f2b23d";
      g.fillRect(60, 180, 136, 46);

      g.strokeStyle = "#be3e2c";
      g.lineWidth = 16;
      g.lineCap="round";
      let y = 170;
      g.beginPath();
      for(let x=40; x<=216; x+=22){
        g.lineTo(x, y + Math.sin(x*0.12)*26);
      }
      g.stroke();
    });

    const texFlagOff = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);
      g.fillStyle="#ffd4aa";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(200, 70, 220, 110);
      g.quadraticCurveTo(190, 140, 136, 150);
      g.closePath(); g.fill();
    });

    const texFlagOn = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);

      g.fillStyle="#ffcc3d";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(210, 60, 228, 110);
      g.quadraticCurveTo(190, 145, 136, 155);
      g.closePath(); g.fill();

      g.fillStyle="rgba(0,0,0,.55)";
      g.fillRect(164, 78, 14, 44);
      g.beginPath(); g.arc(171, 132, 10, 0, Math.PI*2); g.fill();
    });

    const texLadder = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e18a55";
      g.fillRect(w*0.18, 0, w*0.16, h);
      g.fillRect(w*0.66, 0, w*0.16, h);

      g.fillStyle="#d47b49";
      const step=52;
      for(let yy=22; yy<h; yy+=step){
        g.fillRect(w*0.20, yy, w*0.60, 18);
      }
    }, 256, 512);
    texLadder.wrapS = texLadder.wrapT = THREE.RepeatWrapping;

    // ê½ƒì
    const texPetal = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.translate(w/2, h/2);
      g.rotate(-0.35);
      g.scale(1.1, 1.1);

      const grd = g.createRadialGradient(-20,-30, 10, 0,0, 110);
      grd.addColorStop(0, "rgba(255,255,255,.95)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;

      for(let i=0;i<4;i++){
        g.rotate(Math.PI/2);
        g.beginPath();
        g.moveTo(0, -10);
        g.bezierCurveTo(45,-55, 85,-10, 55, 50);
        g.bezierCurveTo(25, 95, -10, 75, -10, 35);
        g.closePath();
        g.fill();
      }
    }, 256, 256);

    // í­ì£½ ìŠ¤íŒŒí¬(ì›í˜•)
    const texSpark = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      const grd = g.createRadialGradient(cx,cy, 0, cx,cy, w*0.45);
      grd.addColorStop(0, "rgba(255,255,255,1)");
      grd.addColorStop(0.2, "rgba(255,255,255,.7)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath(); g.arc(cx,cy, w*0.45, 0, Math.PI*2); g.fill();
    }, 128, 128);

    // "ë¿…" ë§(ë“±ì¥/ë¦¬í°)
    const texSpawnRing = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      // ì™¸ê³½ ë§
      g.strokeStyle = "rgba(255,255,255,0.85)";
      g.lineWidth = w*0.08;
      g.beginPath();
      g.arc(cx, cy, w*0.34, 0, Math.PI*2);
      g.stroke();
      // ì”ê´‘
      const grd = g.createRadialGradient(cx,cy, w*0.08, cx,cy, w*0.48);
      grd.addColorStop(0, "rgba(255,255,255,0.35)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(cx, cy, w*0.48, 0, Math.PI*2);
      g.fill();
    }, 192, 192);

    // ----------------------------
    // ì—”í‹°í‹° ìƒì„±
    // ----------------------------
    function addPlatform(x,y,w,h){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({ map: texPlatform })
      );
      mesh.position.set(x+w/2, y+h/2, 1);
      scene.add(mesh);
      const p = { x,y,w,h, mesh, isSolid:true };
      world.platforms.push(p);
      return p;
    }

    // ë²½/ì°¨ë‹¨ìš©(ê°™ì€ í”Œë«í¼ í…ìŠ¤ì²˜ ì‚¬ìš©, ê¸¸ê²Œ ì„¸ì›€)
    function addBlockWall(x,y,w,h){
      return addPlatform(x,y,w,h);
    }

    function addCoin(x,y){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(0.7,0.7),
        new THREE.MeshBasicMaterial({ map: TEX.hudCoin, transparent:true })
      );
      mesh.position.set(x, y, 2.2);
      scene.add(mesh);
      const c = { x, y, r:0.35, mesh, t: rand(0,10), dead:false };
      world.coins.push(c);
      world.totalCoinsLevel++;
      return c;
    }
	
	function coinOverlapsSolid(x,y,r=0.35){
	  const cx = x - r;
	  const cy = y - r;
	  const s  = r*2;
	  for(const p of world.platforms){
		// eps=0ìœ¼ë¡œ â€œì‚´ì§ì´ë¼ë„ ê²¹ì¹˜ë©´â€ ê²¹ì¹¨ìœ¼ë¡œ ì·¨ê¸‰
		if(aabbIntersect(cx,cy,s,s, p.x,p.y,p.w,p.h, 0)) return true;
	  }
	  return false;
	}

	function safeAddCoin(x,y){
	  // 1) ê¸°ë³¸ ìœ„ì¹˜ì—ì„œ ìœ„ë¡œ ì¡°ê¸ˆì”© ì˜¬ë ¤ê°€ë©° ì†”ë¦¬ë“œ ê²¹ì¹¨ íšŒí”¼
	  let yy = y;
	  for(let i=0;i<14;i++){
		if(!coinOverlapsSolid(x, yy)) return addCoin(x, yy);
		yy += 0.18;
	  }

	  // 2) ê·¸ë˜ë„ ì•ˆ ë˜ë©´: x ì•„ë˜ì— ìˆëŠ” â€œê°€ì¥ ë†’ì€ í”Œë«í¼â€ ìœ„ë¡œ ì˜¬ë ¤ì„œ ìƒì„±
	  let bestTop = -Infinity;
	  for(const p of world.platforms){
		if(x > p.x + 0.4 && x < p.x + p.w - 0.4){
		  const top = p.y + p.h;
		  if(top > bestTop && top < yy + 10) bestTop = top;
		}
	  }
	  if(bestTop > -Infinity) return addCoin(x, bestTop + 0.8);

	  // 3) ìµœí›„ fallback
	  return addCoin(x, y + 1.0);
	}

    function addEnemyOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.95),
        new THREE.MeshBasicMaterial({ map: texSlimeRest, transparent:true })
      );
      const yCenter = top + 0.33;
      mesh.position.set(xCenter, yCenter, 2.1);
      scene.add(mesh);

      const e = {
        x: xCenter,
        y: yCenter,
        w: 1.0,
        h: 0.65,
        vx: rand(-1,1) < 0 ? -rand(1.1, 1.7) : rand(1.1, 1.7),
        mesh,
        dead:false,
        roamMin: p.x+0.7,
        roamMax: p.x+p.w-0.7,
        animT: 0,
        texState: "rest",
        deathTimer: 0
      };
      world.enemies.push(e);
      return e;
    }

    function addSpringOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.6),
        new THREE.MeshBasicMaterial({ map: texSpring, transparent:true })
      );
      const yCenter = top + 0.22;
      mesh.position.set(xCenter, yCenter, 2.05);
      scene.add(mesh);
      const s = { x: xCenter, y: yCenter, w:1.0, h:0.35, mesh };
      world.springs.push(s);
      return s;
    }

    // ì‚¬ë‹¤ë¦¬: ì•„ë˜ ë¸”ë¡ top ~ ìœ„ ë¸”ë¡ top
    function addGoalWithBase(pBase){
      const baseTop = pBase.y + pBase.h;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 1.6),
        new THREE.MeshBasicMaterial({ map: texFlagOff, transparent:true })
      );
      const x = pBase.x + pBase.w - 1.2;
      const y = baseTop + 0.85;
      mesh.position.set(x, y, 2.0);
      scene.add(mesh);

      world.goal = { x, y, w:0.8, h:1.2, mesh, active:false, base: pBase };
      return world.goal;
    }

    // ----------------------------
    // íŒŒí‹°í´
    // ----------------------------
    const geoTiny = new THREE.PlaneGeometry(0.10,0.10);
    const geoDust = new THREE.PlaneGeometry(0.16,0.16);
    const geoPetal = new THREE.PlaneGeometry(0.28,0.28);
    const geoSpark = new THREE.PlaneGeometry(0.18,0.18);

    function spawnParticles(x,y,n=10, power=1){
      for(let i=0;i<n;i++){
        const mesh = new THREE.Mesh(
          geoTiny,
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.85 })
        );
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.6);
        scene.add(mesh);
        world.particles.push({
          kind:"spark",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-2.2,2.2)*power,
          vy: rand(0.8,3.4)*power,
          life: rand(0.25,0.55),
          mesh, spin: rand(-6,6)
        });
      }
    }

    function spawnDust(x,y, n=6){
      for(let i=0;i<n;i++){
        const mesh = new THREE.Mesh(
          geoDust,
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.45 })
        );
        mesh.position.set(x + rand(-0.25,0.25), y + rand(-0.05,0.15), 2.55);
        scene.add(mesh);
        world.particles.push({
          kind:"dust",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-1.8,1.8),
          vy: rand(0.6,2.2),
          life: rand(0.16,0.34),
          mesh, spin: rand(-4,4)
        });
      }
    }

    function spawnFlowerBurst(x,y, n=90){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.95,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.85);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        const spd = rand(4.0, 12.0);
        const ang = rand(-Math.PI*0.15, Math.PI*1.15);
        world.particles.push({
          kind:"petal",
          x: mesh.position.x, y: mesh.position.y,
          vx: Math.cos(ang)*spd + rand(-1.5,1.5),
          vy: Math.sin(ang)*spd + rand(2.0,8.0),
          life: rand(1.4, 2.6),
          mesh,
          spin: rand(-10, 10),
          sway: rand(6, 12)
        });
      }
    }

    // âœ… ê½ƒë¹„(ì§€ì†): í™”ë©´ ìƒë‹¨ì—ì„œ ë–¨ì–´ì§
    function spawnFlowerRain(camX, camY, viewW, viewH, n=10){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.85,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        const x = camX + rand(-viewW*0.55, viewW*0.55);
        const y = camY + viewH*0.65 + rand(0.4, 2.4);
        mesh.position.set(x, y, 2.86);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        world.particles.push({
          kind:"petalRain",
          x, y,
          vx: rand(-1.2,1.2),
          vy: rand(-2.0,-7.5), // ì•„ë˜ë¡œ ì‹œì‘
          life: rand(1.2, 2.2),
          mesh,
          spin: rand(-6, 6),
          sway: rand(4, 10)
        });
      }
    }

    // âœ… í­ì£½: Additive + ë‹¤ìƒ‰ ìŠ¤íŒŒí¬
    function spawnFirework(cx, cy){
      SFX.firework();

      const palette = [0xff3b3b,0xffcc3d,0x8bff6a,0x3ddcff,0xb46bff,0xffffff,0xff7eb6];
      const count = 70;
      for(let i=0;i<count;i++){
        const col = choice(palette);
        const mat = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: col,
          transparent:true,
          opacity: 0.95,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const mesh = new THREE.Mesh(geoSpark, mat);
        mesh.position.set(cx, cy, 2.9);
        scene.add(mesh);

        const a = rand(0, Math.PI*2);
        const sp = rand(5.5, 15.5);
        world.particles.push({
          kind:"firework",
          x: cx, y: cy,
          vx: Math.cos(a)*sp + rand(-1.0,1.0),
          vy: Math.sin(a)*sp + rand(1.0,4.0),
          life: rand(0.9, 1.6),
          mesh,
          spin: rand(-12, 12),
          drag: rand(0.90, 0.95)
        });
      }
      // ì¤‘ì•™ í”Œë˜ì‹œ
      spawnParticles(cx, cy, 18, 1.3);
      screenShake(0.10, 0.14);
    }

    // Afterimage
    function spawnAfterimage(x,y, tex, sx, sy){
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity:0.35 });
      const sp = new THREE.Sprite(mat);
      sp.position.set(x, y, 2.9);
      sp.scale.set(sx, sy, 1);
      scene.add(sp);
      world.afterimages.push({ sp, life: 0.22 });
    }

    // í™”ë©´ í”ë“¤ë¦¼
    let shakeT=0, shakeP=0;
    function screenShake(t=0.12, p=0.12){ shakeT = Math.max(shakeT, t); shakeP = Math.max(shakeP, p); }

    
    // âœ… ì¶”ë½/ì£½ìŒ íŒ¡! ì—°ì¶œ (ê°„ë‹¨ + í”„ë¡œ ëŠë‚Œ)
    function spawnPop(x, y){
      // í”Œë˜ì‹œ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // íŒŒí¸/ë¨¼ì§€
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // ì¶”ê°€ ìŠ¤íŒŒí¬
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ì—°ì¶œ(ë§ + ì‘ì€ ë°˜ì§)
    function spawnAppear_origin(x, y){
      // ë§
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false, //falsse
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.15);
      mesh.scale.set(0.85, 0.85, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRing",
        x, y,
        vx:0, vy:0,
        life: 0.8, //0.34,
        mesh,
        spin: rand(-6, 6)
      });

      // ì‘ì€ ìŠ¤íŒŒí´
      for(let i=0;i<10;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(2.8, 5.2);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.75,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        m2.scale.set(0.55, 0.55, 1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd + rand(0.8, 2.2),
          life: rand(0.20, 0.30),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }
	    // ë³€ê²½í•œ ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ì—°ì¶œ(ë§ + ì‘ì€ ë°˜ì§)
    function spawnAppear(x, y){
      // í”Œë˜ì‹œ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // íŒŒí¸/ë¨¼ì§€
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // ì¶”ê°€ ìŠ¤íŒŒí¬
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ì‚¬ë§ "ì•„ì‰¬ìš´" ì—°ì¶œ(ê³¼í•œ í­ë°œ ëŒ€ì‹  ì‘ì€ ì”ê´‘)
    function spawnDeathPoof(x, y){
      // ì‘ì€ ë§
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.70,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.12);
      mesh.scale.set(0.55, 0.55, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRingSmall",
        x, y,
        vx:0, vy:0,
        life: 0.26,
        mesh,
        spin: rand(-6, 6)
      });

      // ìµœì†Œí•œì˜ íŒŒí¸
      spawnParticles(x, y, 12, 0.85);
      spawnDust(x, y, 8);
    }

// ----------------------------
    // Celeste ëŠë‚Œ í”Œë ˆì´ì–´(í•µì‹¬: 8ë°©í–¥ 1íšŒ ì—ì–´ëŒ€ì‹œ)
    // ----------------------------
    const GRAVITY_UP     = -30.0;
    const GRAVITY_DOWN   = -40.0;
    const FAST_FALL_MULT =  1.55;
    const APEX_VY        =  1.25;
    const APEX_GRAV_MULT =  0.65;

    const MOVE_MAX       =  8.8;
    const GROUND_ACCEL   =  26.0;
    const GROUND_BRAKE   =  30.0;
    const AIR_ACCEL      =  14.0;
    const AIR_BRAKE      =  10.0;
    const TURN_BOOST     =  1.40;

    const JUMP_V         =  14.6;
    const JUMP_CUT       =  0.55;
    const JUMP_HOLD_TIME =  0.12;
    const JUMP_HOLD_GRAV =  0.45;

    const COYOTE         =  0.11;
    const JUMP_BUF       =  0.12;

    // âœ… 8ë°©í–¥ ëŒ€ì‹œ(1íšŒ) - ê³µì¤‘ 1íšŒ, ë•…/ì‚¬ë‹¤ë¦¬ ì ‘ì´‰ ì‹œ ë¦¬í•„
    const DASH_SPEED     =  18.8;
    const DASH_TIME      =  0.15;
    const DASH_COOLDOWN  =  0.10;
    const DASH_CHARGES_MAX = 1;

    const STAND_H        =  1.55;
    const DUCK_H         =  1.00;        // ìˆ™ì´ê¸° í†µê³¼ í™•ì‹¤í•˜ê²Œ
    const DUCK_SPEED_MUL =  0.60;

    const CLIMB_SPEED    =  7.0;
    const LADDER_SNAP    =  22.0;
    const LADDER_TOP_PAD =  0.10;
    const LADDER_LOCK_T  =  0.18;

    const MAX_FALL_SPEED = -28.5;

    const SLIDE_SPEED    =  12.6;
    const SLIDE_TIME     =  0.22;
    const SLIDE_CD       =  0.42;

    const WALL_SLIDE_MAXFALL = -6.0;
    const WALL_JUMP_V        =  14.2;
    const WALL_JUMP_H        =  10.5;
    const WALL_GRACE         =  0.12;

    const playerMat = new THREE.SpriteMaterial({ map: TEX.idle, transparent:true });
    const playerSprite = new THREE.Sprite(playerMat);
    scene.add(playerSprite);

    // ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸(PLAYER_DOWN: 3í”„ë ˆì„)
    const deathMat = new THREE.SpriteMaterial({
      map: (PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]) ? PLAYER_DOWN.frames[0] : TEX.hit,
      transparent:true,
      opacity: 1.0
    });
    const deathSprite = new THREE.Sprite(deathMat);
    deathSprite.visible = false;
    deathSprite.frustumCulled = false;
    scene.add(deathSprite);

    const deathAnim = {
      active: false,
      t: 0,
      x: 0,
      y: 0,
      facing: 1,
      dur: RESPAWN_DELAY,
    };
	
	
	
	

    function beginDeathAnim(x, y, facing){
      deathAnim.active = true;
      deathAnim.t = 0;
      deathAnim.x = x;
      deathAnim.y = y;
      deathAnim.facing = (facing||1);
      deathAnim.dur = RESPAWN_DELAY;

      // ì²« í”„ë ˆì„ì—ì„œ ì‹œì‘
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]){
        deathSprite.material.map = PLAYER_DOWN.frames[0];
      }
      deathSprite.material.opacity = 1.0;
      deathSprite.visible = true;
      deathSprite.position.set(x, y, 3.25);
      // í”Œë ˆì´ì–´ ìŠ¤ì¼€ì¼ê³¼ ìœ ì‚¬í•˜ê²Œ(ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ë³´ì •)
      const asp = (PLAYER_DOWN.fw && PLAYER_DOWN.fh) ? (PLAYER_DOWN.fw / PLAYER_DOWN.fh) : 1;
      const baseY = 1.75;
      deathSprite.scale.set(baseY*asp * (deathAnim.facing>=0 ? 1 : -1), baseY, 1);
      deathSprite.rotation.z = 0;
    }

    function endDeathAnim(){
      deathAnim.active = false;
      deathSprite.visible = false;
    }

    function updateDeathAnim(dt){
      if(!deathAnim.active) return;
      deathAnim.t += dt;

      const t = deathAnim.t;
      // í”„ë ˆì„: 0 -> 1 -> 2 í›„ ìœ ì§€
      let fi = 0;
      if(t >= 0.12) fi = 1;
      if(t >= 0.24) fi = 2;
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[fi]){
        deathSprite.material.map = PLAYER_DOWN.frames[fi];
      }

      // ì‚´ì§ ìœ„ë¡œ "íˆ­" + ì•„ë˜ë¡œ ê°€ë¼ì•‰ê¸°
      const hop = Math.exp(-t*10) * 0.55;
      const fall = t * 0.95;
      const yy = deathAnim.y + hop - fall;
      deathSprite.position.set(deathAnim.x, yy, 3.25);

      // ì‚´ì§ ê¸°ìš¸ê¸°
      deathSprite.rotation.z = Math.sin(t*7.0) * 0.06;

      // í˜ì´ë“œ ì•„ì›ƒ
      const fadeStart = Math.min(0.55, RESPAWN_DELAY*0.55);
      if(t > fadeStart){
        const k = clamp((t - fadeStart) / Math.max(0.0001, (RESPAWN_DELAY - fadeStart)), 0, 1);
        deathSprite.material.opacity = 1 - easeOutCubic(k);
      }

      if(t >= RESPAWN_DELAY){
        endDeathAnim();
      }
    }

    const player = {
      x: 0, y: 2.5,
      vx: 0, vy: 0,
      w: 1.05, h: STAND_H,
      facing: 1,
      onGround: false,

      coyote: 0,
      jumpBuf: 0,
      jumpHold: 0,

      dashT: 0,
      dashCd: 0,
      dashTrailT: 0,
      dashCharges: DASH_CHARGES_MAX,

      invuln: 0,
      hurtT: 0,
      hp: 3,

      // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ëª¨ì…˜ íƒ€ì´ë¨¸(ì‹œê° íš¨ê³¼)
      spawnT: 0,

      isDucking: false,
      onLadder: false,
      isClimbing: false,
      ladderLock: 0,

      slideT: 0,
      slideCd: 0,

      wallDir: 0,
      wallGrace: 0,

      landSquashT: 0,

      idleStill: 0,
      state: "idle",
      animT: 0,
      duckStepT: 0,
    };

    function setPlayerTex(tex){
      if(playerSprite.material.map === tex) return;
      playerSprite.material.map = tex;
      playerSprite.material.needsUpdate = true;
    }

    function canStandHere(){
      const bottom = player.y - player.h*0.5;
      const ax = player.x - player.w*0.5;
      const ay = bottom;
      const aw = player.w;
      const ah = STAND_H;
      for(const p of world.platforms){
        if(aabbIntersect(ax, ay, aw, ah, p.x, p.y, p.w, p.h)) return false;
      }
      return true;
    }

const SKIN = 0.001;
const GROUND_PROBE = 0.06; // âœ… ë°”ë‹¥ ë¯¸ì„¸ ê²¹ì¹¨(ëœëœ ë–¨ë¦¼/ì™¼ìª½ ë ì›Œí”„) ë°©ì§€ìš©

function resolveCollisions(nextX, nextY){
  let x = nextX, y = nextY;
  let onGround = false;
  let wallDir = 0;

  const hw = player.w * 0.5;
  const hh = player.h * 0.5;

  // ---------------------------------
  // 1) Y(ìƒí•˜) í•´ê²°
  //   - vy<0(ë‚™í•˜): ì¼ë°˜ ë°”ë‹¥ ì¶©ëŒ
  //   - vy>0(ìƒìŠ¹): ì²œì¥ ì¶©ëŒ
  //   - vy==0 ì´ë©´ì„œ onGroundì˜€ë˜ ê²½ìš°: ë°”ë‹¥ ìŠ¤ëƒ…ìœ¼ë¡œ ë¯¸ì„¸ ê²¹ì¹¨ ì œê±°
  // ---------------------------------
  {
    const ax = x - hw;
    const aw = player.w;

    if(player.vy < 0){
      let best = -Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y + p.h + hh + SKIN; // ë°”ë‹¥ ìœ„ë¡œ ìŠ¤ëƒ…
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        y = best;
        player.vy = 0;
        onGround = true;
      }
    }else if(player.vy > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y - hh - SKIN; // ì²œì¥ ì•„ë˜ë¡œ ìŠ¤ëƒ…
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        y = best;
        player.vy = 0;
      }
    }else if((player.onGround || player.coyote > 0) && !player.isClimbing){
      // âœ… "ê°€ë§Œíˆ ìˆì„ ë•Œ ë–¨ë¦¼" + "ë²½/ì í”„ë²½ ë‹¿ì„ ë•Œ ì¢Œì¸¡ ëìœ¼ë¡œ ì›Œí”„"ì˜ ì›ì¸ì¸
      //    ë°”ë‹¥ì˜ 'ì•„ì£¼ ë¯¸ì„¸í•œ ê²¹ì¹¨'ì„ ë§¤ í”„ë ˆì„ ì œê±°
      const bottom = y - hh;
      let bestTop = -Infinity;

      // ë°œë ì•„ë˜ìª½ìœ¼ë¡œ ì•„ì£¼ ì–•ê²Œ í”„ë¡œë¸Œ
      const probeAy = bottom - GROUND_PROBE;
      const probeAh = player.h + GROUND_PROBE;

      for(const p of world.platforms){
        if(!aabbIntersect(ax, probeAy, aw, probeAh, p.x, p.y, p.w, p.h, 0)) continue;
        const top = p.y + p.h;

        // ë°”ë‹¥(í”Œë«í¼ top)ì´ ë°œë ê·¼ì²˜ì— ìˆì„ ë•Œë§Œ í›„ë³´ë¡œ ì¸ì •
        if(top <= bottom + GROUND_PROBE + 1e-4){
          if(top > bestTop) bestTop = top;
        }
      }

      if(bestTop > -Infinity){
        y = bestTop + hh + SKIN;
        onGround = true;
      }
    }
  }

  // ---------------------------------
  // 2) X(ì¢Œìš°) í•´ê²°
  //   - ë°”ë‹¥ì´ 'ë²½'ìœ¼ë¡œ ì˜¤ì¸ë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´
  //     Xì¶©ëŒ íŒì •ìš© AABBëŠ” ì„¸ë¡œë¡œ ì•„ì£¼ ì‚´ì§ ì¤„ì—¬ì„œ ì‚¬ìš©
  // ---------------------------------
  if(player.vx !== 0){
    const shrink = Math.min(0.03, player.h * 0.08);
    const ay = (y - hh) + shrink;
    const ah = player.h - shrink * 2;

    if(player.vx > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x - hw - SKIN;
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        x = best;
        player.vx = 0;
        wallDir = +1;
      }
    }else{
      let best = -Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x + p.w + hw + SKIN;
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        x = best;
        player.vx = 0;
        wallDir = -1;
      }
    }
  }

  return { x, y, onGround, wallDir };
}


    

    // ----------------------------
    // ì›”ë“œ ì •ë¦¬
    // ----------------------------
    function clearWorld(){
      for(const key of ["platforms","coins","enemies","springs","ladders","particles","afterimages","bossBullets"]){
        for(const o of world[key]){
          if(o.mesh) scene.remove(o.mesh);
          if(o.sp) scene.remove(o.sp);
        }
        world[key] = [];
      }
      if(world.goal?.mesh) scene.remove(world.goal.mesh);
      world.goal = null;
      if(world.boss?.mesh) scene.remove(world.boss.mesh);
      world.boss = null;

      world.totalCoinsLevel = 0;
      world.collectedCoinsLevel = 0;
      // totalCoinsRunì€ ì •ì±…ì— ë”°ë¼ ìœ ì§€/ë¦¬ì…‹ì—ì„œ ì²˜ë¦¬
    }

    // ----------------------------
    // í¼ì¦ ëª¨ë“ˆ: ì‚¬ë‹¤ë¦¬ í•„ìˆ˜
    // - ì í”„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ ë†’ì´ ì°¨ì´ë¥¼ í¬ê²Œ
    // - ë²½ì í”„ë¡œë„ ëª» ìš°íšŒí•˜ê²Œ ì¢Œìš° ì°¨ë‹¨ë²½/ì²œì¥ ì¶”ê°€
    // ----------------------------
    function buildLadderPuzzle(xStart, groundTop, diff){
      const low = addPlatform(xStart, groundTop-1.0, 6.0, 1.0);
      const lowTop = low.y + low.h;

      // ì í”„ë¡œ ëª» ë‹¿ë„ë¡ top ì°¨ì´ë¥¼ í¬ê²Œ(> ì•½ 3.8)
      const highTop = lowTop + rand(4.4, 5.2) + (diff-1)*0.3;
      const high = addPlatform(xStart + rand(2.0, 2.8), highTop-1.0, 6.0, 1.0);

      // ì‚¬ë‹¤ë¦¬ ì¤‘ì•™
      const ladderX = (Math.max(low.x+1.2, high.x+1.2) + Math.min(low.x+low.w-1.2, high.x+high.w-1.2)) / 2;
      //addLadderBetween(low, high, ladderX);

      // ì í”„/ë²½ì í”„ ìš°íšŒ ì°¨ë‹¨: ì–‘ìª½ ë²½ + ë‚®ì€ ì²œì¥
      addBlockWall(low.x - 0.6, lowTop, 0.6, (highTop - lowTop) + 3.0);
      addBlockWall(low.x + low.w, lowTop, 0.6, (highTop - lowTop) + 3.0);

      // ì²œì¥: low ìœ„ì— ì–•ê²Œ ë§Œë“¤ì–´ ì í”„ê³µê°„ ì œí•œ(ì‚¬ë‹¤ë¦¬ë¡œë§Œ â€œìœ„ìª½ í†µë¡œâ€)
      //addPlatform(low.x, lowTop + 1.35, low.w, 0.55);
	  // âœ… ì‚¬ë‹¤ë¦¬ êµ¬ë© ë‚¨ê¸°ëŠ” ì²œì¥(ì½”ì¸/ë“±ë°˜ í†µë¡œ í™•ë³´)
	/*	{
		  const gapW = 1.8;            // ì‚¬ë‹¤ë¦¬/ì½”ì¸ í†µë¡œ í­
		  const ceilY = lowTop + 2.0;  // ì½”ì¸ ë¼ì¸ë³´ë‹¤ ìœ„ë¡œ ì˜¬ë ¤ì„œ ì ˆëŒ€ ë§‰ì§€ ì•Šê²Œ
		  const ceilH = 0.55;

		  const leftEnd = (ladderX - gapW/2);
		  const rightStart = (ladderX + gapW/2);

		  const leftW = leftEnd - low.x;
		  if(leftW > 0.6) addPlatform(low.x, ceilY, leftW, ceilH);

		  const rightW = (low.x + low.w) - rightStart;
		  if(rightW > 0.6) addPlatform(rightStart, ceilY, rightW, ceilH);
		}
		{
		  const span = (highTop - lowTop);
		  const n = clamp(Math.floor(span / 0.85), 5, 10);
		  for(let i=0;i<n;i++){
			const t = (i+1) / (n+1);
			const yy = lerp(lowTop + 0.75, highTop - 0.75, t);
			safeAddCoin(ladderX, yy);
		  }
		}
*/
      // ì½”ì¸ íŒíŠ¸(ì‚¬ë‹¤ë¦¬ë¡œ ìœ ë„)
      for(let i=0;i<5;i++){
        //addCoin(ladderX, lowTop + 0.8 + i*0.75);
		safeAddCoin(ladderX, lowTop + 0.8 + i*0.75);
      }
      addCoin(high.x + high.w*0.5, highTop + 0.8);

      // ë‹¤ìŒìœ¼ë¡œ ì´ì–´ì§€ëŠ” ì¶œêµ¬ í”Œë«í¼
      const out = addPlatform(high.x + high.w + rand(2.2, 3.0), highTop-1.0, rand(4.2, 5.6), 1.0);
      if(rng() < clamp(0.18 + (diff-1)*0.08, 0.18, 0.45)){
        addEnemyOnPlatform(out, out.x + out.w*0.5);
      }
      return { endX: out.x + out.w, endTop: out.y + out.h, entry: low, exit: out };
    }

    // ----------------------------
    // í¼ì¦ ëª¨ë“ˆ: ìˆ™ì´ê¸° í•„ìˆ˜ í„°ë„
    // - ì„œìˆëŠ” ì¶©ëŒ ë†’ì´(STAND_H)ê°€ ëª» ë“¤ì–´ê°€ê²Œ
    // - ìˆ™ì´ê¸°(DUCK_H)ë§Œ í†µê³¼ ê°€ëŠ¥
    // - ìš°íšŒ í†µë¡œê°€ ì—†ë„ë¡ ë²½/ì§€í˜•ìœ¼ë¡œ ê°•ì œ
    // ----------------------------
    function buildDuckTunnelPuzzle(xStart, baseTop, diff){
      // ì…êµ¬ í”Œë«í¼
      const entry = addPlatform(xStart, baseTop-1.0, 6.0, 1.0);
      const entryTop = entry.y + entry.h;

      // í„°ë„ ë°”ë‹¥
      const floor = addPlatform(entry.x + entry.w + 1.4, baseTop-1.0, 9.0, 1.0);
      const floorTop = floor.y + floor.h;

      // clearance: STAND(1.55) ëª» ë“¤ì–´ê°€ê³  DUCK(1.00)ë§Œ ë“¤ì–´ê°€ê²Œ
      // í”Œë ˆì´ì–´ëŠ” ë°”ë‹¥ ê¸°ì¤€ìœ¼ë¡œ hê°€ ì ìš©ë˜ë¯€ë¡œ, ì‹¤ì§ˆ í†µê³¼ ë†’ì´ë¥¼ 1.10~1.18ë¡œ
      const clearance = 1.14;
      const ceilingY = floorTop + clearance;
      const ceiling = addPlatform(floor.x, ceilingY, floor.w, 0.6);

      // ì…êµ¬/ì¶œêµ¬ë¥¼ ê°•ì œí•˜ëŠ” ë²½(ìš°íšŒ ë°©ì§€)
      // ì…êµ¬ ë²½: ì²œì¥ ë†’ì´ê¹Œì§€ ë§‰ê³ , ì•„ë˜ë§Œ í†µê³¼ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ê¸°
      ////addBlockWall(floor.x - 0.55, floorTop, 0.55, clearance + 0.6);
      ////addBlockWall(floor.x + floor.w, floorTop, 0.55, clearance + 0.6);

      // ì¶œêµ¬ í”Œë«í¼(í„°ë„ ë)
      const exit = addPlatform(floor.x + floor.w + 1.6, baseTop-1.0, 6.0, 1.0);

      // ìš°íšŒ ì í”„ ì°¨ë‹¨(ìœ„ìª½ í° ì²œì¥)
      //addPlatform(floor.x - 0.6, ceilingY + 1.0, floor.w + 1.2, 0.8);

      // ì½”ì¸ ë¼ì¸(í„°ë„ ë‚´ë¶€)
      for(let i=0;i<8;i++){
        addCoin(floor.x + 1.0 + i*1.0, floorTop + 0.65);
      }

      // ë‚œì´ë„ì— ë”°ë¼ ì /ìŠ¤í”„ë§ ë°°ì¹˜
      if(rng() < clamp(0.10 + (diff-1)*0.05, 0.10, 0.25)){
        addSpringOnPlatform(exit, exit.x + exit.w*0.5);
      }else if(rng() < clamp(0.12 + (diff-1)*0.06, 0.12, 0.32)){
        addEnemyOnPlatform(exit, exit.x + exit.w*0.5);
      }

      return { endX: exit.x + exit.w, endTop: exit.y + exit.h, entry, exit };
    }

    // ----------------------------
    // ëœë¤ ë ˆë²¨ ìƒì„±(í¼ì¦ ëª¨ë“ˆ í¬í•¨)
    // ----------------------------
    function buildRandomLevel(level){
      clearWorld();

      const diff = 1.0 + (level-1)*0.16;
      game.difficulty = diff;

      const groundY = -2.8;
      const groundH = 2.2;
      const groundTop = groundY + groundH;


      world.groundTop = groundTop;
      world.killY = groundY - 10.5;

      // ì‹œì‘ ì§€ë©´
      addPlatform(-80, groundY, 160, groundH);

      // ì‹œì‘ ë°œíŒ
      let x = -18;
      let top = groundTop + 0.6;
      let p = addPlatform(x, top-1.0, 6.0, 1.0);

      // ì¼ë°˜ êµ¬ê°„ ëª‡ ê°œ
      const normalSteps = 3 + Math.min(2, level|0);
      for(let i=0;i<normalSteps;i++){
        const w = rand(3.6, 5.8);
        const gap = rand(1.4, 2.4) + (diff-1)*0.25;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 0.9) * (1.0 + (diff-1)*0.45);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 4.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.85) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.10 + (diff-1)*0.04, 0.10, 0.22)) addEnemyOnPlatform(p, p.x + p.w*0.5);
      }

      // âœ… ì‚¬ë‹¤ë¦¬ í•„ìˆ˜ í¼ì¦(í•­ìƒ 1íšŒ)
      const ladderSeg = buildLadderPuzzle(p.x + p.w + rand(2.2, 3.0), groundTop + 0.6, diff);
      x = ladderSeg.endX;
      top = ladderSeg.endTop;
      p = ladderSeg.exit;

      // ì¤‘ê°„ ì¼ë°˜ êµ¬ê°„
      const midSteps = 2 + Math.min(2, (level-1)|0);
      for(let i=0;i<midSteps;i++){
        const w = rand(3.2, 5.6);
        const gap = rand(1.5, 2.8) + (diff-1)*0.30;
        x = p.x + p.w + gap;

        const dy = rand(-0.8, 0.9) * (1.0 + (diff-1)*0.55);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.88) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.12 + (diff-1)*0.05, 0.12, 0.28)) addSpringOnPlatform(p, p.x + p.w*0.5);
      }

      // âœ… ìˆ™ì´ê¸° í•„ìˆ˜ í¼ì¦(í•­ìƒ 1íšŒ)
      const duckSeg = buildDuckTunnelPuzzle(p.x + p.w + rand(2.4, 3.2), groundTop + 0.6, diff);
      x = duckSeg.endX;
      top = duckSeg.endTop;
      p = duckSeg.exit;

      // ê³¨ ì• ë§ˆì§€ë§‰ êµ¬ê°„
      const tailSteps = 2 + Math.min(3, level|0);
      for(let i=0;i<tailSteps;i++){
        const w = rand(3.4, 6.2);
        const gap = rand(1.5, 2.8) + (diff-1)*0.35;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 1.0) * (1.0 + (diff-1)*0.60);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.8);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.9){
          addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
          if(rng() < 0.25) addCoin(p.x + rand(0.8, p.w-0.8), top + 1.3);
        }
        if(rng() < clamp(0.16 + (diff-1)*0.06, 0.16, 0.40)) addEnemyOnPlatform(p, p.x + p.w*0.55);
      }

      // âœ… ê³¨ ë² ì´ìŠ¤ í”Œë«í¼ + ê¹ƒë°œ
      const goalBase = addPlatform(p.x + p.w + 3.0, groundTop-1.0, 7.0, 1.0);
      addGoalWithBase(goalBase);

      // ê³¨ ì£¼ë³€ ì½”ì¸(ë§ˆì§€ë§‰ ìœ ë„)
      addCoin(goalBase.x + 2.0, goalBase.y + goalBase.h + 0.9);
      addCoin(goalBase.x + 4.5, goalBase.y + goalBase.h + 1.4);

      // UI ì´ˆê¸°í™”
      world.collectedCoinsLevel = 0;
      $stageText.textContent = `ë ˆë²¨ ${level}`;
      updateCoinHUD();
    }

    // ----------------------------
    // ì½”ì¸ HUD(ë ˆë²¨/ëŸ°)
    // ----------------------------
    function updateCoinHUD(){
      const levelPart = `${world.collectedCoinsLevel} / ${world.totalCoinsLevel}`;
      if(policy.keepCoins){
        $coinText.textContent = `${levelPart} | ì´ ${world.totalCoinsRun}`;
      }else{
        $coinText.textContent = levelPart;
      }
    }

    // ----------------------------
    // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
    // ----------------------------
    function updatePlayer(dt){
      const canControl = (game.state === "play" || game.state === "boss" || game.state === "bossIntro");

      player.ladderLock = Math.max(0, player.ladderLock - dt);
      player.slideCd = Math.max(0, player.slideCd - dt);
      player.landSquashT = Math.max(0, player.landSquashT - dt);
      player.hurtT = Math.max(0, player.hurtT - dt);
      player.invuln = Math.max(0, player.invuln - dt);
      player.wallGrace = Math.max(0, player.wallGrace - dt);

      player.dashCd = Math.max(0, player.dashCd - dt);
      if(player.dashT > 0) player.dashT = Math.max(0, player.dashT - dt);

      // ì‚¬ë‹¤ë¦¬ ì˜¤ë²„ë©
      let ladder = null;
      player.onLadder = false;
      if(player.ladderLock <= 0){
        const margin = 0.18;
        const px = (player.x - player.w*0.5) - margin;
        const py = (player.y - player.h*0.5);
        const pw = player.w + margin*2;
        const ph = player.h;
        for(const l of world.ladders){
          if(aabbIntersect(px, py, pw, ph, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }

      // ëŒ€ì‹œ ë¦¬í•„: ë•…/ì‚¬ë‹¤ë¦¬ ì ‘ì´‰ ì‹œ
      if(player.onGround || player.onLadder){
        player.dashCharges = DASH_CHARGES_MAX;
      }
      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;

      // í´ë¼ì„ ì‹œì‘/ì¢…ë£Œ
      if(player.isClimbing){
        if(!player.onLadder || !canControl) player.isClimbing = false;
      }else{
        if(player.onLadder && canControl && (input.up || input.down) && player.dashT<=0){
          player.isClimbing = true;
          player.vx = 0; player.vy = 0;
        }
      }

      // ìˆ™ì´ê¸°(ì¶©ëŒ ë°•ìŠ¤ ê°ì†Œ)
      if(canControl && !player.isClimbing && player.onGround && player.dashT<=0){
        if(input.down || player.slideT>0){
          if(!player.isDucking){
            const bottom = player.y - player.h*0.5;
            player.isDucking = true;
            player.h = DUCK_H;
            player.y = bottom + player.h*0.5;
          }
        }else{
          if(player.isDucking && canStandHere()){
            const bottom = player.y - player.h*0.5;
            player.isDucking = false;
            player.h = STAND_H;
            player.y = bottom + player.h*0.5;
          }
        }
      }else{
        if(!player.onGround && player.isDucking && player.slideT<=0){
          const bottom = player.y - player.h*0.5;
          player.isDucking = false;
          player.h = STAND_H;
          player.y = bottom + player.h*0.5;
        }
      }

      // ì í”„ ë²„í¼/ì½”ìš”í…Œ
      if(player.onGround && !player.isClimbing) player.coyote = COYOTE;
      else player.coyote = Math.max(0, player.coyote - dt);

      if(canControl && input.jumpPressed) player.jumpBuf = JUMP_BUF;
      else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

      // ìŠ¬ë¼ì´ë“œ(â†“+ëŒ€ì‹œ í‚¤: ê¸°ë³¸ X)
      if(canControl && player.onGround && !player.isClimbing && player.dashT<=0){
        if(input.dashPressed && input.down && player.slideCd<=0 && player.slideT<=0){
          player.slideT = SLIDE_TIME;
          player.slideCd = SLIDE_CD;
          player.isDucking = true;
          player.h = DUCK_H;
          player.vx = SLIDE_SPEED * player.facing;
          spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
          screenShake(0.08, 0.10);
          showToast("ìŠ¬ë¼ì´ë“œ!", 450);
        }
      }
      if(player.slideT > 0){
        player.slideT = Math.max(0, player.slideT - dt);
        player.vx = moveTowards(player.vx, 0, 26 * dt);
        if(player.slideT===0) spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 6);
      }

      // ë°©í–¥/ì´ë™
      const dir = canControl ? ((input.left ? -1 : 0) + (input.right ? 1 : 0)) : 0;
      if(dir !== 0 && !input.faceLock) player.facing = dir;
      else if(player.facing === 0) player.facing = 1;

      const speedMul = (player.isDucking ? DUCK_SPEED_MUL : 1.0);
      const targetVx = dir * MOVE_MAX * speedMul;

      if(!player.isClimbing && player.dashT <= 0 && player.slideT<=0){
        const reversing = (dir !== 0) && (player.vx !== 0) && (Math.sign(player.vx) !== Math.sign(targetVx));
        if(player.onGround){
          const accel = (dir!==0 ? GROUND_ACCEL : GROUND_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          const before = player.vx;
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
          if(reversing && Math.abs(before) > 5.5) spawnDust(player.x - sign(before)*0.15, player.y - player.h/2 + 0.02, 4);
        }else{
          const accel = (dir!==0 ? AIR_ACCEL : AIR_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
        }
      }

      // í´ë¼ì„
      if(player.isClimbing && ladder && canControl){
        const lx = ladder.x + ladder.w*0.5;
        player.x = lerp(player.x, lx, 1 - Math.exp(-LADDER_SNAP*dt));

        const v = (input.up?1:0) + (input.down?-1:0);
        player.vy = v * CLIMB_SPEED;

        // âœ… ë°”ë‹¥ í”Œë«í¼ ë‚´ë¶€ë¡œ ë“¤ì–´ê°€ì§€ ì•Šê²Œ + ë°©í–¥ ì•ˆì •í™”
		const minY = ladder.topLow  + (player.h*0.5) + 0.02;
		const maxY = ladder.topHigh + (player.h*0.5) + 0.02;
		player.y = clamp(player.y, minY, maxY);

		// âœ… ìœ„/ì•„ë˜ ì…ë ¥ ì—†ì´ ì¢Œ/ìš°ë¡œ ì›€ì§ì´ë©´ ì‚¬ë‹¤ë¦¬ì—ì„œ â€œì˜†ìœ¼ë¡œ ë¹ ì ¸ë‚˜ì˜¤ê¸°â€
		if((input.left || input.right) && !(input.up || input.down)){
		  player.isClimbing = false;
		  player.ladderLock = 0.12;
		}

        const nearTop = (player.y - player.h*0.5) >= (ladder.topHigh - LADDER_TOP_PAD);
        if(nearTop && input.up){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.vy = 0;
          player.y = ladder.topHigh + player.h*0.5 + 0.02;
        }

        if(input.jumpPressed){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.jumpBuf = 0; player.coyote = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          player.vy = JUMP_V;
          player.vx = MOVE_MAX * 0.70 * player.facing;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          screenShake(0.09, 0.10);
        }
      }else{
        // ë²½ ì í”„
        if(canControl && input.jumpPressed && player.wallGrace > 0 && !player.onGround && player.dashT<=0){
          const wd = player.wallDir || (dir!==0 ? -dir : -player.facing);
          player.vy = WALL_JUMP_V;
          player.vx = -wd * WALL_JUMP_H;
          player.facing = -wd;
          player.wallGrace = 0;
          player.jumpHold = JUMP_HOLD_TIME * 0.75;
          spawnDust(player.x + wd*0.25, player.y - player.h/2 + 0.12, 10);
          screenShake(0.10, 0.12);
          showToast("ë²½ ì í”„!", 520);
        }

        // ì í”„
        if(canControl && player.jumpBuf > 0 && (player.onGround || player.coyote > 0) && player.dashT<=0){
          player.vy = JUMP_V;
          player.onGround = false;
          player.coyote = 0;
          player.jumpBuf = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          spawnDust(player.x, player.y - player.h/2 + 0.02, 6);
          screenShake(0.09, 0.10);
          SFX.jump();
          showToast("ì í”„!", 450);
        }

        // ì í”„ ì»·
        if(input.jumpReleased && player.vy > 0){
          player.vy *= JUMP_CUT;
          player.jumpHold = 0;
        }

        // âœ… 8ë°©í–¥ ëŒ€ì‹œ(ê³µì¤‘ 1íšŒ)
        if(canControl && input.dashPressed && player.dashCd<=0 && player.dashT<=0 && player.dashCharges>0){
          // ë°©í–¥ ì…ë ¥ (ì—†ìœ¼ë©´ facing)
          let dx = (input.left?-1:0) + (input.right?1:0);
          let dy = (input.down?-1:0) + (input.up?1:0);
          if(dx===0 && dy===0) dx = player.facing;

          // ì •ê·œí™”
          const len = Math.hypot(dx,dy) || 1;
          dx /= len; dy /= len;

          player.dashT = DASH_TIME;
          player.dashCd = DASH_COOLDOWN;
          player.dashCharges--;

          player.isDucking = false;
          player.h = STAND_H;

          player.vx = dx * DASH_SPEED;
          player.vy = dy * DASH_SPEED;

          player.dashTrailT = 0.02;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);

          spawnParticles(player.x, player.y, 12, 1.2);
          screenShake(0.10, 0.12);
          SFX.dash();
          showToast("ëŒ€ì‹œ!", 420);
        }

        // ëŒ€ì‹œ ì¤‘(ì§§ê²Œ ì¤‘ë ¥ ì•½í™”)
        if(player.dashT > 0){
          player.vx = moveTowards(player.vx, player.vx, 0); // ìœ ì§€
          player.vy = moveTowards(player.vy, player.vy, 0);
          // ì‚´ì§ ê°ì‡ ë¡œ ì…€ë ˆìŠ¤íŠ¸ ëŠë‚Œ
          player.vx *= 0.995;
          player.vy *= 0.995;
        }else{
          // ì¤‘ë ¥
          let g = (player.vy > 0) ? GRAVITY_UP : GRAVITY_DOWN;

          if(!player.onGround && Math.abs(player.vy) <= APEX_VY){
            g *= APEX_GRAV_MULT;
          }

          if(player.vy > 0 && input.jump && player.jumpHold > 0){
            player.jumpHold = Math.max(0, player.jumpHold - dt);
            g *= JUMP_HOLD_GRAV;
          }else{
            player.jumpHold = 0;
          }

          if(!player.onGround && player.vy < 0 && input.down){
            g *= FAST_FALL_MULT;
          }

          player.vy += g * dt;
          player.vy = Math.max(player.vy, MAX_FALL_SPEED);
        }
      }

      // ëŒ€ì‹œ ì”ìƒ
      if(player.dashT > 0){
        player.dashTrailT -= dt;
        if(player.dashTrailT <= 0){
          player.dashTrailT = 0.03;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);
        }
      }

      // ì ë¶„ + ì¶©ëŒ
      const nextX = player.x + player.vx*dt;
      const nextY = player.y + player.vy*dt;
      const beforeGround = player.onGround;

      const res = resolveCollisions(nextX, nextY);
      player.x = res.x;
      player.y = res.y;

      if(!player.onGround && res.wallDir !== 0){
        player.wallDir = res.wallDir;
        player.wallGrace = WALL_GRACE;
      }else if(player.wallGrace <= 0){
        player.wallDir = 0;
      }

      player.onGround = res.onGround && !player.isClimbing;

      if(!beforeGround && player.onGround){
        player.landSquashT = 0.12;
        spawnParticles(player.x, player.y - player.h/2 + 0.05, 14, 1.0);
        spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
        screenShake(0.09, 0.10);
      }

      // ë²½ ìŠ¬ë¼ì´ë“œ
      const wantsWall = (dir !== 0) ? dir : player.facing;
      if(!player.onGround && player.wallGrace > 0 && player.vy < 0 && !player.isClimbing){
        if(wantsWall === player.wallDir){
          player.vy = Math.max(player.vy, WALL_SLIDE_MAXFALL);
          if(rng() < 0.08) spawnDust(player.x + player.wallDir*0.22, player.y - player.h/2 + 0.35, 2);
        }
      }

      // ì• ë‹ˆ ìƒíƒœ
      const isMoving = Math.abs(player.vx) > 0.65;
      const groundIdle = player.onGround && !player.isClimbing && !player.isDucking && !isMoving;
      const frontHold = groundIdle && input.up && canControl;

      if(player.isClimbing) player.state = "climb";
      else if(player.slideT>0) player.state = "slide";
      else if(player.isDucking && isMoving && player.onGround) player.state = "duckWalk";
      else if(player.isDucking) player.state = "duck";
      else if(frontHold) player.state = "frontHold";
      else if(!player.onGround) player.state = "jump";
      else if(isMoving) player.state = "walk";
      else player.state = "idle";

      player.idleStill = groundIdle ? (player.idleStill + dt) : 0;
      player.animT += dt;

      const showHit = player.hurtT > 0;

      if(showHit) setPlayerTex(TEX.hit);
      else if(player.state === "frontHold") setPlayerTex(TEX.front);
      else if(player.state === "idle") setPlayerTex(player.idleStill > 0.6 ? TEX.front : TEX.idle);
      else if(player.state === "jump") setPlayerTex(player.facing < 0 ? TEX.jumpBack : TEX.jump);
      else if(player.state === "walk"){
        const phase = Math.floor(player.animT*10) % 2;
        if(player.facing < 0){
          setPlayerTex(phase ? TEX.walkABack : TEX.walkBBack);
        }else{
          setPlayerTex(phase ? TEX.walkA : TEX.walkB);
        }
      }else if(player.state === "duck" || player.state === "duckWalk" || player.state === "slide"){
        setPlayerTex(TEX.duck);
      }else if(player.state === "climb"){
        const moving = Math.abs(player.vy) > 0.2;
        const phase = Math.floor(player.animT*10) % 2;
        setPlayerTex(moving ? (phase ? TEX.climbA : TEX.climbB) : TEX.climbA);
      }

      // ì‹œê° ìŠ¤ì¼€ì¼
      let baseScaleX = 1.65;
      let baseScaleY = 1.65;
      let yBob = 0;

      if(player.landSquashT > 0){
        const t = 1 - (player.landSquashT / 0.12);
        const squash = Math.sin(t * Math.PI);
        baseScaleY *= (1.0 - 0.10*squash);
        baseScaleX *= (1.0 + 0.06*squash);
      }

      if(player.state === "duckWalk"){
        const t = player.animT * 12.0;
        yBob = Math.sin(t) * 0.035;
        baseScaleY *= 0.90;
        baseScaleX *= 1.02;
        player.duckStepT -= dt;
        if(player.duckStepT <= 0){
          player.duckStepT = 0.09;
          spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 4);
        }
      }else if(player.state === "slide"){
        baseScaleY *= 0.88;
        baseScaleX *= 1.06;
        if(rng() < 0.25) spawnDust(player.x - player.facing*0.25, player.y - player.h/2 + 0.02, 2);
        player.duckStepT = 0;
      }else{
        player.duckStepT = 0;
      }

      // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ëª¨ì…˜(ìŠ¤ì¼€ì¼ 0â†’1 + ì•½ê°„ì˜ ì˜¤ë²„ìŠˆíŠ¸)
      if(player.spawnT > 0){
        player.spawnT = Math.max(0, player.spawnT - dt);
        const k = 1 - clamp(player.spawnT / SPAWN_DUR, 0, 1);
        const s = clamp(easeOutBack(k), 0, 1.25);
        baseScaleX *= s;
        baseScaleY *= s;
        // ì•½ê°„ ìœ„ë¡œ ëœ¨ëŠ” ëŠë‚Œ
        yBob += (1 - easeOutCubic(clamp(k,0,1))) * 0.18;
      }

      playerSprite.position.set(player.x, player.y + 0.08 + yBob, 3);
      playerSprite.scale.set(baseScaleX, baseScaleY, 1);
      {
        const map = playerSprite.material.map;
        const isBackTex = (map === TEX.jumpBack || map === TEX.walkABack || map === TEX.walkBBack);
        playerSprite.scale.x = Math.abs(playerSprite.scale.x) * (isBackTex ? 1 : (player.facing>=0 ? 1 : -1));
      }

      // ë¬´ì  ê¹œë¹¡ì„
      if(player.invuln > 0){
        const blink = (Math.floor(player.animT*16) % 2) ? 0.35 : 1.0;
        playerSprite.material.opacity = blink;
      }else{
        playerSprite.material.opacity = 1.0;
      }
    }

    // ----------------------------
    // ì½”ì¸/ì /ìŠ¤í”„ë§/ê³¨
    // ----------------------------
    function updateCoins(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const c of world.coins){
        if(c.dead) continue;
        c.t += dt;
        const bob = Math.sin(c.t*4.2)*0.10;
        c.mesh.position.y = c.y + bob;
        c.mesh.rotation.z = Math.sin(c.t*2.2)*0.08;

        const cx = c.x - c.r;
        const cy = (c.y+bob) - c.r;
        if(aabbIntersect(px,py,player.w,player.h, cx,cy,c.r*2,c.r*2)){
          c.dead = true;
          scene.remove(c.mesh);

          world.collectedCoinsLevel++;
          if(policy.keepCoins) world.totalCoinsRun++;
          updateCoinHUD();

          spawnParticles(c.x, c.y, 12, 1.1);
          screenShake(0.06, 0.08);
          SFX.coin();
        }
      }
    }
    
	function updateDebugOverlay(){
		  if(!debug.enabled) return;

		  resetDebugPool();

		  // í˜„ì¬ ë·° ë²”ìœ„(ê°€ê¹Œìš´ ê²ƒë§Œ ê·¸ë ¤ì„œ ê°€ë³ê²Œ)
		  const viewW = (camera.right - camera.left) / camera.zoom;
		  const viewH = (camera.top - camera.bottom) / camera.zoom;
		  const minX = camX - viewW*0.5 - 2.5;
		  const maxX = camX + viewW*0.5 + 2.5;
		  const minY = camY - viewH*0.5 - 2.5;
		  const maxY = camY + viewH*0.5 + 2.5;

		  // í”Œë ˆì´ì–´ AABB
		  {
			const px = player.x - player.w*0.5;
			const py = player.y - player.h*0.5;
			const r = getRect(MAT_PLAYER);
			setRect(r, px, py, player.w, player.h);
		  }

		  // ì†ë„ ë²¡í„°(í˜„ì¬ ì†ë„ ë°©í–¥ í™•ì¸ìš©)
		  {
			const sx = player.x;
			const sy = player.y;
			const scale = 0.12; // í™”ë©´ì—ì„œ ë³´ê¸° ì¢‹ì€ ìŠ¤ì¼€ì¼
			setVelLine(sx, sy, sx + player.vx*scale, sy + player.vy*scale);
		  }

		  // í”Œë«í¼(ì†”ë¦¬ë“œ)
		  for(const p of world.platforms){
			if(p.x > maxX || p.x+p.w < minX || p.y > maxY || p.y+p.h < minY) continue;
			const r = getRect(MAT_SOLID);
			setRect(r, p.x, p.y, p.w, p.h);
		  }

		  // ì‚¬ë‹¤ë¦¬
		  for(const l of world.ladders){
			if(l.x > maxX || l.x+l.w < minX || l.y > maxY || l.y+l.h < minY) continue;
			const r = getRect(MAT_LADDER);
			setRect(r, l.x, l.y, l.w, l.h);
		  }

		  // ì½”ì¸(ì›í˜• ëŒ€ì‹  ë°•ìŠ¤)
		  for(const c of world.coins){
			if(c.dead) continue;
			const size = c.r*2;
			const x = c.x - c.r;
			const y = c.y - c.r;
			if(x > maxX || x+size < minX || y > maxY || y+size < minY) continue;
			const r = getRect(MAT_COIN);
			setRect(r, x, y, size, size);
		  }

		  // ì 
		  for(const e of world.enemies){
			if(e.dead) continue;
			const x = e.x - e.w/2;
			const y = e.y - e.h/2;
			if(x > maxX || x+e.w < minX || y > maxY || y+e.h < minY) continue;
			const r = getRect(MAT_ENEMY);
			setRect(r, x, y, e.w, e.h);
		  }

		  // ê³¨
		  if(world.goal){
			const g = world.goal;
			const gx = g.x - g.w/2;
			const gy = g.y - g.h/2;
			if(!(gx > maxX || gx+g.w < minX || gy > maxY || gy+g.h < minY)){
			  const r = getRect(MAT_GOAL);
			  setRect(r, gx, gy, g.w, g.h);
			}
		  }
		}
	
    function hurtPlayer(fromX){
      if(player.invuln > 0 || (game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro")) return;
      player.hp = Math.max(0, player.hp - 1);
      $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));

      // HPê°€ 0ì´ ë˜ë©´ ì¦‰ì‹œ ì‚¬ë§ ì—°ì¶œ(ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ + ì‚¬ìš´ë“œ) í›„ ë¦¬ìŠ¤í°
      if(player.hp <= 0){
        startRespawn("ì²´ë ¥ì´ ë‹¤í–ˆì–´â€¦");
        return;
      }

      player.invuln = 1.0;
      player.hurtT = 0.22;

      const dir = sign(player.x - fromX) || 1;
      player.vx = dir * 10.5;
      player.vy = 9.5;
      screenShake(0.12, 0.15);
      spawnParticles(player.x, player.y, 18, 1.25);
      spawnDust(player.x, player.y - player.h/2 + 0.05, 10);
      SFX.hurt();
      showToast("í”¼ê²©!", 700);
    }

    function updateEnemies(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const e of world.enemies){
        // ì£½ìŒ ì—°ì¶œ(ë‚©ì‘) íƒ€ì´ë¨¸
        if(e.dead){
          e.deathTimer -= dt;
          if(e.deathTimer <= 0){
            scene.remove(e.mesh);
            e.deathTimer = 0;
          }
          continue;
        }

        e.x += e.vx * dt;
        if(e.x < e.roamMin || e.x > e.roamMax) e.vx *= -1;

        e.mesh.position.x = e.x;

        // âœ… ìŠ¬ë¼ì„ í…ìŠ¤ì³ ì• ë‹ˆë©”ì´ì…˜(ê±·ê¸°/íœ´ì‹)
        e.animT += dt;
        const moving = Math.abs(e.vx) > 0.05;

        // movingì´ë©´ walkA/walkB ë²ˆê°ˆì•„, ì•„ë‹ˆë©´ rest
        const phase = (Math.floor(e.animT*8) % 2);
        const nextTex = moving ? (phase ? texSlimeWalkA : texSlimeWalkB) : texSlimeRest;

        if(e.mesh.material.map !== nextTex){
          e.mesh.material.map = nextTex;
          e.mesh.material.needsUpdate = true;
        }

const ex = e.x - e.w/2;
        const ey = e.y - e.h/2;
        if(aabbIntersect(px,py,player.w,player.h, ex,ey,e.w,e.h)){
          const playerBottom = player.y - player.h*0.5;
          const enemyTop = e.y + e.h*0.5;

          if(player.vy < 0 && playerBottom > enemyTop - 0.25){
            e.dead = true;
            // âœ… ë‚©ì‘(Flat) ìŠ¤í”„ë¼ì´íŠ¸ë¡œ ì ê¹ ì—°ì¶œ í›„ ì œê±°
            e.mesh.material.map = texSlimeFlat;
            e.mesh.material.needsUpdate = true;
            e.mesh.scale.y = 0.55;
            e.deathTimer = 0.14;
            player.vy = 12.0;
            spawnParticles(e.x, e.y, 22, 1.35);
            spawnDust(e.x, e.y - 0.25, 10);
            screenShake(0.10, 0.12);
            SFX.stomp();
            showToast("ë°Ÿê¸°!", 500);
          }else{
            hurtPlayer(e.x);
          }
        }
      }
    }

    function updateSprings(){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const s of world.springs){
        const sx = s.x - s.w/2;
        const sy = s.y - s.h/2;
        if(aabbIntersect(px,py,player.w,player.h, sx,sy,s.w,s.h)){
          if(player.vy < 0){
            player.vy = 18.5;
            player.jumpHold = 0;
            spawnParticles(s.x, s.y+0.2, 18, 1.2);
            spawnDust(s.x, s.y, 10);
            screenShake(0.10, 0.14);
            showToast("ìŠ¤í”„ë§!", 600);
          }
        }
      }
    }

    function updateGoal(){
      if(!world.goal) return;

      const g = world.goal;

      // ë ˆë²¨ ì½”ì¸ ë‹¤ ëª¨ìœ¼ë©´ í™œì„±í™”(í¼ì¦/íƒìƒ‰ ëŠë‚Œ)
      if(!g.active && world.collectedCoinsLevel >= world.totalCoinsLevel){
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("ê³¨ í™œì„±í™”!", 900);
      }

      if(!g.active || game.state !== "play") return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

      if(aabbIntersect(px,py,player.w,player.h, gx,gy,g.w,g.h)){
        // âœ… ì½”ì¸ ì „ë¶€ ìˆ˜ì§‘ í›„ ê³¨ ë„ì°© â†’ ë³´ìŠ¤ì „ìœ¼ë¡œ ì „í™˜(ë ˆë²¨ì„ ë°”ë¡œ ë„˜ê¸°ì§€ ì•ŠìŒ)
        startBossFight();
      }
    }
    
	function jumpGoal(){
	    const g = world.goal;

      // ë ˆë²¨ ì½”ì¸ ë‹¤ ëª¨ìœ¼ë©´ í™œì„±í™”(í¼ì¦/íƒìƒ‰ ëŠë‚Œ)
      
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("ê³¨ í™œì„±í™”!", 900);
      

      

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

     
        startBossFight();
      
	}
	
    // ----------------------------
    // ë³´ìŠ¤ì „(ê±°ëŒ€í•œ ê³ ë˜)
    //  - ì½”ì¸ ì „ë¶€ ìˆ˜ì§‘ í›„ ê¹ƒë°œ ë„ì°© â†’ ë³´ìŠ¤ì „ ì§„ì…
    //  - í™”ë©´ ìš°ì¸¡ì—ì„œ ìƒí•˜ ì´ë™
    //  - ê±°í’ˆ ë¯¸ì‚¬ì¼ ë°œì‚¬(ë‚œì´ë„â†‘: ë°œì‚¬ ë¹ˆë„/ì†ë„/íŒ¨í„´ ê³ ë„í™”)
    //  - í”Œë ˆì´ì–´ëŠ” ëŒ€ì‹œë¡œ ëª¸í†µì— ë°•ì¹˜ê¸°í•˜ë©´ í”¼í•´
    // ----------------------------
    const texBubble = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);

      // ì™¸ê³½
      g.beginPath();
      g.arc(w/2,h/2,w*0.34,0,Math.PI*2);
      g.closePath();
      g.strokeStyle = "rgba(9,9,9,0.50)";
      g.lineWidth = w*0.03;
      g.stroke();

      // ë‚´ë¶€ ê·¸ë¼ë°ì´ì…˜
      const grd = g.createRadialGradient(w*0.38,h*0.38,w*0.05, w*0.5,h*0.5,w*0.38);
      grd.addColorStop(0, "rgba(220,245,255,0.55)");
      grd.addColorStop(0.55, "rgba(140,210,255,0.20)");
      grd.addColorStop(1, "rgba(40,120,190,0.10)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(w/2,h/2,w*0.33,0,Math.PI*2);
      g.fill();

      // í•˜ì´ë¼ì´íŠ¸
      g.fillStyle = "rgba(255,255,255,0.55)";
      g.beginPath();
      g.ellipse(w*0.38, h*0.35, w*0.10, h*0.07, -0.6, 0, Math.PI*2);
      g.fill();

      g.fillStyle = "rgba(255,255,255,0.28)";
      g.beginPath();
      g.ellipse(w*0.62, h*0.62, w*0.06, h*0.04, 0.7, 0, Math.PI*2);
      g.fill();
    });

    function setBossHUD(on, boss){
      if(!$bossHpWrap) return;
      $bossHpWrap.style.display = on ? "" : "none";
      if(on && boss){
        $bossHpText.textContent = "â– ".repeat(Math.max(0, boss.hp)) + "â–¡".repeat(Math.max(0, boss.maxHp - boss.hp));
        $bossLvText.textContent = `Lv${boss.diff}`;
      }
    }

    function buildBossArena(diff){
      clearWorld();

      // ë°”ë‹¥/ë²½: ë²½ì í”„ ê°€ëŠ¥í•˜ê²Œ ê°„ë‹¨í•œ ê¸°ë‘¥ ì œê³µ
      const ground = addPlatform(-20, 0, 80, 1.0);
      world.groundTop = ground.y + ground.h;
      world.killY = -12;

      // ì¢Œì¸¡ ì‹œì‘ êµ¬ì—­ ê¸°ë‘¥(ë²½ì í”„ìš©)
      // (ìš”ì²­) ë³´ìŠ¤ì „ ì‹œì‘ êµ¬ì—­ ê¸°ë‘¥ ì œê±°
      // ì‘ì€ ë°œíŒ
      addPlatform(-8, 3.0, 5.0, 0.8);
      addPlatform( 2, 4.6, 4.2, 0.8);
      addPlatform(14, 3.8, 4.8, 0.8);

      // í”Œë ˆì´ì–´ ìœ„ì¹˜
      player.x = -15.5;
      player.y = 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // (ì‚¬ë§ ë¦¬ìŠ¤í°) HP ì •ì±…: ë¬´ì¡°ê±´ 5ë¡œ íšŒë³µ
      if(game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "â¤â¤â¤â¤â¤";
        game.forceFullHP = false;
      }else{
        $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));
      }

      // "ë¿…" ë“±ì¥ ì´í™íŠ¸ + ëª¨ì…˜
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

      // ë³´ìŠ¤ ìƒì„±
      const bossW = 7.2;
      const bossH = 5.2;
      const hitW  = 4.8;
      const hitH  = 3.4;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(bossW, bossH),
        new THREE.MeshBasicMaterial({ map: BOSS_TEX.idleA, transparent:true, color: 0xffffff })
      );
      mesh.position.set(18, 7.0, 1.2);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.boss = {
        diff,
        hp: 5,
        maxHp: 5,
        x: mesh.position.x,
        y: mesh.position.y,
		baseX: mesh.position.x-15,   // âœ… ì¶”ê°€
        baseY: mesh.position.y-5,   // âœ… ì¶”ê°€
        w: bossW, h: bossH,
        hitW, hitH,
        mesh,
        t: 0,
        invuln: 0,
        hurtT: 0,
        chargeT: 0,
        fireCd: 1.1,
        patternCd: 3.2,
        pattern: "aim",
      };

      setBossHUD(true, world.boss);
    }

    function startBossFight(){
      // ë‹¤ìŒ ë ˆë²¨ì€ ë³´ìŠ¤ ê²©íŒŒ í›„ ì§„í–‰
      game.pendingNextLevel = game.level + 1;

      // ëˆ„ì  ë‚œì´ë„(ë³´ìŠ¤ íŒ¨í„´)
      const diff = Math.max(1, (game.bossDifficulty|0));

      // ë³´ìŠ¤ì „ìœ¼ë¡œ ì „í™˜
      game.state = "bossIntro";
      game.t = 1.2;

      // arena êµ¬ì„±
      buildBossArena(diff);
      $stageText.textContent = `BOSS Lv ${diff}`;

      showBigMsg(true, `BOSS ë“±ì¥! ê±°ëŒ€í•œ ê³ ë˜ (Lv ${diff})`);
      showToast("ë³´ìŠ¤ì „! ê±°í’ˆ ë¯¸ì‚¬ì¼ì„ í”¼í•˜ê³  ëŒ€ì‹œë¡œ ê³µê²©!", 15000);
	  showToast("ëŒ€ì‹œ!! ", 15000);
      //screenShake(0.18, 0.20);
	  screenShake(0.99, 0.99);
	  screenShake(0.18, 0.20);
      SFX.clear();
    }

    function spawnBubble(x,y, vx,vy, r=0.42, homing=0){
      const geo = new THREE.PlaneGeometry(r*2, r*2);
      const mat = new THREE.MeshBasicMaterial({ map: texBubble, transparent:true, opacity:0.95 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, 1.1);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.bossBullets.push({
        x,y,r,vx,vy, homing,
        life: 8.0,
        spin: rand(-5,5),
        wob: rand(0,Math.PI*2),
        mesh
      });
    }

    function chooseBossPattern(diff){
      // diffê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ íŒ¨í„´ í’€ í™•ëŒ€
      const pool = ["aim"];
      if(diff >= 2) pool.push("triple");
      if(diff >= 3) pool.push("wave");
      if(diff >= 4) pool.push("homing");
      if(diff >= 6) pool.push("spray");
      return pool[(Math.random()*pool.length)|0];
    }

    function fireBoss(b){
      // ê³µí†µ íŒŒë¼ë¯¸í„°(ë‚œì´ë„ ìŠ¤ì¼€ì¼)
      const spd = 7.8 + b.diff*0.85;
      const rateBase = Math.max(0.34, 1.05 - b.diff*0.06);
      b.fireCd = rateBase * rand(0.85, 1.15);

      // ê³µê²© ì—°ì¶œ: ì ê¹ charge í”„ë ˆì„
      b.chargeT = 0.14;

      const dx0 = (player.x - b.x);
      const dy0 = (player.y - b.y);
      const len = Math.hypot(dx0, dy0) || 1;
      const ux = dx0/len, uy = dy0/len;

      if(b.pattern === "aim"){
        spawnBubble(b.x - 2.1, b.y + 0.2, ux*spd, uy*spd, 0.44, 0);
      }else if(b.pattern === "triple"){
        const a = Math.atan2(uy, ux);
        for(const da of [-0.18, 0, 0.18]){
          const vx = Math.cos(a+da)*spd;
          const vy = Math.sin(a+da)*spd;
          spawnBubble(b.x - 2.1, b.y + 0.2, vx, vy, 0.42, 0);
        }
      }else if(b.pattern === "wave"){
        // ì¢Œâ†’ìš° íŒŒë„ì²˜ëŸ¼ í”ë“¤ë¦¬ëŠ” 5ë°œ
        for(let i=0;i<5;i++){
          const vy = (i-2)*1.25 + Math.sin((b.t+i)*1.1)*0.6;
          spawnBubble(b.x - 2.1, b.y + 0.2 + (i-2)*0.25, -spd*(0.95+0.05*i), vy, 0.40, 0);
        }
      }else if(b.pattern === "homing"){
        // ëŠë¦¬ì§€ë§Œ ì¶”ì 
        spawnBubble(b.x - 2.1, b.y + 0.2, ux*(spd*0.75), uy*(spd*0.75), 0.50, 1);
        // ë³´ì¡°íƒ„ 1ë°œ(ë‚œì´ë„ ë†’ì„ìˆ˜ë¡)
        if(b.diff >= 5){
          spawnBubble(b.x - 2.1, b.y - 0.5, ux*(spd*0.70), uy*(spd*0.70), 0.46, 1);
        }
      }else if(b.pattern === "spray"){
        // ë„“ì€ ë¶€ì±„ê¼´ ì—°ì‚¬
        const base = Math.atan2(uy, ux);
        const count = 7 + Math.min(5, b.diff-6);
        const spread = 0.75;
        for(let i=0;i<count;i++){
          const t = (count<=1)?0:(i/(count-1));
          const da = (t-0.5)*spread;
          const s = spd*(0.85 + 0.25*Math.random());
          spawnBubble(b.x - 2.1, b.y + 0.2, Math.cos(base+da)*s, Math.sin(base+da)*s, 0.38, 0);
        }
      }
    }

    function bossTakeHit(b, hitX, hitY){
      if(b.invuln > 0) return;

      b.hp--;
      b.invuln = 0.28;
      b.hurtT = 0.18;

      setBossHUD(true, b);
      screenShake(0.12, 0.18);
      spawnParticles(hitX, hitY, 30, 1.6);
      spawnDust(hitX, hitY-0.25, 14);
      SFX.stomp();

      // ë§ìœ¼ë©´ í”Œë ˆì´ì–´ íŠ•ê¹€(ëŒ€ì‹œ ê³µê²© ëŠë‚Œ)
      player.vx = -12.0;
      player.vy = 9.0;
      player.dashT = 0;
      player.dashCd = Math.max(player.dashCd, 0.12);

      if(b.hp <= 0){
        // ë³´ìŠ¤ ê²©íŒŒ
        game.state = "bossDefeat";
        game.t = 2.3;

        // ë‹¤ìŒë¶€í„° ë” ì–´ë ¤ì›€
        game.bossDifficulty = (game.bossDifficulty|0) + 1;

        showBigMsg(true, `ê²©íŒŒ ì„±ê³µ! ë‹¤ìŒ ë³´ìŠ¤ Lv ${game.bossDifficulty}`);
        showToast("ë³´ìŠ¤ ê²©íŒŒ! ë‹¤ìŒ ë ˆë²¨ë¡œ...", 1200);

        // íƒ„ ì œê±°
        for(const bb of world.bossBullets){
          if(bb.mesh) scene.remove(bb.mesh);
        }
        world.bossBullets = [];

        screenShake(0.20, 0.22);
        spawnFirework(hitX, hitY+2.0);
        spawnFirework(hitX-1.2, hitY+2.4);
        SFX.clear();
      }
    }

    function updateBoss(dt){
      const b = world.boss;
      if(!b) return;

      b.t += dt;
      b.invuln = Math.max(0, b.invuln - dt);
      b.hurtT  = Math.max(0, b.hurtT  - dt);
      b.chargeT= Math.max(0, b.chargeT- dt);

      // ë·° í¬ê¸°
      b.x = b.baseX;
		const baseY = b.baseY;

		const amp  = 1.6 + b.diff*0.10;
		const spdY = 0.8 + b.diff*0.05;
		b.y = baseY + Math.sin(b.t * spdY) * amp;

      b.mesh.position.x = b.x;
      b.mesh.position.y = b.y;

      // í”„ë ˆì„(ì—°ì¶œ)
	  
      const mat = b.mesh.material;
      
	  /*
	  if(b.hurtT > 0){
        mat.map = BOSS_TEX.hurt;
        mat.color.setHex(0xff6b6b); // ë¶‰ì€ íƒ€ê²©
      }else if(b.chargeT > 0){
        mat.map = BOSS_TEX.charge;
        mat.color.setHex(0xffffff);
      }else{
        mat.color.setHex(0xffffff);
        const phase = (Math.floor(b.t*2.2) % 2);
        // ê³µê²© ì¤‘ì—” attack í”„ë ˆì„ì„ ì„ê¸°
        if(b.fireCd < 0.18){
          mat.map = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
        }else{
          mat.map = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
        }
      }
	  */
	  const phase = (Math.floor(b.t*2.2) % 2);
		let baseMap;

		if (b.fireCd < 0.18) {
		  baseMap = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
		} else {
		  baseMap = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
		}

		// chargeë„ ëª¸í†µ í”„ë ˆì„ ìœ ì§€(ì›í•˜ë©´ attackAë¡œ ê³ ì •)
		if (b.chargeT > 0) {
		  baseMap = BOSS_TEX.attackA;
		}

		mat.map = baseMap;

		// hurtëŠ” í”„ë ˆì„ì„ ë°”ê¾¸ì§€ ë§ê³  â€œë¶‰ì€ìƒ‰ íƒ€ê²©â€ë§Œ
		if (b.hurtT > 0) {
		  mat.color.setHex(0xff6b6b);
		} else {
		  mat.color.setHex(0xffffff);
		}

	
      mat.needsUpdate = true;

      // íŒ¨í„´ ê°±ì‹ (ë‚œì´ë„â†‘ì¼ìˆ˜ë¡ ë” ìì£¼/ë” ë‹¤ì–‘)
      b.patternCd -= dt;
      if(b.patternCd <= 0){
        b.pattern = chooseBossPattern(b.diff);
        b.patternCd = Math.max(2.0, 3.6 - b.diff*0.12) * rand(0.85, 1.2);
      }

      // ë°œì‚¬
      if(game.state === "boss"){
        b.fireCd -= dt;
        if(b.fireCd <= 0){
          fireBoss(b);
        }
      }

      // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ(ëŒ€ì‹œ ê³µê²©/í”¼ê²©)
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const bx = b.x - b.hitW*0.5;
      const by = b.y - b.hitH*0.5;

      if(aabbIntersect(px,py,player.w,player.h, bx,by,b.hitW,b.hitH)){
        if(player.dashT > 0){
          bossTakeHit(b, player.x + player.facing*0.35, player.y + 0.4);
        }else{
          hurtPlayer(b.x);
        }
      }
    }

    function updateBossBullets(dt){
      if(world.bossBullets.length === 0) return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(let i=world.bossBullets.length-1; i>=0; i--){
        const bb = world.bossBullets[i];
        bb.life -= dt;

        // ì•½ê°„ í”ë“¤ë¦¬ëŠ” ê±°í’ˆ ëŠë‚Œ
        bb.wob += dt * 2.2;
        const wobV = Math.sin(bb.wob) * 0.55;

        if(bb.homing){
          const dy = (player.y - bb.y);
          bb.vy += clamp(dy*0.8, -6, 6) * dt * (0.7 + (world.boss?.diff||1)*0.08);
        }

        bb.x += bb.vx * dt;
        bb.y += (bb.vy + wobV) * dt;

        if(bb.mesh){
          bb.mesh.position.x = bb.x;
          bb.mesh.position.y = bb.y;
          bb.mesh.rotation.z += bb.spin * dt * 0.2;
          const s = 1.0 + Math.sin(bb.wob*1.7)*0.04;
          bb.mesh.scale.set(s,s,1);
        }

        // ì¶©ëŒ
        const bx = bb.x - bb.r;
        const by = bb.y - bb.r;
        if(aabbIntersect(px,py,player.w,player.h, bx,by,bb.r*2,bb.r*2)){
          hurtPlayer(bb.x);
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
          continue;
        }

        // ìˆ˜ëª…/í™”ë©´ ë°–
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;
        const minX = camX - viewW/2 - 4;
        const maxX = camX + viewW/2 + 4;
        const minY = camY - viewH/2 - 4;
        const maxY = camY + viewH/2 + 4;

        if(bb.life <= 0 || bb.x < minX || bb.x > maxX || bb.y < minY || bb.y > maxY){
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
        }
      }
    }

    
    // ----------------------------
    // ì¶”ë½(í™”ë©´ ì•„ë˜) => íŒ¡! => ë¦¬ìŠ¤íƒ€íŠ¸
    // ----------------------------
    function startRespawn(reason=""){
      const wasBoss = (game.state === "boss" || game.state === "bossIntro");
      if(game.state !== "play" && !wasBoss) return;
      game.respawnBoss = wasBoss;
      game.state = "respawn";
      game.t = RESPAWN_DELAY;

      // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§í•˜ë©´ ë¬´ì¡°ê±´ HP 5ë¡œ íšŒë³µ
      game.forceFullHP = true;

      // ê³¼í•œ í­ë°œ ëŒ€ì‹  "ì•„ì‰¬ìš´" ì—°ì¶œ + ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ëª¨ì…˜
      spawnDeathPoof(player.x, player.y);
      SFX.death();
      screenShake(0.08, 0.12);

      // í”Œë ˆì´ì–´ ìˆ¨ê¸°ê³  ì‚¬ë§ ìŠ¤í”„ë¼ì´íŠ¸ í‘œì‹œ
      playerSprite.visible = false;
      beginDeathAnim(player.x, player.y + 0.08, player.facing);

      showToast(reason || "ì‚¬ë§...", 900);
    }

    function checkFallDeath(){
      if(game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro") return;

      const viewBottom = camY + (camera.bottom / camera.zoom);

      // í™”ë©´ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ ë¦¬ìŠ¤íƒ€íŠ¸
      if(player.y + player.h*0.5 < viewBottom - 0.8){
        startRespawn("ì¶”ë½! íŒ¡!");
        return;
      }

      // ì•ˆì „ì¥ì¹˜(ì›”ë“œ ë°”ë‹¥ ì•„ë˜)
      if(player.y < world.killY){
        startRespawn("ì¶”ë½! íŒ¡!");
        return;
      }
    }

// ----------------------------
    // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
    // ----------------------------
    function updateParticles(dt){
      for(const p of world.particles){
        p.life -= dt;
        if(p.life <= 0){
          scene.remove(p.mesh);
          p.dead = true;
          continue;
        }

        if(p.kind==="firework"){
          // í­ì£½: ë“œë˜ê·¸ + ì¤‘ë ¥
          p.vx *= p.drag;
          p.vy *= p.drag;
          p.vy += (GRAVITY_DOWN*0.20)*dt;
        }else if(p.kind==="petal" || p.kind==="petalRain"){
          p.vy += (GRAVITY_DOWN*0.18)*dt;
          const sway = Math.sin((performance.now()*0.001) * (p.sway||8) + p.x*1.3) * 0.55;
          p.vx += sway * dt;
        }else if(p.kind==="popFlash"){
          // í”Œë˜ì‹œ: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="spawnRing"){
          // ë“±ì¥ ë§: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="spawnRingSmall"){
          // ì‚¬ë§ ì”ê´‘ ë§: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="popSpark"){
          // íŒ¡! ìŠ¤íŒŒí¬: ì§§ê²Œ íŠ•ê¸°ê³  ì‚¬ë¼ì§
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += (GRAVITY_DOWN*0.15)*dt;
        }else{
          p.vy += (GRAVITY_DOWN*0.35)*dt;
        }

        p.x += p.vx*dt;
        p.y += p.vy*dt;

        p.mesh.position.set(p.x, p.y, p.mesh.position.z);
        if(p.spin) p.mesh.rotation.z += p.spin*dt;
        // í˜ì´ë“œ/ìŠ¤ì¼€ì¼
        if(p.kind==="popFlash"){
          const k = 1 - clamp(p.life/0.22, 0, 1);
          p.mesh.scale.setScalar(2.1 + k*6.0);
        }else if(p.kind==="spawnRing"){
          const k = 1 - clamp(p.life/0.34, 0, 1);
          p.mesh.scale.setScalar(0.85 + k*2.4);
        }else if(p.kind==="spawnRingSmall"){
          const k = 1 - clamp(p.life/0.26, 0, 1);
          p.mesh.scale.setScalar(0.55 + k*1.6);
        }

        let fadeBase = 0.55;
        if(p.kind==="petal" || p.kind==="petalRain") fadeBase = 2.2;
        else if(p.kind==="firework") fadeBase = 1.6;
        else if(p.kind==="popFlash") fadeBase = 0.22;
        else if(p.kind==="spawnRing") fadeBase = 0.34;
        else if(p.kind==="spawnRingSmall") fadeBase = 0.26;
        else if(p.kind==="popSpark") fadeBase = 0.45;
        p.mesh.material.opacity = clamp(p.life/fadeBase, 0, 1);
      }
      world.particles = world.particles.filter(p=>!p.dead);
    }

    function updateAfterimages(dt){
      for(const a of world.afterimages){
        a.life -= dt;
        if(a.life <= 0){
          scene.remove(a.sp);
          a.dead = true;
          continue;
        }
        a.sp.material.opacity = clamp(a.life / 0.22, 0, 1) * 0.35;
      }
      world.afterimages = world.afterimages.filter(a=>!a.dead);
    }

    // ----------------------------
    // ì¹´ë©”ë¼/ë°°ê²½
    // ----------------------------
    let camX=0, camY=0;
    let perfT=0;
    let camZoom=1.0;

    function updateCamera(dt){
      const lookAhead = clamp(player.vx*0.08, -1.2, 1.2);
      const targetX = player.x + lookAhead + (player.facing*0.25);
      let targetY = player.y + 1.1;
      const minCamY = (world.groundTop ?? -0.6) + 1.1;
      if(targetY < minCamY) targetY = minCamY;

      camX = lerp(camX, targetX, 1 - Math.exp(-7.5*dt));
      camY = lerp(camY, targetY, 1 - Math.exp(-7.0*dt));

      if(shakeT > 0){
        shakeT = Math.max(0, shakeT - dt);
        const s = (shakeT>0) ? shakeP : 0;
        camX += rand(-1,1)*s;
        camY += rand(-1,1)*s;
        shakeP *= 0.92;
      }else{
        shakeP = 0;
      }

      camera.position.set(camX, camY, 10);

      const speed = Math.abs(player.vx) + Math.abs(player.vy)*0.15;
      const dashBoost = (player.dashT > 0) ? 0.12 : 0;
      const targetZoom = clamp(1.02 - speed*0.008 - dashBoost, 0.84, 1.08);
      camZoom = lerp(camZoom, targetZoom, 1 - Math.exp(-6.5*dt));
      camera.zoom = camZoom;
      camera.updateProjectionMatrix();

      bgTex.offset.x = camX * 0.02;
      bgTex.offset.y = camY * 0.01;

      waterTex.offset.x = camX * 0.04;
      waterTex.offset.y = Math.sin(perfT*0.8)*0.02;
    }

    // ----------------------------
    // ë ˆë²¨ ì‹œì‘/ë¦¬ì…‹
    // ----------------------------
    function resetPlayer(){
      player.vx = 0; player.vy = 0;
      player.facing = 1;

      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;
      player.jumpHold = 0;

      player.dashT = 0;
      player.dashCd = 0;
      player.dashTrailT = 0;
      player.dashCharges = DASH_CHARGES_MAX;

      player.invuln = 0;
      player.hurtT = 0;

      player.isDucking = false;
      player.isClimbing = false;
      player.ladderLock = 0;

      player.slideT = 0;
      player.slideCd = 0;

      player.wallDir = 0;
      player.wallGrace = 0;

      player.landSquashT = 0;
      player.idleStill = 0;
      player.state = "idle";
      player.animT = 0;
      player.duckStepT = 0;

      player.h = STAND_H;

      playerSprite.material.opacity = 1.0;
      setPlayerTex(TEX.idle);
    }

    function startLevel(level, hardReset=false, seedOverride=null, fromDeath=false){
      showBigMsg(false);
      setBossHUD(false);
      game.level = level;
      game.state = "play";
      game.t = 0;
      game.flowerRainT = 0;
      game.fireworkT = 0;

      // ì •ì±…: HP
      if(hardReset || !policy.keepHP || game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "â¤â¤â¤â¤â¤";
        game.forceFullHP = false;
      }else{
        // ìœ ì§€ ì‹œ í˜„ì¬ hp ê·¸ëŒ€ë¡œ
        $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));
      }

      // ì •ì±…: ì½”ì¸
      if(hardReset || !policy.keepCoins){
        world.totalCoinsRun = 0;
      }


      // ë ˆë²¨ ì‹œë“œ:
      //  - ë ˆë²¨ í´ë¦¬ì–´(ë ˆë²¨ ì¦ê°€) ì‹œ: ë‚˜ë…¸ì´ˆ ê¸°ë°˜ìœ¼ë¡œ í° ëœë¤ ë³€í™”
      //  - ì¶”ë½/ë¦¬ìŠ¤íƒ€íŠ¸(fromDeath) ì‹œ: ë™ì¼ ì‹œë“œë¡œ ë™ì¼ ë§µ ì¬ìƒì„±
      if(seedOverride != null){
        game.levelSeed = (seedOverride >>> 0) || 1;
        seedRng(game.levelSeed);
      }else{
        game.levelSeed = seedFromNano((level * 0x9e3779b9) >>> 0);
      }

      // ì¶”ë½ ë¦¬ìŠ¤íƒ€íŠ¸ ì‹œ ì½”ì¸ íŒŒë° ë°©ì§€: ë ˆë²¨ ì‹œì‘ ì‹œì ìœ¼ë¡œ ë˜ëŒë¦¼
      if(!fromDeath){
        world.totalCoinsRunAtLevelStart = world.totalCoinsRun;
      }else{
        world.totalCoinsRun = world.totalCoinsRunAtLevelStart;
      }

      buildRandomLevel(level);

      // ì‹œì‘ ìœ„ì¹˜(ì¢Œì¸¡)
      player.x = -15.5;
      player.y = 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // "ë¿…" ë“±ì¥ ì´í™íŠ¸ + ëª¨ì…˜
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;
      showToast(fromDeath ? "ë¦¬ìŠ¤íƒ€íŠ¸!" : `ë ˆë²¨ ${level} ì‹œì‘!`, fromDeath ? 650 : 900);
    }

    // ----------------------------
    // ë£¨í”„(ê³ ì • íƒ€ì„ìŠ¤í…)
    // ----------------------------
    const fixed = 1/120;
    let acc = 0;
    let last = performance.now()/1000;

    function step(dt){
      if(toastT > 0){
        toastT -= dt;
        if(toastT <= 0) $toast.style.opacity = "0";
      }

      if(game.state === "celebrate"){
        game.t -= dt;

        // ì—°ì¶œ ì¤‘ ê½ƒë¹„ + í­ì£½ ì§€ì†
        game.flowerRainT -= dt;
        game.fireworkT -= dt;

        // í˜„ì¬ ë·° í¬ê¸° ì¶”ì •
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;

        if(game.flowerRainT <= 0){
          game.flowerRainT = 0.08;
          spawnFlowerRain(camX, camY, viewW, viewH, 10);
        }
        if(game.fireworkT <= 0){
          game.fireworkT = 0.35;
          spawnFirework(camX + rand(-viewW*0.35, viewW*0.35), camY + rand(0.6, viewH*0.45));
        }

        // ì—°ì¶œ ë™ì•ˆ ìºë¦­í„° ì‚´ì§ ê°ì†
        player.vx *= 0.93;
        player.vy *= 0.93;

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "next";
          game.t = 0.75;
        }
      }else if(game.state === "bossIntro"){
        game.t -= dt;

        // ì¸íŠ¸ë¡œ ì¤‘ì—ë„ ì´ë™/ì í”„/ë²½ì¹˜ê¸° ê°€ëŠ¥(ë°œì‚¬ë§Œ ì ê¹ ëŒ€ê¸°)
        updatePlayer(dt);
        updateBoss(dt);

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "boss";
          showToast("START! (ëŒ€ì‹œë¡œ ê³ ë˜ ëª¸í†µì— ë°•ì¹˜ê¸°)", 900);
        }
      }else if(game.state === "boss"){
        updatePlayer(dt);
        updateBoss(dt);
        updateBossBullets(dt);
      }else if(game.state === "bossDefeat"){
        game.t -= dt;

        // ê²©íŒŒ ì—°ì¶œ(í­ì£½ ì¡°ê¸ˆ ë”)
        game.fireworkT -= dt;
        if(game.fireworkT <= 0){
          game.fireworkT = 0.22;
          spawnFirework(camX + rand(-2.2, 2.2), camY + rand(1.0, 4.4));
        }

        // ë³´ìŠ¤ ì„œì„œíˆ ì‚¬ë¼ì§
        if(world.boss?.mesh){
          const a = clamp(game.t/2.3, 0, 1);
          world.boss.mesh.material.opacity = a;
          world.boss.mesh.material.needsUpdate = true;
        }

        // ìºë¦­í„° ê°ì†
        player.vx *= 0.95;
        player.vy *= 0.95;

        if(game.t <= 0){
          showBigMsg(false);
          setBossHUD(false);
          // ë‹¤ìŒ ë ˆë²¨ ì§„í–‰
          startLevel(game.pendingNextLevel, false);
          return;
        }
      }else if(game.state === "next"){
        game.t -= dt;
        if(game.t <= 0){
          startLevel(game.level + 1, false);
        }
      }else if(game.state === "respawn"){
        game.t -= dt;

        // ì—°ì¶œ ë™ì•ˆ ìºë¦­í„° ê°ì†(ì…€ë ˆìŠ¤íŠ¸ ëŠë‚Œ)
        player.vx *= 0.88;
        player.vy *= 0.88;

        if(game.t <= 0){
          // ì‚¬ë§ ìŠ¤í”„ë¼ì´íŠ¸ ì •ë¦¬(í˜¹ì‹œ ë‚¨ì•„ìˆìœ¼ë©´)
          endDeathAnim();

          if(game.respawnBoss){
            const diff = Math.max(1, (game.bossDifficulty|0));
            game.respawnBoss = false;
            game.state = "bossIntro";
            game.t = 0.9;
            buildBossArena(diff);
            $stageText.textContent = `BOSS Lv ${diff}`;
            showBigMsg(true, `BOSS ì¬ë„ì „! ê±°ëŒ€í•œ ê³ ë˜ (Lv ${diff})`);
            showToast("ë‹¤ì‹œ ë„ì „!", 900);
            return;
          }

          startLevel(game.level, false, game.levelSeed, true);
          return;
        }
      }else{
        updatePlayer(dt);
        updateSprings();
        updateEnemies(dt);
        updateCoins(dt);
        updateGoal();
      }

      updateParticles(dt);
      updateAfterimages(dt);
      updateDeathAnim(dt);

      input.jumpPressed = false;
      input.jumpReleased = false;
      input.dashPressed = false;

      updateCamera(dt);

      if(game.state === "play" || game.state === "boss" || game.state === "bossIntro") checkFallDeath();
      updateDebugOverlay();
    }

    function animate(){
      const now = performance.now()/1000;
      let dt = now - last;
      last = now;

      dt = clamp(dt, 0, 0.05);
      acc += dt;
      perfT += dt;

      while(acc >= fixed){
        step(fixed);
        acc -= fixed;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // ì‹œì‘
    syncPolicyUI(); // ì´ˆê¸° ë°˜ì˜
    startLevel(1, true);
    animate();
  </script>
</body>
</html>
