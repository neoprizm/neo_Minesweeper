<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Celeste ëŠë‚Œ í”Œë«í¬ë¨¸ (í¼ì¦ êµ¬ê°„/ì •ì±… í† ê¸€/ê½ƒë¹„+í­ì£½)</title>
  <style>
    :root{
      --bg:#bfe4ff;
      --ink:#1d1d1f;
      --shadow: rgba(0,0,0,.18);
      --hud: rgba(255,255,255,.78);
      --hud2: rgba(255,255,255,.55);
    }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; touch-action:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif; }
    #wrap{ position:fixed; inset:0; }
    canvas{ width:100%; height:100%; display:block; }

    #hud{
      position:fixed; inset:0;
      pointer-events:none;
      color:var(--ink);
      text-shadow: 0 2px 0 rgba(0,0,0,.08);
    }
    #hud .row{
      position:absolute; left:0; right:0;
      display:flex; justify-content:space-between; align-items:center;
      padding: 14px 16px;
      gap: 12px;
    }
    #hud .left, #hud .right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill{
      background: var(--hud);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 999px;
      padding: 8px 12px;
      display:inline-flex; align-items:center; gap:8px;
      backdrop-filter: blur(8px);
    }
    .small{ font-size:12px; opacity:.85; }
    .kbd{
      display:inline-block;
      min-width: 18px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 2px 0 rgba(0,0,0,.08);
      font-weight: 700;
      font-size: 12px;
      line-height: 1.4;
      margin: 0 2px;
    }
    .clickable{
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
    }
    .onTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(35, 199, 99, .18);
      border: 1px solid rgba(35, 199, 99, .25);
    }
    .offTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255, 99, 99, .18);
      border: 1px solid rgba(255, 99, 99, .25);
    }

    #subtitle{
      position:absolute;
      left: 16px;
      right: 16px;
      bottom: 16px;
      background: var(--hud2);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      font-size: 12px;
      line-height: 1.55;
      opacity: 1;
      transform: translateY(0);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
    }
    #subtitle.subHidden{
      opacity:0;
      transform: translateY(10px);
    }
    #infoPill{
      display:none;
      width: 36px; height: 36px;
      padding: 0;
      justify-content:center;
      font-size: 16px;
    }
    #toast{
      position:absolute;
      left:50%; top: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      color:white;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 18px;
      opacity:0;
      transition: opacity .12s ease;
      white-space:nowrap;
      pointer-events:none;
    }

    #bigMsg{
      position:fixed;
      left:50%; top:38%;
      transform: translate(-50%,-50%);
      padding: 18px 22px;
      border-radius: 18px;
      background: rgba(253, 47, 143, .71); //rgba(253, 47, 143, 0.71)
      color: #fff;
      font-weight: 700;
      font-size: 30px;
      letter-spacing: .5px;
      box-shadow: 0 18px 60px rgba(0,0,0,.25);
      opacity: 0;
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
      text-align:center;
      white-space:nowrap;
    }
    #bigMsg.on{
      opacity: 1;
      transform: translate(-50%,-50%) scale(1.02);
    }

    #touch{ position:fixed; inset:0; pointer-events:none; display:none; }
    #touch .btn{
      pointer-events:auto;
      width: 64px; height: 64px;
      border-radius: 18px;
      background: rgba(255,255,255,.70);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      backdrop-filter: blur(8px);
    }
    #touch .cluster{ position:absolute; bottom: 16px; display:flex; gap: 10px; }
    #touch .leftCluster{ left: 16px; }
    #touch .rightCluster{ right: 16px; }
    #touch .col{ display:flex; flex-direction:column; gap:10px; }
  
    /* íƒ€ì´í‹€/ë¡œë”© ì˜¤ë²„ë ˆì´ */
    #loader{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      z-index:9999;
      color:#fff;
      overflow:hidden;
    }
    #loader .bg{
      position:absolute; inset:-40px;
      background:url("title_image.png") center/cover no-repeat;
      filter: blur(18px) brightness(0.88) saturate(1.05);
      transform: scale(1.10);
    }
    #loader .shade{
      position:absolute; inset:0;
      background: radial-gradient(circle at 50% 35%, rgba(0,0,0,.25), rgba(0,0,0,.72));
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    #loader .panel{
      position:relative;
      width:min(760px, 92vw);
      padding:18px 18px 16px;
      border-radius:24px;
      background:rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 20px 70px rgba(0,0,0,.46);
      text-align:center;
    }
    #loader .titleArt{
      display:block;
      width:min(680px, 86vw);
      max-height:52vh;
      object-fit:contain;
      margin: 0 auto 14px;
      border-radius:22px;
      box-shadow: 0 16px 55px rgba(0,0,0,.50);
      background: rgba(255,255,255,.05);
    }
    #loader .bar{
      height:12px;
      border-radius:999px;
      background:rgba(255,255,255,.20);
      overflow:hidden;
    }
    #barFill{
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg, rgba(0,255,200,.95), rgba(120,220,255,.95), rgba(180,120,255,.95));
      transition: width .12s ease;
    }
    #loader .small{
      font-size: 12px;
      opacity: .92;
      text-align:center;
      margin-top: 10px;
      color: rgba(255,255,255,.92);
    }
    #loader .actions{
      display:flex;
      justify-content:center;
      margin-top: 12px;
    }
    #btnStart{
      pointer-events:auto;
      font-weight: 900;
      font-size: 18px;
      padding: 12px 20px;
      border-radius: 999px;
      border: 0;
      color: #0c1020;
      background: rgba(255,255,255,.93);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      cursor: pointer;
      transition: transform .12s ease, opacity .12s ease;
    }
    #btnStart:active{ transform: scale(0.98); }
    #btnStart:disabled{
      opacity: 0.45;
      cursor: not-allowed;
      filter: grayscale(0.55);
      box-shadow: none;
    }



    /* ëª¨ë°”ì¼ ê°€ë³€ UI */
    @media (max-width: 768px){
      #hud .row{
        padding: calc(10px + env(safe-area-inset-top)) 12px 10px;
        gap: 10px;
      }
      .pill{ padding: 7px 10px; }
      #touch .cluster{ bottom: calc(14px + env(safe-area-inset-bottom)); }
      #touch .leftCluster{ left: calc(14px + env(safe-area-inset-left)); }
      #touch .rightCluster{ right: calc(14px + env(safe-area-inset-right)); }
      #touch .btn{
        width: clamp(52px, 11vw, 82px);
        height: clamp(52px, 11vw, 82px);
        border-radius: clamp(14px, 3.8vw, 22px);
        font-size: clamp(18px, 4.8vw, 30px);
      }
      /* ëª¨ë°”ì¼ì—ì„œëŠ” ë„ì›€ë§ì´ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ì„ ê°€ë¦¬ì§€ ì•Šë„ë¡ ìœ„ë¡œ ì˜¬ë¦¼ */
      #subtitle{ bottom: calc(118px + env(safe-area-inset-bottom)); }
      #infoPill{ width: 34px; height: 34px; font-size: 16px; }
    }
    @media (orientation: landscape) and (max-height: 480px){
      #touch .cluster{ bottom: calc(10px + env(safe-area-inset-bottom)); }
      #subtitle{ bottom: calc(96px + env(safe-area-inset-bottom)); font-size: 11px; }
    }
    @media (max-width: 420px){
      #subtitle{ bottom: calc(138px + env(safe-area-inset-bottom)); }
    }


    /* =========================
       DEV MAP EDITOR (F2)
       ========================= */
    #devPanel{
      position:fixed;
      right:14px;
      top:64px;
      width:min(420px, calc(100vw - 28px));
      max-height: calc(100vh - 92px);
      overflow:auto;
      background: rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 18px 55px rgba(0,0,0,.22);
      border-radius: 16px;
      padding: 12px;
      display:none;
      z-index: 9999;
      pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    #devPanel h3{
      margin: 2px 0 10px;
      font-size: 14px;
      letter-spacing: -0.2px;
    }
    #devTabs{
      display:flex;
      gap:2px;
      flex-wrap:wrap;
      margin: 8px 0 10px;
      padding: 4px;
      border-radius: 12px;
      background: rgba(0,0,0,.04);
      border: 1px solid rgba(0,0,0,.10);
    }
    #devTabs .tab{
      border:1px solid transparent;
      background: transparent;
      border-radius: 10px;
      padding: 7px 12px;
      font-size: 12px;
      cursor:pointer;
      box-shadow: none;
      color: rgba(0,0,0,.72);
    }
    #devTabs .tab.on{
      background: #fff;
      border-color: rgba(0,0,0,.12);
      color: #1d1d1f;
      box-shadow: 0 6px 16px rgba(0,0,0,.08);
    }
    .tabPage{ display:none; }
    .tabPage.on{ display:block; }
    #devPanel .row2{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin: 8px 0;
    }
    #devPanel .btn{
      pointer-events:auto;
      user-select:none;
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.10);
    }
    #devPanel .btn.primary{
      background: rgba(45,123,255,.12);
      border-color: rgba(45,123,255,.35);
    }
    #devPanel .btn.danger{
      background: rgba(255,60,60,.10);
      border-color: rgba(255,60,60,.35);
    }
    #devPanel .btn:active{ transform: translateY(1px); }
    #devPanel .tag{
      font-size: 12px;
      background: rgba(0,0,0,.06);
      border:1px solid rgba(0,0,0,.06);
      padding: 5px 8px;
      border-radius: 999px;
    }
    #devTools{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin: 8px 0 10px;
    }
    #devTools .tool{
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor:pointer;
    }
    #devTools .tool.on{
      background: rgba(45,123,255,.16);
      border-color: rgba(45,123,255,.55);
    }
    #devMiniMap{
      width:100%;
      height: 170px;
      border-radius: 12px;
      background: rgba(0,0,0,.04);
      border:1px solid rgba(0,0,0,.08);
      display:block;
      cursor: grab;
    }
    #devMiniMap:active{ cursor: grabbing; }
    #devProps{
      border:1px dashed rgba(0,0,0,.15);
      border-radius: 12px;
      padding: 10px;
      margin-top: 8px;
      background: rgba(255,255,255,.65);
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 10px;
    }
    #devProps .propRow{
      display:grid;
      grid-template-columns: 76px 1fr;
      align-items:center;
      gap:10px;
      margin: 0;
    }
    #devProps .tag{
      grid-column: 1 / -1;
      margin-bottom: 4px;
    }
    #devProps label{
      font-size: 12px;
      opacity: .78;
      text-align: right;
      padding-right: 4px;
    }
    #devProps input{
      flex:1;
      border-radius: 10px;
      border:1px solid rgba(0,0,0,.12);
      padding: 7px 10px;
      font-size: 12px;
      background: rgba(255,255,255,.95);
      width: 100%;
    }
    #devMapList{
      max-height: 140px;
      overflow:auto;
      border:1px solid rgba(0,0,0,.10);
      border-radius: 12px;
      background: rgba(255,255,255,.65);
      padding: 6px;
    }
    #devMapList .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding: 7px 8px;
      border-radius: 10px;
      cursor:pointer;
      font-size: 12px;
    }
    #devMapList .item:hover{ background: rgba(0,0,0,.05); }
    #devMapList .item.on{ background: rgba(45,123,255,.14); border:1px solid rgba(45,123,255,.25); }
    #devToast2{
      position:fixed;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.70);
      color: #fff;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 12px;
      pointer-events:none;
      opacity: 0;
      transition: opacity .18s ease;
      z-index: 10000;
      white-space: nowrap;
    }

</style>
</head>

<body>
  <div id="wrap"></div>

  <!-- íƒ€ì´í‹€/ë¡œë”© ì˜¤ë²„ë ˆì´: ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„ "Dash & Run" ë²„íŠ¼ìœ¼ë¡œ ì‹œì‘ -->
  <div id="loader" aria-label="ë¡œë”©">
    <div class="bg" aria-hidden="true"></div>
    <div class="shade" aria-hidden="true"></div>
    <div class="panel">
      <img class="titleArt" src="title_image.png" alt="Tiny Hero: Dash & Run" />
      <div class="bar"><div id="barFill"></div></div>
      <div id="loadText" class="small">ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...</div>
      <div class="actions">
        <button id="btnStart" disabled>Dash &amp; Run</button>
      </div>
    </div>
  </div>


  <div id="hud">
    <div class="row">
      <div class="left">
        <div class="pill">
          <span style="font-weight:900">ğŸª™</span>
          <span id="coinText" style="font-weight:900">0</span>
        </div>
        <div class="pill small" id="stageText">ë ˆë²¨ 1</div>

        <div class="pill small clickable" id="policyPill" title="í´ë¦­í•´ì„œ í† ê¸€ (ë‹¨ì¶•í‚¤: H/C)" style="display:none">
          <span style="font-weight:900">ì •ì±…</span>
          <span>HP</span><span id="hpPolicyTag" class="onTag">ìœ ì§€</span>
          <span>ì½”ì¸</span><span id="coinPolicyTag" class="onTag">ìœ ì§€</span>
        </div>

        <div class="pill small">
          <span style="font-weight:900">ëŒ€ì‹œ</span>
          <span id="dashText">1/1</span>
        </div>
        <div class="pill small" id="bossHpWrap" style="display:none">
          <span style="font-weight:900">BOSS</span>
          <span id="bossHpText" style="font-weight:900">â– â– â– â– â– </span>
          <span id="bossLvText" class="small" style="opacity:.75">Lv1</span>
        </div>
        <div class="pill small clickable" id="soundPill" title="ì‚¬ìš´ë“œ í† ê¸€: í´ë¦­=ì „ì²´ ON/OFF, M=ë®¤ì§, N=SFX, +/-=ë³¼ë¥¨">
          <span id="soundIcon" style="font-weight:900">ğŸ”Š</span>
          <span id="soundLabel" style="font-weight:900">ON</span>
          <span id="soundVolText" class="small" style="opacity:.75">85%</span>
        </div>
      </div>

      <div class="right">
        <div class="pill clickable" id="infoPill" title="ì¡°ì‘/ì„¤ëª… ë³´ê¸°">â„¹ï¸</div>
        <div class="pill" id="heartWrap" aria-label="ìƒëª…">
          <span id="hearts" style="color:red">â¤â¤â¤â¤â¤â¤</span>
        </div>
      </div>
    </div>

    <div id="toast">ì¤€ë¹„!</div>

    <div id="subtitle">
      ë³´ìŠ¤ì „ <span class="kbd">Z</span> / ë§µë§Œë“¤ê¸° <span class="kbd">F2</span> / ì´ë™ <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">â†</span><span class="kbd">â†’</span> Â·
      ì í”„ <span class="kbd">Space</span> Â·
      ìˆ™ì´ê¸° <span class="kbd">S</span>/<span class="kbd">â†“</span> (ì¶©ëŒ ë°•ìŠ¤â†“) Â·
      ëŒ€ì‹œ <span class="kbd">X</span> (ëŒ€ì²´: <span class="kbd">K</span>, 8ë°©í–¥, ê³µì¤‘ 1íšŒ) Â·
      ìŠ¬ë¼ì´ë“œ <span class="kbd">â†“</span>+<span class="kbd">X</span> Â·
      ë²½ìŠ¬ë¼ì´ë“œ(ë²½ì— ë¶™ìœ¼ë©´) â†’ <span class="kbd">Space</span> ë²½ì í”„ Â·
      ì‚¬ë‹¤ë¦¬ <span class="kbd">W</span><span class="kbd">S</span> / <span class="kbd">â†‘</span><span class="kbd">â†“</span> Â·
      ì •ì±… í† ê¸€ <span class="kbd">H</span>(HP) <span class="kbd">C</span>(ì½”ì¸) Â· ì¬ì‹œì‘ <span class="kbd">R</span> Â· ì‚¬ìš´ë“œ <span class="kbd">M</span>(ë®¤ì§) <span class="kbd">N</span>(SFX) <span class="kbd">+</span>/<span class="kbd">-</span>(ë³¼ë¥¨)
    </div>
  </div>

  <div id="bigMsg">Congratuation !!</div>

  <div id="touch">
    <div class="cluster leftCluster">
      <div class="btn" id="tLeft">â—€</div>
      <div class="btn" id="tRight">â–¶</div>
    </div>

    <div class="cluster rightCluster">
      <div class="col">
        <div class="btn" id="tUp">â–²</div>
        <div class="btn" id="tDown">â–¼</div>
      </div>
      <div class="col">
        <div class="btn" id="tJump">â¤´</div>
        <div class="btn" id="tDash">âŸ¶</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // ----------------------------
    // ê²Œì„ ìƒíƒœ
    // ----------------------------
    // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§ ë¦¬ìŠ¤í° ë”œë ˆì´: 1.5ì´ˆ
    const RESPAWN_DELAY = 3.5;
    // ì‹œì‘/ë¦¬ìŠ¤í° ì‹œ "ë¿…" ë“±ì¥ ëª¨ì…˜
    const SPAWN_DUR = 2.82;

    const game = {
      level: 1,
      levelSeed: 1,
      difficulty: 1.0,
      bossDifficulty: 1,
      pendingNextLevel: 2,
      respawnBoss: false,
      // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§í•˜ë©´ ë¬´ì¡°ê±´ HP 5ë¡œ íšŒë³µ
      forceFullHP: false,
      state: "play",     // play | celebrate | bossIntro | boss | bossDefeat | next | respawn
      t: 0,
      // ì—°ì¶œ ìŠ¤í° íƒ€ì´ë¨¸
      flowerRainT: 0,
      fireworkT: 0,
    };
	
	
	// ----------------------------
    // ìœ í‹¸
    // ----------------------------

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const sign = (v)=> (v>0)-(v<0);

    // ì´ì§•(ë“±ì¥/ì‚¬ë§ ì—°ì¶œ)
    const easeOutCubic = (t)=>1 - Math.pow(1-t, 3);
    const easeOutBack = (t)=>{
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
    };

    // ----------------------------
    // ë‚œìˆ˜(ì‹œë“œ ê¸°ë°˜)
    //  - "ë‚˜ë…¸ì´ˆ" ì •ë°€ë„ëŠ” ë¸Œë¼ìš°ì €/í™˜ê²½ì— ë”°ë¼ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
    //  - performance.timeOrigin + performance.now()ë¥¼ ns(í™˜ì‚°)ë¡œ ë³´ê³  32bit ì‹œë“œë¥¼ ë§Œë“­ë‹ˆë‹¤.
    // ----------------------------
    let RNG_SEED = 1 >>> 0;

    function seedFromNano(extra = 0){
      const tMs = (performance.timeOrigin || 0) + performance.now(); // ms

      // ns(í™˜ì‚°) ì •ë°€ë„ëŠ” í™˜ê²½ì— ë”°ë¼ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
      // BigInt ì—†ì´ë„ ë™ì‘í•˜ë„ë¡, ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ì¼€ì¼/ì†Œìˆ˜ë¶€ë¥¼ ì„ì–´ 32bit ì‹œë“œë¥¼ ë§Œë“­ë‹ˆë‹¤.
      const a = (tMs * 1000) | 0;      // us-ish
      const b = (tMs * 1000000) | 0;   // ns-ish (í•˜ìœ„ë¹„íŠ¸ ìœ„ì£¼)
      let s = (a ^ (b << 11) ^ (b >>> 7) ^ (extra >>> 0)) >>> 0;

      // xorshift ë¯¹ì‹±
      s ^= (s << 13) >>> 0;
      s ^= (s >>> 17) >>> 0;
      s ^= (s << 5) >>> 0;
      RNG_SEED = (s >>> 0) || 1;
      return RNG_SEED;
    }


    function seedRng(seed){
      RNG_SEED = (seed >>> 0) || 1;
    }

    function rng(){
      // xorshift32
      let x = RNG_SEED >>> 0;
      x ^= (x << 13) >>> 0;
      x ^= (x >>> 17) >>> 0;
      x ^= (x << 5) >>> 0;
      RNG_SEED = x >>> 0;
      return RNG_SEED / 4294967296;
    }

    const rand = (a,b)=>a + rng()*(b-a);
    const choice = (arr)=>arr[(rng()*arr.length)|0];


    function moveTowards(current, target, maxDelta){
      const d = target - current;
      if(Math.abs(d) <= maxDelta) return target;
      return current + Math.sign(d) * maxDelta;
    }
	function aabbIntersect(ax,ay,aw,ah, bx,by,bw,bh, eps=1e-5){
	  return ax < bx + bw - eps &&
			 ax + aw > bx + eps &&
			 ay < by + bh - eps &&
			 ay + ah > by + eps;
	}


    // ----------------------------
    // HUD
    // ----------------------------
    const $coinText = document.getElementById("coinText");
    const $hearts = document.getElementById("hearts");
    const $toast = document.getElementById("toast");
    const $stageText = document.getElementById("stageText");
    const $bigMsg = document.getElementById("bigMsg");
    const $dashText = document.getElementById("dashText");
    const $bossHpWrap = document.getElementById("bossHpWrap");
    const $bossHpText = document.getElementById("bossHpText");
    const $bossLvText = document.getElementById("bossLvText");

    const $soundPill = document.getElementById("soundPill");
    const $soundIcon = document.getElementById("soundIcon");
    const $soundLabel = document.getElementById("soundLabel");
    const $soundVolText = document.getElementById("soundVolText");


    const $policyPill = document.getElementById("policyPill");
    const $hpPolicyTag = document.getElementById("hpPolicyTag");
    const $coinPolicyTag = document.getElementById("coinPolicyTag");

    let toastT = 0;
    function showToast(msg, ms=1000){
      $toast.textContent = msg;
      toastT = ms/1000;
      $toast.style.opacity = "1";
    }
    function showBigMsg(on, msg=null){
      if(msg != null) $bigMsg.textContent = msg;
      if(on) $bigMsg.classList.add("on");
      else $bigMsg.classList.remove("on");
    }

    // ----------------------------
    // ì •ì±…(ìœ ì§€/ë¦¬ì…‹)
    // ----------------------------
    const policy = {
      keepHP: true,
      keepCoins: true,
    };
    function syncPolicyUI(){
      $hpPolicyTag.className = policy.keepHP ? "onTag" : "offTag";
      $hpPolicyTag.textContent = policy.keepHP ? "ìœ ì§€" : "ë¦¬ì…‹";
      $coinPolicyTag.className = policy.keepCoins ? "onTag" : "offTag";
      $coinPolicyTag.textContent = policy.keepCoins ? "ìœ ì§€" : "ë¦¬ì…‹";
      showToast(`ì •ì±…: HP ${policy.keepHP?"ìœ ì§€":"ë¦¬ì…‹"} / ì½”ì¸ ${policy.keepCoins?"ìœ ì§€":"ë¦¬ì…‹"}`, 900);
    }
    $policyPill.addEventListener("click", ()=>{
      // í´ë¦­ì€ ë‘˜ ë‹¤ í† ê¸€
      policy.keepHP = !policy.keepHP;
      policy.keepCoins = !policy.keepCoins;
      syncPolicyUI();

    
    });

// ----------------------------
    // ì‚¬ìš´ë“œ(ë¸Œë¼ìš°ì € ì œì•½: ì²« ì…ë ¥ í›„ ì‹œì‘)
    // - BGM/SFXëŠ” WebAudioë¡œ "ì§ì ‘ í•©ì„±"(ì €ì‘ê¶Œ ì´ìŠˆ ì—†ìŒ)
    // ----------------------------
    const sound = {
      enabled: true,
      musicEnabled: true,
      sfxEnabled: true,
      masterVol: 0.85,
      musicVol: 0.45,
      sfxVol: 0.85,

      ctx: null,
      master: null,
      musicBus: null,
      sfxBus: null,
      comp: null,
      convolver: null,
      noiseBuf: null,

      started: false,
      bgmTimer: null,
      bgmNextT: 0,
      bgmStep: 0,
      bpm: 124,
      rng: null,

      last: Object.create(null),
    };

    // ë¡œì»¬ ì €ì¥(ì„ íƒ)
    (function loadSoundSettings(){
      try{
        const v = JSON.parse(localStorage.getItem("pm_sound_v1") || "null");
        if(v){
          sound.enabled = !!v.enabled;
          sound.musicEnabled = !!v.musicEnabled;
          sound.sfxEnabled = !!v.sfxEnabled;
          sound.masterVol = clamp(+v.masterVol || 0.85, 0, 1);
          sound.musicVol = clamp(+v.musicVol || 0.45, 0, 1);
          sound.sfxVol   = clamp(+v.sfxVol   || 0.85, 0, 1);
        }
      }catch(_){}
    })();

    function saveSoundSettings(){
      try{
        localStorage.setItem("pm_sound_v1", JSON.stringify({
          enabled: sound.enabled,
          musicEnabled: sound.musicEnabled,
          sfxEnabled: sound.sfxEnabled,
          masterVol: sound.masterVol,
          musicVol: sound.musicVol,
          sfxVol: sound.sfxVol,
        }));
      }catch(_){}
    }

    function syncSoundUI(){
      if(!$soundPill) return;
      const on = sound.enabled;
      const icon = on ? "ğŸ”Š" : "ğŸ”‡";
      $soundIcon.textContent = icon;
      $soundLabel.textContent = on ? "ON" : "OFF";
      const pct = Math.round(sound.masterVol*100);
      $soundVolText.textContent = pct + "%";
      $soundPill.style.opacity = on ? "1" : "0.65";
    }

    function nowNanoSeed32(){
      // "ë‚˜ë…¸ì´ˆ"ëŠ” ë¸Œë¼ìš°ì €/OSì— ë”°ë¼ ì •ë°€ë„ê°€ ì œí•œë  ìˆ˜ ìˆìŒ(í™•ì‹¤í•˜ì§€ ì•ŠìŒ).
      // ëŒ€ì‹  Date.now(ms) + performance.now(ì„œë¸Œms)ë¥¼ ì„ì–´ 32ë¹„íŠ¸ ì‹œë“œë¡œ ì‚¬ìš©.
      const epochMs = BigInt(Date.now());
      const perf = performance.now();
      const fracNs = BigInt(Math.floor((perf - Math.floor(perf)) * 1e6)); // 0~999,999ns ê·¼ì‚¬
      const ns = epochMs * 1000000n + fracNs; // epoch ê¸°ì¤€ ns(ê·¼ì‚¬)
      let x = Number(ns & 0xffffffffn) >>> 0;
      x ^= x << 13; x >>>= 0;
      x ^= x >>> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return x >>> 0;
    }

    function mulberry32(a){
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

    function makeImpulse(ctx, dur=1.2, decay=2.4){
      const rate = ctx.sampleRate;
      const len = Math.floor(rate * dur);
      const buf = ctx.createBuffer(2, len, rate);
      for(let c=0;c<2;c++){
        const data = buf.getChannelData(c);
        for(let i=0;i<len;i++){
          const t = i/len;
          const amp = Math.pow(1 - t, decay);
          data[i] = (Math.random()*2-1) * amp;
        }
      }
      return buf;
    }

    function makeNoiseBuffer(ctx){
      const len = Math.floor(ctx.sampleRate * 1.2);
      const buf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i] = Math.random()*2 - 1;
      return buf;
    }

    function applySoundGains(){
      // âœ… MP3 BGM ë³¼ë¥¨/í† ê¸€(ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì—†ì´ë„ ì ìš©)
      if(sound.bgmEl){
        const v = (sound.enabled && sound.musicEnabled) ? clamp(sound.masterVol * sound.musicVol, 0, 1) : 0;
        try{ sound.bgmEl.volume = v; }catch(_){}
        if(v <= 0.0001){
          try{ sound.bgmEl.pause(); }catch(_){}
        }else if(sound.started){
          // autoplay ì •ì±…: ì²« ì…ë ¥ ì´í›„(sound.started)ë§Œ ì¬ìƒ ì‹œë„
          sound.bgmEl.play().catch(()=>{});
        }
      }

      // SFXëŠ” WebAudio ë²„ìŠ¤ì— ì ìš©
      if(sound.ctx){
        sound.master.gain.setTargetAtTime(sound.enabled ? sound.masterVol : 0, sound.ctx.currentTime, 0.02);
        sound.musicBus.gain.setTargetAtTime((sound.enabled && sound.musicEnabled) ? sound.musicVol : 0, sound.ctx.currentTime, 0.02);
        sound.sfxBus.gain.setTargetAtTime((sound.enabled && sound.sfxEnabled) ? sound.sfxVol : 0, sound.ctx.currentTime, 0.02);
      }

      syncSoundUI();
      saveSoundSettings();
    }


    function ensureAudio(){
      if(sound.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if(!Ctx) return;

      const ctx = new Ctx();
      sound.ctx = ctx;

      sound.master = ctx.createGain();
      sound.musicBus = ctx.createGain();
      sound.sfxBus = ctx.createGain();

      sound.master.gain.value = sound.masterVol;
      sound.musicBus.gain.value = sound.musicVol;
      sound.sfxBus.gain.value = sound.sfxVol;

      // ë¦¬ë¯¸í„°/ì»´í”„ë ˆì„œë¡œ "ê²½ì¾Œ+ê³ ìŒì§ˆ" ëŠë‚Œ(í´ë¦¬í•‘ ë°©ì§€)
      sound.comp = ctx.createDynamicsCompressor();
      sound.comp.threshold.value = -18;
      sound.comp.knee.value = 18;
      sound.comp.ratio.value = 4.2;
      sound.comp.attack.value = 0.006;
      sound.comp.release.value = 0.14;

      // ë¦¬ë²„ë¸Œ(ê°€ë²¼ìš´ ê³µê°„ê°)
      sound.convolver = ctx.createConvolver();
      sound.convolver.buffer = makeImpulse(ctx, 1.15, 2.2);
      const rv = ctx.createGain();
      rv.gain.value = 0.22;

      // ë¼ìš°íŒ…
      sound.musicBus.connect(rv);
      rv.connect(sound.convolver);
      sound.convolver.connect(sound.master);

      sound.musicBus.connect(sound.master);
      sound.sfxBus.connect(sound.master);

      sound.master.connect(sound.comp);
      sound.comp.connect(ctx.destination);

      sound.noiseBuf = makeNoiseBuffer(ctx);

      // BGMìš© RNG(ë ˆë²¨ë§ˆë‹¤ seed ê°±ì‹  ê°€ëŠ¥)
      sound.rng = mulberry32(nowNanoSeed32());

      applySoundGains();
        syncSoundUI();
        saveSoundSettings();
      syncSoundUI();
    }

    function unlockAudio(){
      if(!sound.enabled) return;
      ensureAudio();
      if(!sound.ctx) return;
      if(sound.ctx.state === "suspended"){
        sound.ctx.resume().catch(()=>{});
      }
      if(!sound.started){
        startBGM();
        sound.started = true;
      }
    }

    // --- ì•…ê¸° ê¸°ë³¸ ---
    function envGain(g, t, a=0.004, d=0.08, s=0.0, r=0.06, peak=1.0){
      g.gain.cancelScheduledValues(t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(peak, t+a);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, peak*(0.25+s)), t+a+d);
      g.gain.exponentialRampToValueAtTime(0.0001, t+a+d+r);
    }

    function playOsc({t,freq=440,dur=0.12,type="triangle",gain=0.22,detune=0,slideTo=null,slideTime=0.06,filterHz=null,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const out = bus || sound.musicBus;

      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      if(slideTo){
        o.frequency.exponentialRampToValueAtTime(Math.max(20, slideTo), t + slideTime);
      }
      if(detune) o.detune.setValueAtTime(detune, t);

      let node = o;
      if(filterHz){
        const f = ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.setValueAtTime(filterHz, t);
        node.connect(f);
        node = f;
      }else{
        o.connect(g);
        node = g;
      }
      if(filterHz){
        node.connect(g);
      }
      g.connect(out);

      envGain(g, t, 0.004, dur*0.45, 0.0, dur*0.55, gain);

      o.start(t);
      o.stop(t + dur + 0.12);
    }

    function playNoise({t,dur=0.09,gain=0.22,band="high",hz=6000,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const src = ctx.createBufferSource();
      src.buffer = sound.noiseBuf;
      const f = ctx.createBiquadFilter();
      const g = ctx.createGain();

      if(band==="high"){ f.type="highpass"; f.frequency.setValueAtTime(hz, t); }
      else if(band==="band"){ f.type="bandpass"; f.frequency.setValueAtTime(hz, t); f.Q.setValueAtTime(1.2, t); }
      else { f.type="lowpass"; f.frequency.setValueAtTime(hz, t); }

      src.connect(f);
      f.connect(g);
      g.connect(bus || sound.sfxBus);

      envGain(g, t, 0.002, dur*0.25, 0.0, dur*0.65, gain);

      src.start(t);
      src.stop(t + dur + 0.05);
    }

    function limit(name, sec){
      if(!sound.ctx) return false;
      const t = sound.ctx.currentTime;
      const last = sound.last[name] || -999;
      if(t - last < sec) return true;
      sound.last[name] = t;
      return false;
    }

    // --- BGM(ë°ê³  ê²½ì¾Œí•œ ìºì£¼ì–¼) ---
    function startBGM(){
      // âœ… MP3 BGM ì¬ìƒ (WebAudio í•©ì„± BGM ì œê±°)
      if(!sound.bgmEl) return;
      if(!sound.enabled || !sound.musicEnabled) return;
      const v = clamp(sound.masterVol * sound.musicVol, 0, 1);
      try{ sound.bgmEl.volume = v; }catch(_){}
      // autoplay ì •ì±…: unlockAudio(ì²« ì…ë ¥) ì´í›„ì—ë§Œ ì •ìƒ ì¬ìƒë©ë‹ˆë‹¤.
      sound.bgmEl.play().catch(()=>{});
    }

    function stopBGM(){
      if(sound.bgmEl){
        try{ sound.bgmEl.pause(); }catch(_){}
      }
    }

    function scheduleBgmStep(t, s){
      const step = s % 64;            // 4ë§ˆë””(16*4)
      const bar = Math.floor(step/16);
      const pos = step % 16;

      // ì½”ë“œ ì§„í–‰: C - G - Am - F (ë°ê³  ìµìˆ™)
      const prog = [
        {root: 60, type:"maj"}, // C
        {root: 67, type:"maj"}, // G
        {root: 69, type:"min"}, // A
        {root: 65, type:"maj"}, // F
      ];
      const ch = prog[bar];

      // ë“œëŸ¼(ê°€ë²¼ìš´ í‚¥/ìŠ¤ë„¤ì–´/í•˜ì´í–‡)
      if(pos===0 || pos===8){
        // kick
        playOsc({ t, freq: 120, slideTo: 48, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.32, bus: sound.musicBus });
      }
      if(pos===4 || pos===12){
        // snare
        playNoise({ t, dur: 0.10, gain: 0.20, band:"band", hz: 1800, bus: sound.musicBus });
        playOsc({ t, freq: 220, dur: 0.08, type:"triangle", gain: 0.10, bus: sound.musicBus });
      }
      if(pos%2===0){
        // hat
        playNoise({ t, dur: 0.045, gain: 0.10, band:"high", hz: 6500, bus: sound.musicBus });
      }

      // ë² ì´ìŠ¤(ì¿¼í„°)
      if(pos%4===0){
        const bassMidi = (ch.root - 24); // ì €ì—­
        playOsc({ t, freq: midiToFreq(bassMidi), dur: 0.14, type:"triangle", gain: 0.20, filterHz: 700, bus: sound.musicBus });
      }

      // íŒ¨ë“œ(ë§ˆë”” ì‹œì‘)
      if(pos===0){
        const tri = (ch.type==="maj") ? [0,4,7] : [0,3,7];
        for(let i=0;i<3;i++){
          const m = ch.root + tri[i];
          playOsc({ t, freq: midiToFreq(m), dur: 0.55, type:"sawtooth", gain: 0.055, filterHz: 1400, detune: (i-1)*6, bus: sound.musicBus });
        }
      }

      // ë¦¬ë“œ(ì‹±ì½”í˜ì´ì…˜ + íœíƒ€í† ë‹‰)
      const leadSlots = [2,6,10,14];
      if(leadSlots.includes(pos)){
        const scale = [0,2,4,7,9]; // major pentatonic
        const pick = scale[Math.floor((sound.rng ? sound.rng() : Math.random()) * scale.length)];
        const base = ch.root + 12; // í•œ ì˜¥íƒ€ë¸Œ ìœ„
        const m = base + pick + (pos===14 ? 12 : 0)*( (sound.rng ? sound.rng() : Math.random())>0.85 ? 1:0);
        const f = midiToFreq(m);
        playOsc({ t, freq: f, dur: 0.13, type:"square", gain: 0.12, filterHz: 2600, detune: (sound.rng ? (sound.rng()-0.5)*8 : (Math.random()-0.5)*8), bus: sound.musicBus });
        // ì‘ì€ í•˜ëª¨ë‹ˆ(ê°€ë”)
        if((sound.rng ? sound.rng() : Math.random()) > 0.72){
          playOsc({ t, freq: midiToFreq(m-12), dur: 0.12, type:"triangle", gain: 0.06, filterHz: 2400, bus: sound.musicBus });
        }
      }
    }

    // --- SFX(ê²½ì¾Œ + ê³ ìŒì§ˆ) ---
    const SFX = {
      jump(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("jump", 0.03)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 420, slideTo: 860, slideTime: 0.06, dur: 0.10, type:"triangle", gain: 0.22, filterHz: 3200, bus: sound.sfxBus });
        playNoise({ t, dur: 0.045, gain: 0.06, band:"high", hz: 7000, bus: sound.sfxBus });
      },
      coin(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("coin", 0.02)) return;
        const t = sound.ctx.currentTime;
        const base = 880;
        playOsc({ t, freq: base, dur: 0.08, type:"sine", gain: 0.16, bus: sound.sfxBus });
        playOsc({ t: t+0.035, freq: base*1.25, dur: 0.08, type:"sine", gain: 0.14, bus: sound.sfxBus });
        playOsc({ t: t+0.070, freq: base*1.50, dur: 0.09, type:"triangle", gain: 0.10, bus: sound.sfxBus });
      },
      dash(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("dash", 0.06)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.11, gain: 0.16, band:"band", hz: 1300, bus: sound.sfxBus });
        playOsc({ t, freq: 220, slideTo: 90, slideTime: 0.10, dur: 0.12, type:"sawtooth", gain: 0.10, filterHz: 900, bus: sound.sfxBus });
      },
      spring(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spring", 0.06)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 260, slideTo: 980, slideTime: 0.08, dur: 0.14, type:"square", gain: 0.18, filterHz: 2600, bus: sound.sfxBus });
      },
      stomp(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("stomp", 0.05)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 140, slideTo: 70, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.24, bus: sound.sfxBus });
        playNoise({ t, dur: 0.06, gain: 0.10, band:"band", hz: 900, bus: sound.sfxBus });
      },
      hurt(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("hurt", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 520, slideTo: 220, slideTime: 0.11, dur: 0.16, type:"sawtooth", gain: 0.18, filterHz: 1600, bus: sound.sfxBus });
        playNoise({ t, dur: 0.10, gain: 0.14, band:"band", hz: 700, bus: sound.sfxBus });
      },
      pop(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("pop", 0.12)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 380, slideTo: 110, slideTime: 0.06, dur: 0.12, type:"triangle", gain: 0.20, bus: sound.sfxBus });
        playNoise({ t, dur: 0.09, gain: 0.12, band:"high", hz: 5200, bus: sound.sfxBus });
        // sparkle
        for(let i=0;i<3;i++){
          const dt = 0.02*i;
          playOsc({ t: t+dt, freq: 1200 + i*320, dur: 0.06, type:"sine", gain: 0.06, bus: sound.sfxBus });
        }
      },
      spawn(){
        // ë¦¬ìŠ¤í°/ì‹œì‘ "ë¿…"(ê°€ë²¼ìš´ ë°˜ì§)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spawn", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 880, slideTo: 1320, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.11, bus: sound.sfxBus });
        playOsc({ t: t+0.03, freq: 1760, dur: 0.08, type:"triangle", gain: 0.06, bus: sound.sfxBus });
      },
      death(){
        // ì‚¬ë§ "ì‚ìš© ì‚ìš© ì‚ìš©~" (ì•„ì‰¬ìš´ í†¤)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("death", 0.30)) return;
        const t = sound.ctx.currentTime;
        const seq = [780, 640, 520];
        for(let i=0;i<3;i++){
          playOsc({ t: t+i*0.11, freq: seq[i], slideTo: seq[i]*0.72, slideTime: 0.14, dur: 0.24, type:"triangle", gain: 0.16, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.05, band:"high", hz: 5200, bus: sound.sfxBus });
      },
      clear(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("clear", 0.35)) return;
        const t = sound.ctx.currentTime;
        // ì‘ì€ íŒ¬í˜ì–´(ê²½ì¾Œ)
        const notes = [880, 1108, 1318, 1760];
        for(let i=0;i<notes.length;i++){
          playOsc({ t: t+i*0.08, freq: notes[i], dur: 0.18, type:"square", gain: 0.11, filterHz: 3200, bus: sound.sfxBus });
          playOsc({ t: t+i*0.08, freq: notes[i]*0.5, dur: 0.18, type:"triangle", gain: 0.06, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.08, band:"high", hz: 7600, bus: sound.sfxBus });
      },
      firework(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("fw", 0.08)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.10, gain: 0.10, band:"high", hz: 6800, bus: sound.sfxBus });
        playOsc({ t, freq: 980, slideTo: 420, slideTime: 0.09, dur: 0.14, type:"sine", gain: 0.09, bus: sound.sfxBus });
      }
    };

    // UI/ë‹¨ì¶•í‚¤
    syncSoundUI();
    if($soundPill){
      $soundPill.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        unlockAudio();
        sound.enabled = !sound.enabled;
        applySoundGains();
        showToast(sound.enabled ? "ì‚¬ìš´ë“œ ON" : "ì‚¬ìš´ë“œ OFF", 800);
      });
    }

    // ----------------------------
    // ì…ë ¥
    // ----------------------------
    const input = {
      left:false, right:false, up:false, down:false,
      jump:false, jumpPressed:false, jumpReleased:false,
      dash:false, dashPressed:false,
      faceLock:false
    };

   const keyMap = {
      "ArrowLeft":"left","KeyA":"left",
      "ArrowRight":"right","KeyD":"right",
      "ArrowUp":"up","KeyW":"up",
      "ArrowDown":"down","KeyS":"down",
      "Space":"jump",
      // âœ… Windows 'ê³ ì •í‚¤(Sticky Keys)' íŒì—…ì„ ê·¼ë³¸ì ìœ¼ë¡œ í”¼í•˜ë ¤ë©´
      //    'Shift' ê°™ì€ ëª¨ë””íŒŒì´ì–´ í‚¤ë¥¼ ëŒ€ì‹œë¡œ ì“°ì§€ ì•ŠëŠ” ê²Œ ê°€ì¥ í™•ì‹¤í•©ë‹ˆë‹¤.
      //    ê¸°ë³¸ ëŒ€ì‹œ í‚¤: X (ëŒ€ì²´: K)
      "KeyX":"dash",
      "KeyK":"dash",
      "AltLeft":"faceLock","AltRight":"faceLock",
      "KeyR":"restart",
	  "KeyZ":"boss"
    };

    // Shift í‚¤ë¥¼ ì—°íƒ€/ê¸¸ê²Œ ëˆ„ë¥¼ ë•Œ Windows ê³ ì •í‚¤/í•„í„°í‚¤ íŒì—…ì´ ëœ° ìˆ˜ ìˆì–´ì„œ,
    // ê²Œì„ ë‚´ì—ì„œëŠ” Shiftë¥¼ 'ëŒ€ì‹œ'ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì°¨ë‹¨í•˜ê³  ì•ˆë‚´ í† ìŠ¤íŠ¸ë§Œ ë„ì›ë‹ˆë‹¤.
    let _shiftWarned = false;    
	
	
	
    addEventListener("keydown", (e)=>{
      // ë””ë²„ê·¸ í† ê¸€: ` (Backquote)
		if(e.code === "Backquote"){
		  debug.enabled = !debug.enabled;
		  showToast(debug.enabled ? "ë””ë²„ê·¸ ON (`)" : "ë””ë²„ê·¸ OFF (`)", 900);
		  // ë°”ë¡œ ë°˜ì˜
		  if(!debug.enabled){
			resetDebugPool();
			if(debug.velLine) debug.velLine.visible = false;
		  }
		  return;
		}

	  // âœ… Shift ì°¨ë‹¨(ìœˆë„ìš° ê³ ì •í‚¤/í•„í„°í‚¤ íŒì—… ë°©ì§€)
	  // ë¸Œë¼ìš°ì € ì½”ë“œë¡œ OS íŒì—… ìì²´ë¥¼ 'ì™„ì „ ì°¨ë‹¨'í•  ìˆ˜ëŠ” ì—†ì–´ì„œ(Windows ê¸°ëŠ¥),
	  // ê²Œì„ ì¡°ì‘ì—ì„œëŠ” Shiftë¥¼ ì“°ì§€ ì•Šê³  X/Kë¡œ ëŒ€ì‹œí•˜ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤.
	  if(e.code === "ShiftLeft" || e.code === "ShiftRight"){
		if(!_shiftWarned){
		  showToast("ìœˆë„ìš° ê³ ì •í‚¤ íŒì—… ë°©ì§€: ëŒ€ì‹œëŠ” X(ë˜ëŠ” K) í‚¤!", 1600);
		  _shiftWarned = true;
		}
		e.preventDefault();
		return;
	  }

      // ì‚¬ìš´ë“œ(ì²« ì…ë ¥ ì‹œ ì˜¤ë””ì˜¤ ì–¸ë½)

      if(sound.enabled) unlockAudio();

      // ì‚¬ìš´ë“œ ë‹¨ì¶•í‚¤
      if(e.code === "KeyM"){
        sound.musicEnabled = !sound.musicEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.musicEnabled ? "BGM ON" : "BGM OFF", 800);
        return;
      }
      if(e.code === "KeyN"){
        sound.sfxEnabled = !sound.sfxEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.sfxEnabled ? "SFX ON" : "SFX OFF", 800);
        return;
      }
      if(e.code === "Equal" || e.code === "NumpadAdd"){
        sound.masterVol = clamp(sound.masterVol + 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("ë³¼ë¥¨ " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }
      if(e.code === "Minus" || e.code === "NumpadSubtract"){
        sound.masterVol = clamp(sound.masterVol - 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("ë³¼ë¥¨ " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }

// ì •ì±… ë‹¨ì¶•í‚¤
      if(e.code==="KeyH"){
        policy.keepHP = !policy.keepHP;
        syncPolicyUI();
        return;
      }
      if(e.code==="KeyC"){
        policy.keepCoins = !policy.keepCoins;
        syncPolicyUI();
        return;
      }
	  
	  if(e.code==="KeyZ"){
        jumpGoal();
        return;
      }

      const k = keyMap[e.code];
      if(!k) return;

      if(k==="restart"){
        startLevel(1, true);
        showToast("ë¦¬ì…‹!", 800);
        return;
      }

      if(k==="jump"){ if(!input.jump) input.jumpPressed=true; input.jump=true; return; }
      if(k==="dash"){ if(!input.dash) input.dashPressed=true; input.dash=true; return; }

      input[k] = true;
    });

    addEventListener("keyup", (e)=>{
      const k = keyMap[e.code];
      if(!k) return;

      if(k==="jump"){ input.jump=false; input.jumpReleased=true; return; }
      if(k==="dash"){ input.dash=false; return; }

      input[k] = false;
    });

    // ëª¨ë°”ì¼ ë„ì›€ë§(Info ë²„íŠ¼)
    // - ëª¨ë°”ì¼ì—ì„œëŠ” ì„¤ëª…ì„ ê¸°ë³¸ ìˆ¨ê¹€
    // - â„¹ï¸ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ 5ì´ˆê°„ í‘œì‹œ í›„ ìë™ ìˆ¨ê¹€
    const $subtitle = document.getElementById("subtitle");
    const $infoPill = document.getElementById("infoPill");
    let infoTimer = null;

    function hideHelp(){
      if(!$subtitle) return;
      $subtitle.classList.add("subHidden");
    }
    function showHelp(){
      if(!$subtitle) return;
      $subtitle.classList.remove("subHidden");
      if(infoTimer) clearTimeout(infoTimer);
      infoTimer = setTimeout(()=>{ hideHelp(); }, 5000);
    }

    // í„°ì¹˜(ëª¨ë°”ì¼)
    const touch = ("ontouchstart" in window) || (navigator.maxTouchPoints>0);
    const $touch = document.getElementById("touch");
    if(touch){
      $touch.style.display="block";
      // ëª¨ë°”ì¼: ë„ì›€ë§ì€ â„¹ï¸ë¡œë§Œ ë…¸ì¶œ
      if($infoPill) $infoPill.style.display = "inline-flex";
      hideHelp();
      if($infoPill){
        $infoPill.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); showHelp(); });
      }

      const bind = (id, key)=>{
        const el = document.getElementById(id);
        const down = (ev)=>{ ev.preventDefault();
        if(sound.enabled) unlockAudio(); input[key]=true; if(key==="jump") input.jumpPressed=true; if(key==="dash") input.dashPressed=true; };
        const up   = (ev)=>{ ev.preventDefault(); input[key]=false; if(key==="jump") input.jumpReleased=true; };
        el.addEventListener("pointerdown", down);
        addEventListener("pointerup", up);
        el.addEventListener("pointercancel", up);
        el.addEventListener("pointerleave", up);
      };
      bind("tLeft","left");
      bind("tRight","right");
      bind("tUp","up");
      bind("tDown","down");
      bind("tJump","jump");
      bind("tDash","dash");
    }else{
      // ë°ìŠ¤í¬í†±ì—ì„œëŠ” ê¸°ë³¸ ì„¤ëª…ì„ í•­ìƒ ë³´ì—¬ì£¼ê³ , â„¹ï¸ëŠ” ìˆ¨ê¹€
      if($infoPill) $infoPill.style.display = "none";
    }

    // ----------------------------
    // Three ê¸°ë³¸ ì„¸íŒ…
    // ----------------------------

    const wrap = document.getElementById("wrap");

    // ----------------------------
    // ë¡œë”© UI (ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„ ì‹œì‘)
    // ----------------------------
    const $loader = document.getElementById("loader");
    const $barFill = document.getElementById("barFill");
    const $loadText = document.getElementById("loadText");
    const $btnStart = document.getElementById("btnStart");

    let __canStart = false;
    let __started = false;

    function showReadyToStart(){
      __canStart = true;
      if($btnStart) $btnStart.disabled = false;
      if($loadText) $loadText.textContent = "ì¤€ë¹„ ì™„ë£Œ! Dash & Run ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.";
    }

    function startFromTitle(){
      if(__started || !__canStart) return;
      __started = true;

      // ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œë§Œ ì˜¤ë””ì˜¤ ì–¸ë½(ë¸Œë¼ìš°ì € ì •ì±…)
      try{ if(typeof unlockAudio === 'function') unlockAudio(); }catch(_){ }

      hideLoader();
      syncPolicyUI(); // ì •ì±…(HP/ì½”ì¸ ìœ ì§€ ë“±) ë°˜ì˜
      startLevel(1, true);
      animate();
    }

    if($btnStart){
      $btnStart.addEventListener("click", (ev)=>{
        ev.preventDefault();
        startFromTitle();
      });
    }
    function setLoading(done, total, label){
      const pct = total > 0 ? Math.round((done/total)*100) : 0;
      if($barFill) $barFill.style.width = pct + "%";
      if($loadText) $loadText.textContent = `${label || "ë¡œë”© ì¤‘"}  (${done}/${total})`;
    }
    function hideLoader(){
      if($loader) $loader.style.display = "none";
    }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfe4ff);

    const camera = new THREE.OrthographicCamera(-10, 10, 6, -6, 0.01, 100);
    camera.position.set(0, 0, 10);
    camera.zoom = 1.0;
    camera.updateProjectionMatrix();
    scene.add(camera);
	
	// ----------------------------
	// ë””ë²„ê·¸ ì˜¤ë²„ë ˆì´(AABB/ë²¡í„°) - ` í‚¤ë¡œ í† ê¸€
	// ----------------------------
	const debug = {
	  enabled: false,
	  group: new THREE.Group(),
	  pool: [],
	  velLine: null,
	};
	debug.group.position.z = 9;
	scene.add(debug.group);

	function makeLine(color, opacity=0.95){
	  return new THREE.LineBasicMaterial({ color, transparent:true, opacity, depthTest:false });
	}

	const MAT_PLAYER  = makeLine(0x00e5ff, 0.95);
	const MAT_SOLID   = makeLine(0x00ff7f, 0.55);
	const MAT_LADDER  = makeLine(0xffcc3d, 0.85);
	const MAT_COIN    = makeLine(0xff66cc, 0.80);
	const MAT_ENEMY   = makeLine(0xff3b3b, 0.85);
	const MAT_GOAL    = makeLine(0xb46bff, 0.90);
	const MAT_VEL     = makeLine(0xffffff, 0.85);

	function allocRect(material){
	  // LineLoop(5ì : ì‚¬ê°í˜• ë‹«í˜)
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(5 * 3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));
	  const line = new THREE.Line(geo, material);
	  line.frustumCulled = false;
	  line.visible = false;
	  debug.group.add(line);
	  return { line, arr, inUse:false };
	}

	function getRect(material){
	  let r = debug.pool.find(o => !o.inUse && o.line.material === material);
	  if(!r){
		r = allocRect(material);
		debug.pool.push(r);
	  }
	  r.inUse = true;
	  r.line.visible = debug.enabled;
	  return r;
	}

	function setRect(r, x, y, w, h, z=9){
	  // x,y = bottom-left
	  const a = r.arr;
	  const x0=x, y0=y, x1=x+w, y1=y+h;
	  a[0]=x0; a[1]=y0; a[2]=z;
	  a[3]=x1; a[4]=y0; a[5]=z;
	  a[6]=x1; a[7]=y1; a[8]=z;
	  a[9]=x0; a[10]=y1; a[11]=z;
	  a[12]=x0; a[13]=y0; a[14]=z;
	  r.line.geometry.attributes.position.needsUpdate = true;
	}

	function resetDebugPool(){
	  for(const r of debug.pool){
		r.inUse = false;
		r.line.visible = false;
	  }
	}

	function ensureVelLine(){
	  if(debug.velLine) return;
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(2*3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr,3));
	  debug.velLine = new THREE.Line(geo, MAT_VEL);
	  debug.velLine.frustumCulled = false;
	  debug.velLine.visible = false;
	  debug.group.add(debug.velLine);
	}

	function setVelLine(x0,y0,x1,y1,z=9){
	  ensureVelLine();
	  const pos = debug.velLine.geometry.attributes.position.array;
	  pos[0]=x0; pos[1]=y0; pos[2]=z;
	  pos[3]=x1; pos[4]=y1; pos[5]=z;
	  debug.velLine.geometry.attributes.position.needsUpdate = true;
	  debug.velLine.visible = debug.enabled;
	}

    function resize(){
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w,h, false);

      const viewH = 12;
      const aspect = w/h;
      const viewW = viewH * aspect;
      camera.left   = -viewW/2;
      camera.right  =  viewW/2;
      camera.top    =  viewH/2;
      camera.bottom = -viewH/2;
      camera.updateProjectionMatrix();
    }
    addEventListener("resize", resize);
    resize();

    // ----------------------------
    // í…ìŠ¤ì²˜ ë¡œë”©
    // ----------------------------
    const loader = new THREE.TextureLoader();

    const required = [
      "background_color_mushrooms.png",
      "character_green_idle.png",
      "character_green_walk_a.png",
      "character_green_walk_b.png",
      "character_green_walk_a_back.png",
      "character_green_walk_b_back.png",
      "character_green_jump.png",
      "character_green_jump_back.png",
      "character_green_hit.png",
      // ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸(3í”„ë ˆì„)
      "character_green_down.png",
      "character_green_duck.png",
      "character_green_front.png",
      "character_green_climb_a.png",
      "character_green_climb_b.png",
      "hud_coin.png",
      "slime_normal_flat.png",
      "slime_normal_rest.png",
      "slime_normal_walk_a.png",
	  "slime_normal_walk_b.png",
      "boss_whale_image.png",
      "boss_dragon_image.png",
      "boss_octopus_image.png"
    ];

    // âœ… BGM: ì²¨ë¶€ MP3 ì‚¬ìš©(íŒŒì¼ëª… ë³€ê²½ ì‹œ ì—¬ê¸°ë§Œ ìˆ˜ì •)
    const BGM_URL = encodeURI("ë°˜ì§ì´ëŠ” ëª¨í—˜.mp3");

    let _loadDone = 0;
    const _loadTotal = required.length + 1; // + BGM
    setLoading(_loadDone, _loadTotal, "ì´ˆê¸° ë¦¬ì†ŒìŠ¤ ì¤€ë¹„...");

    function markLoaded(label){
      _loadDone++;
      setLoading(_loadDone, _loadTotal, label);
    }

    const loadTex = (url)=>new Promise((resolve,reject)=>{
      loader.load(url, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        markLoaded(url);
        resolve(t);
      }, undefined, (e)=>reject(e));
    });

    function loadBGM(url){
      return new Promise((resolve, reject)=>{
        const a = new Audio();
        a.preload = "auto";
        a.loop = true;
        a.src = url;

        const done = ()=>{
          cleanup();
          markLoaded("BGM");
          resolve(a);
        };
        const fail = ()=>{
          cleanup();
          reject(new Error("BGM ë¡œë”© ì‹¤íŒ¨: MP3 íŒŒì¼(ë°˜ì§ì´ëŠ” ëª¨í—˜.mp3)ì´ index.htmlê³¼ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."));
        };
        const cleanup = ()=>{
          a.removeEventListener("canplaythrough", done);
          a.removeEventListener("loadeddata", done);
          a.removeEventListener("error", fail);
        };

        // ì¼ë¶€ í™˜ê²½ì—ì„œ canplaythroughê°€ ì•ˆ ëœ¨ëŠ” ê²½ìš°ê°€ ìˆì–´ loadeddataë„ ê°™ì´ ë°›ìŠµë‹ˆë‹¤.
        a.addEventListener("canplaythrough", done, { once:true });
        a.addEventListener("loadeddata", done, { once:true });
        a.addEventListener("error", fail, { once:true });

        try{ a.load(); }catch(_){}
      });
    }

    let TEX = {};
    let BOSS_TEX = {};
    let BOSS_TEX_WHALE = null;
    let BOSS_TEX_DRAGON = null;
    let BOSS_TEX_OCTOPUS = null;
    let PLAYER_DOWN = { frames:[], fw:0, fh:0 };
    try{
      const texPs = required.map(loadTex);
      const bgmEl = await loadBGM(BGM_URL);
      const [bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale, bossDragon, bossOctopus] = await Promise.all(texPs);

      TEX = { bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale, bossDragon, bossOctopus };

      // ----------------------------
      // ë³´ìŠ¤(ê³ ë˜) ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ë¶„í• (4x4, íƒ€ì¼ 256px)
      //  - íŒŒì¼: boss_whale_image.png (index.htmlê³¼ ê°™ì€ í´ë”ì— ë‘ì„¸ìš”)
      // ----------------------------
      function sliceSheet(sheet, col, row, tile=256){
        const c = document.createElement("canvas");
        c.width = tile; c.height = tile;
        const g = c.getContext("2d");
        // row=0ì´ ì´ë¯¸ì§€ ìµœìƒë‹¨
        g.clearRect(0,0,tile,tile);
        g.drawImage(sheet.image, col*tile, row*tile, tile, tile, 0,0, tile, tile);
        const t = new THREE.CanvasTexture(c);
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        return t;
      }

      BOSS_TEX = {
        idleA:  sliceSheet(bossWhale, 0, 0),
        attackA:sliceSheet(bossWhale, 1, 0),
        attackB:sliceSheet(bossWhale, 2, 0),
        idleB:  sliceSheet(bossWhale, 3, 0),

        tailA:  sliceSheet(bossWhale, 0, 1),
        tailB:  sliceSheet(bossWhale, 1, 1),
        charge: sliceSheet(bossWhale, 2, 1),
        tailC:  sliceSheet(bossWhale, 3, 1),

        eyeA:   sliceSheet(bossWhale, 0, 2),
        smile:  sliceSheet(bossWhale, 1, 2),
        hurt:   sliceSheet(bossWhale, 2, 2),
        eyeB:   sliceSheet(bossWhale, 3, 2),
      };


// ê³ ë˜ í…ìŠ¤ì²˜ë¥¼ ë³´ê´€(ë“œë˜ê³¤/ê³ ë˜ ì „í™˜ìš©)
BOSS_TEX_WHALE = BOSS_TEX;

// ----------------------------
// ë³´ìŠ¤(ë“œë˜ê³¤) ìŠ¤í”„ë¼ì´íŠ¸ ë¶„í• (ìë™ 5í”„ë ˆì„ ê°ì§€)
//  - íŒŒì¼: boss_dragon_image.png
//  - í˜„ì¬ ì²¨ë¶€ ì´ë¯¸ì§€ëŠ” ê°€ë¡œ 2048pxë¡œ 5ë“±ë¶„ì´ ë”± ë–¨ì–´ì§€ì§€ ì•Šì•„(2048/5=409.6),
//    íˆ¬ëª… ì•ŒíŒŒë¥¼ ê¸°ë°˜ìœ¼ë¡œ í”„ë ˆì„ êµ¬ê°„ì„ ìë™ ê°ì§€í•©ë‹ˆë‹¤.
// ----------------------------
function sliceStripAuto(sheet, expected=5){
  const img = sheet.image;
  const cw = img.width, ch = img.height;

  const c0 = document.createElement("canvas");
  c0.width = cw; c0.height = ch;
  const g0 = c0.getContext("2d");
  g0.clearRect(0,0,cw,ch);
  g0.drawImage(img, 0,0);

  let boxes = [];
  try{
    const data = g0.getImageData(0,0,cw,ch).data;
    const colHas = new Uint8Array(cw);

    // alpha íˆ¬ì˜(ì—´ ë‹¨ìœ„)
    for(let x=0; x<cw; x++){
      let hit = 0;
      for(let y=0; y<ch; y++){
        const a = data[(y*cw + x)*4 + 3];
        if(a > 10){ hit = 1; break; }
      }
      colHas[x] = hit;
    }

    // ì—°ì† êµ¬ê°„(í”„ë ˆì„ í›„ë³´) ì°¾ê¸°
    let inSeg=false, s=0;
    for(let x=0; x<cw; x++){
      if(!inSeg && colHas[x]){
        inSeg=true; s=x;
      }else if(inSeg && !colHas[x]){
        const e = x-1;
        if(e-s > 10) boxes.push([s, e]);
        inSeg=false;
      }
    }
    if(inSeg){
      const e = cw-1;
      if(e-s > 10) boxes.push([s, e]);
    }

    // ì„¸ë¡œ ë°”ìš´ë”©(ê° êµ¬ê°„ë³„)
    const refined = [];
    for(const [sx, ex] of boxes){
      let top = ch-1, bot = 0;
      for(let y=0; y<ch; y++){
        for(let x=sx; x<=ex; x++){
          const a = data[(y*cw + x)*4 + 3];
          if(a > 10){
            if(y < top) top = y;
            if(y > bot) bot = y;
            break;
          }
        }
      }
      // ì—¬ë°± ì¡°ê¸ˆ
      const pad = 2;
      const x0 = Math.max(0, sx - pad);
      const x1 = Math.min(cw-1, ex + pad);
      const y0 = Math.max(0, top - pad);
      const y1 = Math.min(ch-1, bot + pad);
      if(x1-x0 > 12 && y1-y0 > 12) refined.push({x:x0, y:y0, w:(x1-x0+1), h:(y1-y0+1)});
    }

    // ì¢Œâ†’ìš° ì •ë ¬
    refined.sort((a,b)=>a.x-b.x);

    // ê¸°ëŒ€ í”„ë ˆì„ ìˆ˜ë³´ë‹¤ ë§ìœ¼ë©´, ë©´ì  í° ê²ƒ ìœ„ì£¼ë¡œ ê³ ë¥´ê³  ë‹¤ì‹œ ì¢Œâ†’ìš° ì •ë ¬
    if(refined.length > expected){
      refined.sort((a,b)=>(b.w*b.h)-(a.w*a.h));
      refined.length = expected;
      refined.sort((a,b)=>a.x-b.x);
    }

    if(refined.length === expected){
      boxes = refined;
    }else{
      boxes = [];
    }
  }catch(_){
    boxes = [];
  }

  // ê°ì§€ ì‹¤íŒ¨ ì‹œ ê· ë“± ë¶„í•  í´ë°±(ë§ˆì§€ë§‰ ì•ˆì „ì¥ì¹˜)
  if(!boxes || boxes.length !== expected){
    const fw = Math.floor(cw / expected);
    const fh = ch;
    const out = [];
    for(let i=0;i<expected;i++){
      const c = document.createElement("canvas");
      c.width = fw; c.height = fh;
      const g = c.getContext("2d");
      g.clearRect(0,0,fw,fh);
      g.drawImage(img, i*fw, 0, fw, fh, 0, 0, fw, fh);
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.needsUpdate = true;
      out.push(t);
    }
    return out;
  }

  // ê°ì§€ ì„±ê³µ: ê° bboxë¡œ ìº”ë²„ìŠ¤ í…ìŠ¤ì²˜ ìƒì„±
  const out = [];
  for(const b of boxes){
    const c = document.createElement("canvas");
    c.width = b.w; c.height = b.h;
    const g = c.getContext("2d");
    g.clearRect(0,0,b.w,b.h);
    g.drawImage(img, b.x, b.y, b.w, b.h, 0,0, b.w, b.h);
    const t = new THREE.CanvasTexture(c);
    t.colorSpace = THREE.SRGBColorSpace;
    t.needsUpdate = true;
    out.push(t);
  }
  return out;
}

   const dragonFrames = sliceStripAuto(bossDragon, 5);

	// ë“œë˜ê³¤ 5í¬ì¦ˆë¥¼ idle/attackì— ë§¤í•‘
	// (ì¶”ì¸¡) ì¢Œâ†’ìš° ìˆœì„œ: roarA, roarB, glide, cute, calm
	BOSS_TEX_DRAGON = {
	  attackA: dragonFrames[0] || dragonFrames[1] || dragonFrames[2],
	  attackB: dragonFrames[1] || dragonFrames[0] || dragonFrames[2],
	  idleA:   dragonFrames[3] || dragonFrames[2] || dragonFrames[4],
	  idleB:   dragonFrames[4] || dragonFrames[3] || dragonFrames[2],
	  charge:  dragonFrames[2] || dragonFrames[0],
	  hurt:    dragonFrames[2] || dragonFrames[1],
	};

  // ----------------------------
  // ë³´ìŠ¤(ë¬¸ì–´) ìŠ¤í”„ë¼ì´íŠ¸ ë¶„í• (5í”„ë ˆì„)
  //  - íŒŒì¼: boss_octopus_image.png
  //  - ì²¨ë¶€ ì´ë¯¸ì§€ëŠ” 5ê°œì˜ í¬ì¦ˆê°€ ê°€ë¡œë¡œ ì´ì–´ì§„ ìŠ¤íŠ¸ë¦½ì…ë‹ˆë‹¤.
  //    (ì•ˆì „í•˜ê²Œ ì•ŒíŒŒ ê¸°ë°˜ ìë™ ê°ì§€ ë¡œì§ ì¬ì‚¬ìš©)
  // ----------------------------
  const octoFrames = sliceStripAuto(bossOctopus, 5);

  // ë¬¸ì–´ 5í¬ì¦ˆë¥¼ idle/attackì— ë§¤í•‘
  // (ì¶”ì¸¡) ì¢Œâ†’ìš°: ì¡¸ë¦°/ë¯¸ì†Œ/ê¸°ì¨/ë†€ëŒ/ë¶„ë…¸
  BOSS_TEX_OCTOPUS = {
    idleA:   octoFrames[0] || octoFrames[1] || octoFrames[2],
    idleB:   octoFrames[1] || octoFrames[0] || octoFrames[2],
    attackA: octoFrames[2] || octoFrames[3] || octoFrames[4],
    attackB: octoFrames[3] || octoFrames[2] || octoFrames[4],
    charge:  octoFrames[3] || octoFrames[2],
    hurt:    octoFrames[4] || octoFrames[3],
  };

	// ê¸°ë³¸ ë³´ìŠ¤ëŠ” ê³ ë˜
	BOSS_TEX = BOSS_TEX_WHALE;
      // ----------------------------
      // í”Œë ˆì´ì–´ ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸(ê°€ë¡œ 3í”„ë ˆì„)
      //  - íŒŒì¼: character_green_down.png
      // ----------------------------
      function sliceStrip(sheet, frames=3){
        const img = sheet.image;
        const fw = Math.floor(img.width / frames);
        const fh = img.height;
        const out = [];
        for(let i=0;i<frames;i++){
          const c = document.createElement("canvas");
          c.width = fw; c.height = fh;
          const g = c.getContext("2d");
          g.clearRect(0,0,fw,fh);
          g.drawImage(img, i*fw, 0, fw, fh, 0, 0, fw, fh);
          const t = new THREE.CanvasTexture(c);
          t.colorSpace = THREE.SRGBColorSpace;
          t.needsUpdate = true;
          out.push(t);
        }
        return { frames: out, fw, fh };
      }
      PLAYER_DOWN = sliceStrip(downSheet, 3);


      // ì‚¬ìš´ë“œì— BGM MP3 ì£¼ì…
      sound.bgmEl = bgmEl;
      try{ applySoundGains(); }catch(_){}

      showReadyToStart();
    }catch(err){
      console.error(err);
      if($loadText) $loadText.textContent = "ë¡œë”© ì‹¤íŒ¨: íŒŒì¼ ëˆ„ë½/ê²½ë¡œ ë¬¸ì œ";
      showToast((err && err.message) ? err.message : "ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹¤íŒ¨", 4000);
      throw err;
    }


    // ----------------------------
    // CanvasTexture ìƒì„±ê¸°
    // ----------------------------
    function makeCanvasTexture(drawFn, w=256, h=256){
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const g = canvas.getContext("2d");
      drawFn(g, w, h);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ----------------------------
    // ë°°ê²½
    // ----------------------------
    const bgTex = TEX.bg;
    bgTex.wrapS = bgTex.wrapT = THREE.RepeatWrapping;
    bgTex.repeat.set(8, 4);

    const bgPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(260, 92),
      new THREE.MeshBasicMaterial({ map: bgTex })
    );
    bgPlane.position.set(0, 6, -5);
    scene.add(bgPlane);

    const waterTex = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle = "rgba(120,190,255,.85)";
      g.fillRect(0, h*0.30, w, h*0.70);
      g.strokeStyle = "rgba(255,255,255,.55)";
      g.lineWidth = 10; g.lineCap = "round";
      for(let i=0;i<8;i++){
        const y = h*0.32 + i*22;
        g.beginPath();
        for(let x=-40;x<=w+40;x+=40){
          g.lineTo(x, y + Math.sin((x+i*10)*0.08)*8);
        }
        g.stroke();
      }
    }, 512, 256);
    waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
    waterTex.repeat.set(10, 2);

    const water = new THREE.Mesh(
      new THREE.PlaneGeometry(280, 16),
      new THREE.MeshBasicMaterial({ map: waterTex, transparent:true, opacity:.92 })
    );
    water.position.set(0, -6.7, -2.8);
    scene.add(water);

    // ----------------------------
    // ì›”ë“œ ë°ì´í„°
    // ----------------------------
    const world = {
      platforms: [],
      coins: [],
      enemies: [],
      springs: [],
      ladders: [],
      particles: [],
      afterimages: [],
      bossBullets: [],
      boss: null,
      goal: null,

      totalCoinsLevel: 0,
      collectedCoinsLevel: 0,

      // ì½”ì¸ ìœ ì§€ ì •ì±…ìš©
      totalCoinsRun: 0,
      totalCoinsRunAtLevelStart: 0,

      // ì¹´ë©”ë¼/ì¶”ë½ íŒì •ìš©(ë ˆë²¨ ìƒì„± ì‹œ ê°±ì‹ )
      groundTop: -0.6,
      killY: -12,
    };

    // ----------------------------
    // ì›”ë“œ í…ìŠ¤ì²˜
    // ----------------------------
    const texPlatform = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const grd = g.createLinearGradient(0,0,0,h);
      grd.addColorStop(0, "#f3a66c");
      grd.addColorStop(1, "#cf6b3e");
      g.fillStyle = grd;
      g.fillRect(0,0,w,h);

      g.fillStyle = "#41c85f";
      g.fillRect(0,0,w, 64);
      g.fillStyle = "#2aa44a";
      for(let x=0;x<w;x+=22){
        g.beginPath();
        g.arc(x+10, 62, 8, 0, Math.PI*2);
        g.fill();
      }

      g.globalAlpha = .18;
      g.fillStyle = "#000";
      for(let y=90;y<h;y+=56) g.fillRect(0, y, w, 8);
      g.globalAlpha = 1;
    });

    const texCoin = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2, r=90;

      g.fillStyle="#f7d34c";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();

      const grd = g.createRadialGradient(cx-30, cy-30, 10, cx, cy, r);
      grd.addColorStop(0, "#fff2a8");
      grd.addColorStop(1, "#e0a600");
      g.fillStyle=grd;
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.fill();

      g.globalAlpha=.35;
      g.fillStyle="#b56b00";
      g.beginPath(); g.arc(cx,cy, r*0.35,0,Math.PI*2); g.fill();
      g.globalAlpha=1;

      g.lineWidth = 18;
      g.strokeStyle = "rgba(0,0,0,.30)";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.stroke();

      g.lineWidth = 10;
      g.strokeStyle = "rgba(255,255,255,.22)";
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.stroke();
    });

    const texSlimeFlat = TEX.slimeFlat;
    const texSlimeRest = TEX.slimeRest;
    const texSlimeWalkA = TEX.slimeWalkA;
	const texSlimeWalkB = TEX.slimeWalkB;
    // ê¸°ë³¸ ìŠ¬ë¼ì„ í…ìŠ¤ì³
    const texSlime = texSlimeRest;

    const texSpring = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle = "#f2b23d";
      g.fillRect(60, 180, 136, 46);

      g.strokeStyle = "#be3e2c";
      g.lineWidth = 16;
      g.lineCap="round";
      let y = 170;
      g.beginPath();
      for(let x=40; x<=216; x+=22){
        g.lineTo(x, y + Math.sin(x*0.12)*26);
      }
      g.stroke();
    });

    const texFlagOff = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);
      g.fillStyle="#ffd4aa";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(200, 70, 220, 110);
      g.quadraticCurveTo(190, 140, 136, 150);
      g.closePath(); g.fill();
    });

    const texFlagOn = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);

      g.fillStyle="#ffcc3d";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(210, 60, 228, 110);
      g.quadraticCurveTo(190, 145, 136, 155);
      g.closePath(); g.fill();

      g.fillStyle="rgba(0,0,0,.55)";
      g.fillRect(164, 78, 14, 44);
      g.beginPath(); g.arc(171, 132, 10, 0, Math.PI*2); g.fill();
    });

    const texLadder = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e18a55";
      g.fillRect(w*0.18, 0, w*0.16, h);
      g.fillRect(w*0.66, 0, w*0.16, h);

      g.fillStyle="#d47b49";
      const step=52;
      for(let yy=22; yy<h; yy+=step){
        g.fillRect(w*0.20, yy, w*0.60, 18);
      }
    }, 256, 512);
    texLadder.wrapS = texLadder.wrapT = THREE.RepeatWrapping;

    // ê½ƒì
    const texPetal = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.translate(w/2, h/2);
      g.rotate(-0.35);
      g.scale(1.1, 1.1);

      const grd = g.createRadialGradient(-20,-30, 10, 0,0, 110);
      grd.addColorStop(0, "rgba(255,255,255,.95)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;

      for(let i=0;i<4;i++){
        g.rotate(Math.PI/2);
        g.beginPath();
        g.moveTo(0, -10);
        g.bezierCurveTo(45,-55, 85,-10, 55, 50);
        g.bezierCurveTo(25, 95, -10, 75, -10, 35);
        g.closePath();
        g.fill();
      }
    }, 256, 256);

    // í­ì£½ ìŠ¤íŒŒí¬(ì›í˜•)
    const texSpark = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      const grd = g.createRadialGradient(cx,cy, 0, cx,cy, w*0.45);
      grd.addColorStop(0, "rgba(255,255,255,1)");
      grd.addColorStop(0.2, "rgba(255,255,255,.7)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath(); g.arc(cx,cy, w*0.45, 0, Math.PI*2); g.fill();
    }, 128, 128);

    // "ë¿…" ë§(ë“±ì¥/ë¦¬í°)
    const texSpawnRing = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      // ì™¸ê³½ ë§
      g.strokeStyle = "rgba(255,255,255,0.85)";
      g.lineWidth = w*0.08;
      g.beginPath();
      g.arc(cx, cy, w*0.34, 0, Math.PI*2);
      g.stroke();
      // ì”ê´‘
      const grd = g.createRadialGradient(cx,cy, w*0.08, cx,cy, w*0.48);
      grd.addColorStop(0, "rgba(255,255,255,0.35)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(cx, cy, w*0.48, 0, Math.PI*2);
      g.fill();
    }, 192, 192);

    // ----------------------------
    // ì—”í‹°í‹° ìƒì„±
    // ----------------------------
    function addPlatform(x,y,w,h){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({ map: texPlatform })
      );
      mesh.position.set(x+w/2, y+h/2, 1);
      scene.add(mesh);
      const p = { x,y,w,h, mesh, isSolid:true };
      world.platforms.push(p);
      return p;
    }

    // ë²½/ì°¨ë‹¨ìš©(ê°™ì€ í”Œë«í¼ í…ìŠ¤ì²˜ ì‚¬ìš©, ê¸¸ê²Œ ì„¸ì›€)
    function addBlockWall(x,y,w,h){
      return addPlatform(x,y,w,h);
    }

    function addCoin(x,y){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(0.7,0.7),
        new THREE.MeshBasicMaterial({ map: (TEX.hudCoin || texCoin), transparent:true })
      );
      mesh.position.set(x, y, 2.2);
      scene.add(mesh);
      const c = { x, y, r:0.35, mesh, t: rand(0,10), dead:false };
      world.coins.push(c);
      world.totalCoinsLevel++;
      return c;
    }
	
	function coinOverlapsSolid(x,y,r=0.35){
	  const cx = x - r;
	  const cy = y - r;
	  const s  = r*2;
	  for(const p of world.platforms){
		// eps=0ìœ¼ë¡œ â€œì‚´ì§ì´ë¼ë„ ê²¹ì¹˜ë©´â€ ê²¹ì¹¨ìœ¼ë¡œ ì·¨ê¸‰
		if(aabbIntersect(cx,cy,s,s, p.x,p.y,p.w,p.h, 0)) return true;
	  }
	  return false;
	}

	function safeAddCoin(x,y){
	  // 1) ê¸°ë³¸ ìœ„ì¹˜ì—ì„œ ìœ„ë¡œ ì¡°ê¸ˆì”© ì˜¬ë ¤ê°€ë©° ì†”ë¦¬ë“œ ê²¹ì¹¨ íšŒí”¼
	  let yy = y;
	  for(let i=0;i<14;i++){
		if(!coinOverlapsSolid(x, yy)) return addCoin(x, yy);
		yy += 0.18;
	  }

	  // 2) ê·¸ë˜ë„ ì•ˆ ë˜ë©´: x ì•„ë˜ì— ìˆëŠ” â€œê°€ì¥ ë†’ì€ í”Œë«í¼â€ ìœ„ë¡œ ì˜¬ë ¤ì„œ ìƒì„±
	  let bestTop = -Infinity;
	  for(const p of world.platforms){
		if(x > p.x + 0.4 && x < p.x + p.w - 0.4){
		  const top = p.y + p.h;
		  if(top > bestTop && top < yy + 10) bestTop = top;
		}
	  }
	  if(bestTop > -Infinity) return addCoin(x, bestTop + 0.8);

	  // 3) ìµœí›„ fallback
	  return addCoin(x, y + 1.0);
	}

    function addEnemyOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.95),
        new THREE.MeshBasicMaterial({ map: texSlimeRest, transparent:true })
      );
      const yCenter = top + 0.33;
      mesh.position.set(xCenter, yCenter, 2.1);
      scene.add(mesh);

      const e = {
        x: xCenter,
        y: yCenter,
        w: 1.0,
        h: 0.65,
        vx: rand(-1,1) < 0 ? -rand(1.1, 1.7) : rand(1.1, 1.7),
        mesh,
        dead:false,
        roamMin: p.x+0.7,
        roamMax: p.x+p.w-0.7,
        animT: 0,
        texState: "rest",
        deathTimer: 0
      };
      world.enemies.push(e);
      return e;
    }

    function addSpringOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.6),
        new THREE.MeshBasicMaterial({ map: texSpring, transparent:true })
      );
      const yCenter = top + 0.22;
      mesh.position.set(xCenter, yCenter, 2.05);
      scene.add(mesh);
      const s = { x: xCenter, y: yCenter, w:1.0, h:0.35, mesh };
      world.springs.push(s);
      return s;
    }


    // ----------------------------
    // ì‚¬ë‹¤ë¦¬(í´ë¼ì„ìš©)
    //  - x,y,w,h: AABB(ë°”ë‹¥ ê¸°ì¤€)
    //  - topLow/topHigh: í”Œë ˆì´ì–´ y(ì¤‘ì‹¬) í´ë¨í”„ ê¸°ì¤€ì´ ë˜ëŠ” "ë°ŸëŠ” ë†’ì´"(ëŒ€ê°œ ì•„ë˜/ìœ„ ë°œíŒì˜ top)
    // ----------------------------
    function addLadder(x, y, w, h, topLow=null, topHigh=null){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(w, h),
        new THREE.MeshBasicMaterial({ map: texLadder, transparent:true, opacity: 0.95 })
      );
      mesh.position.set(x + w/2, y + h/2, 2.02);
      mesh.frustumCulled = false;

      // í…ìŠ¤ì²˜ ë°˜ë³µ(ì„¸ë¡œ ë°©í–¥)
      try{
        mesh.material.map.repeat.set(Math.max(1, w/1.2), Math.max(1, h/1.6));
        mesh.material.map.needsUpdate = true;
      }catch(_e){}

      scene.add(mesh);

      const l = {
        x, y, w, h,
        topLow: (topLow==null ? y : topLow),
        topHigh: (topHigh==null ? (y+h) : topHigh),
        mesh
      };
      world.ladders.push(l);
      return l;
    }


    // ì‚¬ë‹¤ë¦¬: ì•„ë˜ ë¸”ë¡ top ~ ìœ„ ë¸”ë¡ top
    function addGoalWithBase(pBase){
      const baseTop = pBase.y + pBase.h;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 1.6),
        new THREE.MeshBasicMaterial({ map: texFlagOff, transparent:true })
      );
      const x = pBase.x + pBase.w - 1.2;
      const y = baseTop + 0.85;
      mesh.position.set(x, y, 2.0);
      scene.add(mesh);

      world.goal = { x, y, w:0.8, h:1.2, mesh, active:false, base: pBase };
      return world.goal;
    }

    // ----------------------------
    // íŒŒí‹°í´
    // ----------------------------
    const geoTiny = new THREE.PlaneGeometry(0.10,0.10);
    const geoDust = new THREE.PlaneGeometry(0.16,0.16);
    const geoPetal = new THREE.PlaneGeometry(0.28,0.28);
    const geoSpark = new THREE.PlaneGeometry(0.18,0.18);

    function spawnParticles(x,y,n=10, power=1){
      for(let i=0;i<n;i++){
        const mesh = new THREE.Mesh(
          geoTiny,
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.85 })
        );
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.6);
        scene.add(mesh);
        world.particles.push({
          kind:"spark",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-2.2,2.2)*power,
          vy: rand(0.8,3.4)*power,
          life: rand(0.25,0.55),
          mesh, spin: rand(-6,6)
        });
      }
    }

    function spawnDust(x,y, n=6){
      for(let i=0;i<n;i++){
        const mesh = new THREE.Mesh(
          geoDust,
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.45 })
        );
        mesh.position.set(x + rand(-0.25,0.25), y + rand(-0.05,0.15), 2.55);
        scene.add(mesh);
        world.particles.push({
          kind:"dust",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-1.8,1.8),
          vy: rand(0.6,2.2),
          life: rand(0.16,0.34),
          mesh, spin: rand(-4,4)
        });
      }
    }

    function spawnFlowerBurst(x,y, n=90){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.95,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.85);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        const spd = rand(4.0, 12.0);
        const ang = rand(-Math.PI*0.15, Math.PI*1.15);
        world.particles.push({
          kind:"petal",
          x: mesh.position.x, y: mesh.position.y,
          vx: Math.cos(ang)*spd + rand(-1.5,1.5),
          vy: Math.sin(ang)*spd + rand(2.0,8.0),
          life: rand(1.4, 2.6),
          mesh,
          spin: rand(-10, 10),
          sway: rand(6, 12)
        });
      }
    }

    // âœ… ê½ƒë¹„(ì§€ì†): í™”ë©´ ìƒë‹¨ì—ì„œ ë–¨ì–´ì§
    function spawnFlowerRain(camX, camY, viewW, viewH, n=10){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.85,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        const x = camX + rand(-viewW*0.55, viewW*0.55);
        const y = camY + viewH*0.65 + rand(0.4, 2.4);
        mesh.position.set(x, y, 2.86);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        world.particles.push({
          kind:"petalRain",
          x, y,
          vx: rand(-1.2,1.2),
          vy: rand(-2.0,-7.5), // ì•„ë˜ë¡œ ì‹œì‘
          life: rand(1.2, 2.2),
          mesh,
          spin: rand(-6, 6),
          sway: rand(4, 10)
        });
      }
    }

    // âœ… í­ì£½: Additive + ë‹¤ìƒ‰ ìŠ¤íŒŒí¬
    function spawnFirework(cx, cy){
      SFX.firework();

      const palette = [0xff3b3b,0xffcc3d,0x8bff6a,0x3ddcff,0xb46bff,0xffffff,0xff7eb6];
      const count = 70;
      for(let i=0;i<count;i++){
        const col = choice(palette);
        const mat = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: col,
          transparent:true,
          opacity: 0.95,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const mesh = new THREE.Mesh(geoSpark, mat);
        mesh.position.set(cx, cy, 2.9);
        scene.add(mesh);

        const a = rand(0, Math.PI*2);
        const sp = rand(5.5, 15.5);
        world.particles.push({
          kind:"firework",
          x: cx, y: cy,
          vx: Math.cos(a)*sp + rand(-1.0,1.0),
          vy: Math.sin(a)*sp + rand(1.0,4.0),
          life: rand(0.9, 1.6),
          mesh,
          spin: rand(-12, 12),
          drag: rand(0.90, 0.95)
        });
      }
      // ì¤‘ì•™ í”Œë˜ì‹œ
      spawnParticles(cx, cy, 18, 1.3);
      screenShake(0.10, 0.14);
    }

    // Afterimage
    function spawnAfterimage(x,y, tex, sx, sy){
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity:0.35 });
      const sp = new THREE.Sprite(mat);
      sp.position.set(x, y, 2.9);
      sp.scale.set(sx, sy, 1);
      scene.add(sp);
      world.afterimages.push({ sp, life: 0.22 });
    }

    // í™”ë©´ í”ë“¤ë¦¼
    let shakeT=0, shakeP=0;
    function screenShake(t=0.12, p=0.12){ shakeT = Math.max(shakeT, t); shakeP = Math.max(shakeP, p); }

    
    // âœ… ì¶”ë½/ì£½ìŒ íŒ¡! ì—°ì¶œ (ê°„ë‹¨ + í”„ë¡œ ëŠë‚Œ)
    function spawnPop(x, y){
      // í”Œë˜ì‹œ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // íŒŒí¸/ë¨¼ì§€
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // ì¶”ê°€ ìŠ¤íŒŒí¬
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ì—°ì¶œ(ë§ + ì‘ì€ ë°˜ì§)
    function spawnAppear_origin(x, y){
      // ë§
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false, //falsse
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.15);
      mesh.scale.set(0.85, 0.85, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRing",
        x, y,
        vx:0, vy:0,
        life: 0.8, //0.34,
        mesh,
        spin: rand(-6, 6)
      });

      // ì‘ì€ ìŠ¤íŒŒí´
      for(let i=0;i<10;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(2.8, 5.2);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.75,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        m2.scale.set(0.55, 0.55, 1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd + rand(0.8, 2.2),
          life: rand(0.20, 0.30),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }
	    // ë³€ê²½í•œ ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ì—°ì¶œ(ë§ + ì‘ì€ ë°˜ì§)
    function spawnAppear(x, y){
      // í”Œë˜ì‹œ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // íŒŒí¸/ë¨¼ì§€
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // ì¶”ê°€ ìŠ¤íŒŒí¬
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ì‚¬ë§ "ì•„ì‰¬ìš´" ì—°ì¶œ(ê³¼í•œ í­ë°œ ëŒ€ì‹  ì‘ì€ ì”ê´‘)
    function spawnDeathPoof(x, y){
      // ì‘ì€ ë§
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.70,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.12);
      mesh.scale.set(0.55, 0.55, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRingSmall",
        x, y,
        vx:0, vy:0,
        life: 0.26,
        mesh,
        spin: rand(-6, 6)
      });

      // ìµœì†Œí•œì˜ íŒŒí¸
      spawnParticles(x, y, 12, 0.85);
      spawnDust(x, y, 8);
    }

// ----------------------------
    // Celeste ëŠë‚Œ í”Œë ˆì´ì–´(í•µì‹¬: 8ë°©í–¥ 1íšŒ ì—ì–´ëŒ€ì‹œ)
    // ----------------------------
    const GRAVITY_UP     = -30.0;
    const GRAVITY_DOWN   = -40.0;
    const FAST_FALL_MULT =  1.55;
    const APEX_VY        =  1.25;
    const APEX_GRAV_MULT =  0.65;

    const MOVE_MAX       =  8.8;
    const GROUND_ACCEL   =  26.0;
    const GROUND_BRAKE   =  30.0;
    const AIR_ACCEL      =  14.0;
    const AIR_BRAKE      =  10.0;
    const TURN_BOOST     =  1.40;

    const JUMP_V         =  14.6;
    const JUMP_CUT       =  0.55;
    const JUMP_HOLD_TIME =  0.12;
    const JUMP_HOLD_GRAV =  0.45;

    const COYOTE         =  0.11;
    const JUMP_BUF       =  0.12;

    // âœ… 8ë°©í–¥ ëŒ€ì‹œ(1íšŒ) - ê³µì¤‘ 1íšŒ, ë•…/ì‚¬ë‹¤ë¦¬ ì ‘ì´‰ ì‹œ ë¦¬í•„
    const DASH_SPEED     =  18.8;
    const DASH_TIME      =  0.15;
    const DASH_COOLDOWN  =  0.10;
    const DASH_CHARGES_MAX = 1;

    const STAND_H        =  1.55;
    const DUCK_H         =  1.00;        // ìˆ™ì´ê¸° í†µê³¼ í™•ì‹¤í•˜ê²Œ
    const DUCK_SPEED_MUL =  0.60;

    const CLIMB_SPEED    =  7.0;
    const LADDER_SNAP    =  22.0;
    const LADDER_TOP_PAD =  0.10;
    const LADDER_LOCK_T  =  0.18;

    const MAX_FALL_SPEED = -28.5;

    const SLIDE_SPEED    =  12.6;
    const SLIDE_TIME     =  0.22;
    const SLIDE_CD       =  0.42;

    const WALL_SLIDE_MAXFALL = -6.0;
    const WALL_JUMP_V        =  14.2;
    const WALL_JUMP_H        =  10.5;
    const WALL_GRACE         =  0.12;

    const playerMat = new THREE.SpriteMaterial({ map: TEX.idle, transparent:true });
    const playerSprite = new THREE.Sprite(playerMat);
    scene.add(playerSprite);

    // ì‚¬ë§/ì¶”ë½ ìŠ¤í”„ë¼ì´íŠ¸(PLAYER_DOWN: 3í”„ë ˆì„)
    const deathMat = new THREE.SpriteMaterial({
      map: (PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]) ? PLAYER_DOWN.frames[0] : TEX.hit,
      transparent:true,
      opacity: 1.0
    });
    const deathSprite = new THREE.Sprite(deathMat);
    deathSprite.visible = false;
    deathSprite.frustumCulled = false;
    scene.add(deathSprite);

    const deathAnim = {
      active: false,
      t: 0,
      x: 0,
      y: 0,
      facing: 1,
      dur: RESPAWN_DELAY,
    };
	
	
	
	

    function beginDeathAnim(x, y, facing){
      deathAnim.active = true;
      deathAnim.t = 0;
      deathAnim.x = x;
      deathAnim.y = y;
      deathAnim.facing = (facing||1);
      deathAnim.dur = RESPAWN_DELAY;

      // ì²« í”„ë ˆì„ì—ì„œ ì‹œì‘
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]){
        deathSprite.material.map = PLAYER_DOWN.frames[0];
      }
      deathSprite.material.opacity = 1.0;
      deathSprite.visible = true;
      deathSprite.position.set(x, y, 3.25);
      // í”Œë ˆì´ì–´ ìŠ¤ì¼€ì¼ê³¼ ìœ ì‚¬í•˜ê²Œ(ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ë³´ì •)
      const asp = (PLAYER_DOWN.fw && PLAYER_DOWN.fh) ? (PLAYER_DOWN.fw / PLAYER_DOWN.fh) : 1;
      const baseY = 1.75;
      deathSprite.scale.set(baseY*asp * (deathAnim.facing>=0 ? 1 : -1), baseY, 1);
      deathSprite.rotation.z = 0;
    }

    function endDeathAnim(){
      deathAnim.active = false;
      deathSprite.visible = false;
    }

    function updateDeathAnim(dt){
      if(!deathAnim.active) return;
      deathAnim.t += dt;

      const t = deathAnim.t;
      // í”„ë ˆì„: 0 -> 1 -> 2 í›„ ìœ ì§€
      let fi = 0;
      if(t >= 0.12) fi = 1;
      if(t >= 0.24) fi = 2;
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[fi]){
        deathSprite.material.map = PLAYER_DOWN.frames[fi];
      }

      // ì‚´ì§ ìœ„ë¡œ "íˆ­" + ì•„ë˜ë¡œ ê°€ë¼ì•‰ê¸°
      const hop = Math.exp(-t*10) * 0.55;
      const fall = t * 0.95;
      const yy = deathAnim.y + hop - fall;
      deathSprite.position.set(deathAnim.x, yy, 3.25);

      // ì‚´ì§ ê¸°ìš¸ê¸°
      deathSprite.rotation.z = Math.sin(t*7.0) * 0.06;

      // í˜ì´ë“œ ì•„ì›ƒ
      const fadeStart = Math.min(0.55, RESPAWN_DELAY*0.55);
      if(t > fadeStart){
        const k = clamp((t - fadeStart) / Math.max(0.0001, (RESPAWN_DELAY - fadeStart)), 0, 1);
        deathSprite.material.opacity = 1 - easeOutCubic(k);
      }

      if(t >= RESPAWN_DELAY){
        endDeathAnim();
      }
    }

    const player = {
      x: 0, y: 2.5,
      vx: 0, vy: 0,
      w: 1.05, h: STAND_H,
      facing: 1,
      onGround: false,

      coyote: 0,
      jumpBuf: 0,
      jumpHold: 0,

      dashT: 0,
      dashCd: 0,
      dashTrailT: 0,
      dashCharges: DASH_CHARGES_MAX,

      invuln: 0,
      hurtT: 0,
      hp: 3,

      // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ëª¨ì…˜ íƒ€ì´ë¨¸(ì‹œê° íš¨ê³¼)
      spawnT: 0,

      isDucking: false,
      onLadder: false,
      isClimbing: false,
      ladderLock: 0,

      slideT: 0,
      slideCd: 0,

      wallDir: 0,
      wallGrace: 0,

      landSquashT: 0,

      idleStill: 0,
      state: "idle",
      animT: 0,
      duckStepT: 0,
    };

    function setPlayerTex(tex){
      if(playerSprite.material.map === tex) return;
      playerSprite.material.map = tex;
      playerSprite.material.needsUpdate = true;
    }

    function canStandHere(){
      const bottom = player.y - player.h*0.5;
      const ax = player.x - player.w*0.5;
      const ay = bottom;
      const aw = player.w;
      const ah = STAND_H;
      for(const p of world.platforms){
        if(aabbIntersect(ax, ay, aw, ah, p.x, p.y, p.w, p.h)) return false;
      }
      return true;
    }

const SKIN = 0.001;
const GROUND_PROBE = 0.06; // âœ… ë°”ë‹¥ ë¯¸ì„¸ ê²¹ì¹¨(ëœëœ ë–¨ë¦¼/ì™¼ìª½ ë ì›Œí”„) ë°©ì§€ìš©

function resolveCollisions(nextX, nextY){
  let x = nextX, y = nextY;
  let onGround = false;
  let wallDir = 0;

  const hw = player.w * 0.5;
  const hh = player.h * 0.5;

  // ---------------------------------
  // 1) Y(ìƒí•˜) í•´ê²°
  //   - vy<0(ë‚™í•˜): ì¼ë°˜ ë°”ë‹¥ ì¶©ëŒ
  //   - vy>0(ìƒìŠ¹): ì²œì¥ ì¶©ëŒ
  //   - vy==0 ì´ë©´ì„œ onGroundì˜€ë˜ ê²½ìš°: ë°”ë‹¥ ìŠ¤ëƒ…ìœ¼ë¡œ ë¯¸ì„¸ ê²¹ì¹¨ ì œê±°
  // ---------------------------------
  {
    const ax = x - hw;
    const aw = player.w;
    /*
    if(player.vy < 0){
      let best = -Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y + p.h + hh + SKIN; // ë°”ë‹¥ ìœ„ë¡œ ìŠ¤ëƒ…
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        y = best;
        player.vy = 0;
        onGround = true;
      }*/
	   if(player.vy < 0){
      // âœ… ì‚¬ë‹¤ë¦¬ í´ë¼ì„ ì¤‘(íŠ¹íˆ ë‚´ë ¤ê°ˆ ë•Œ)ì€ í”Œë«í¼ ë°”ë‹¥ ìŠ¤ëƒ…ì´ ê±¸ë¦¬ë©´ ëª» ë‚´ë ¤ê°
      if(!(player.isClimbing && player.onLadder)){
        let best = -Infinity;
        for(const p of world.platforms){
          const ay = y - hh;
          if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
            const candidate = p.y + p.h + hh + SKIN; // ë°”ë‹¥ ìœ„ë¡œ ìŠ¤ëƒ…
            if(candidate > best) best = candidate;
          }
        }
        if(best > -Infinity){
          y = best;
          player.vy = 0;
          onGround = true;
        }
      }
    
   /* }else if(player.vy > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y - hh - SKIN; // ì²œì¥ ì•„ë˜ë¡œ ìŠ¤ëƒ…
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        y = best;
        player.vy = 0;
      }*/
	 }else if(player.vy > 0){
  // âœ… ì‚¬ë‹¤ë¦¬(CLIMB)ë¡œ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì¤‘ì—ëŠ” í”Œë«í¼ ì²œì¥ ì¶©ëŒì„ ë¬´ì‹œí•´ì•¼
  //    "ì‚¬ë‹¤ë¦¬ + í”Œë«í¼ ìƒë‹¨ì´ ë§ë‹¿ëŠ”" êµ¬ì¡°ì—ì„œë„ ìœ„ë¡œ ë¹ ì ¸ë‚˜ì˜¬ ìˆ˜ ìˆìŒ
		  if(!(player.isClimbing && player.onLadder)){
			let best = Infinity;
			for(const p of world.platforms){
			  const ay = y - hh;
			  if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
				const candidate = p.y - hh - SKIN; // ì²œì¥ ì•„ë˜ë¡œ ìŠ¤ëƒ…
				if(candidate < best) best = candidate;
			  }
			}
			if(best < Infinity){
			  y = best;
			  player.vy = 0;
			}
		  }
		
		 
	  
    }else if((player.onGround || player.coyote > 0) && !player.isClimbing){
      // âœ… "ê°€ë§Œíˆ ìˆì„ ë•Œ ë–¨ë¦¼" + "ë²½/ì í”„ë²½ ë‹¿ì„ ë•Œ ì¢Œì¸¡ ëìœ¼ë¡œ ì›Œí”„"ì˜ ì›ì¸ì¸
      //    ë°”ë‹¥ì˜ 'ì•„ì£¼ ë¯¸ì„¸í•œ ê²¹ì¹¨'ì„ ë§¤ í”„ë ˆì„ ì œê±°
      const bottom = y - hh;
      let bestTop = -Infinity;

      // ë°œë ì•„ë˜ìª½ìœ¼ë¡œ ì•„ì£¼ ì–•ê²Œ í”„ë¡œë¸Œ
      const probeAy = bottom - GROUND_PROBE;
      const probeAh = player.h + GROUND_PROBE;

      for(const p of world.platforms){
        if(!aabbIntersect(ax, probeAy, aw, probeAh, p.x, p.y, p.w, p.h, 0)) continue;
        const top = p.y + p.h;

        // ë°”ë‹¥(í”Œë«í¼ top)ì´ ë°œë ê·¼ì²˜ì— ìˆì„ ë•Œë§Œ í›„ë³´ë¡œ ì¸ì •
        if(top <= bottom + GROUND_PROBE + 1e-4){
          if(top > bestTop) bestTop = top;
        }
      }

      if(bestTop > -Infinity){
        y = bestTop + hh + SKIN;
        onGround = true;
      }
    }
  }

  // ---------------------------------
  // 2) X(ì¢Œìš°) í•´ê²°
  //   - ë°”ë‹¥ì´ 'ë²½'ìœ¼ë¡œ ì˜¤ì¸ë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´
  //     Xì¶©ëŒ íŒì •ìš© AABBëŠ” ì„¸ë¡œë¡œ ì•„ì£¼ ì‚´ì§ ì¤„ì—¬ì„œ ì‚¬ìš©
  // ---------------------------------
  if(player.vx !== 0){
    const shrink = Math.min(0.03, player.h * 0.08);
    const ay = (y - hh) + shrink;
    const ah = player.h - shrink * 2;

    if(player.vx > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x - hw - SKIN;
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        x = best;
        player.vx = 0;
        wallDir = +1;
      }
    }else{
      let best = -Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x + p.w + hw + SKIN;
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        x = best;
        player.vx = 0;
        wallDir = -1;
      }
    }
  }

  return { x, y, onGround, wallDir };
}


    

    // ----------------------------
    // ì›”ë“œ ì •ë¦¬
    // ----------------------------
    function clearWorld(){
      for(const key of ["platforms","coins","enemies","springs","ladders","particles","afterimages","bossBullets"]){
        for(const o of world[key]){
          if(o.mesh) scene.remove(o.mesh);
          if(o.sp) scene.remove(o.sp);
        }
        world[key] = [];
      }
      if(world.goal?.mesh) scene.remove(world.goal.mesh);
      world.goal = null;
      if(world.boss?.mesh) scene.remove(world.boss.mesh);
      world.boss = null;

      world.totalCoinsLevel = 0;
      world.collectedCoinsLevel = 0;
      // totalCoinsRunì€ ì •ì±…ì— ë”°ë¼ ìœ ì§€/ë¦¬ì…‹ì—ì„œ ì²˜ë¦¬
    }

    // ----------------------------
    // í¼ì¦ ëª¨ë“ˆ: ì‚¬ë‹¤ë¦¬ í•„ìˆ˜
    // - ì í”„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ ë†’ì´ ì°¨ì´ë¥¼ í¬ê²Œ
    // - ë²½ì í”„ë¡œë„ ëª» ìš°íšŒí•˜ê²Œ ì¢Œìš° ì°¨ë‹¨ë²½/ì²œì¥ ì¶”ê°€
    // ----------------------------
    function buildLadderPuzzle(xStart, groundTop, diff){
      const low = addPlatform(xStart, groundTop-1.0, 6.0, 1.0);
      const lowTop = low.y + low.h;

      // ì í”„ë¡œ ëª» ë‹¿ë„ë¡ top ì°¨ì´ë¥¼ í¬ê²Œ(> ì•½ 3.8)
      const highTop = lowTop + rand(4.4, 5.2) + (diff-1)*0.3;
      const high = addPlatform(xStart + rand(2.0, 2.8), highTop-1.0, 6.0, 1.0);

      // ì‚¬ë‹¤ë¦¬ ì¤‘ì•™
      const ladderX = (Math.max(low.x+1.2, high.x+1.2) + Math.min(low.x+low.w-1.2, high.x+high.w-1.2)) / 2;
      //addLadderBetween(low, high, ladderX);

      // ì í”„/ë²½ì í”„ ìš°íšŒ ì°¨ë‹¨: ì–‘ìª½ ë²½ + ë‚®ì€ ì²œì¥
      addBlockWall(low.x - 0.6, lowTop, 0.6, (highTop - lowTop) + 3.0);
      addBlockWall(low.x + low.w, lowTop, 0.6, (highTop - lowTop) + 3.0);

      // ì²œì¥: low ìœ„ì— ì–•ê²Œ ë§Œë“¤ì–´ ì í”„ê³µê°„ ì œí•œ(ì‚¬ë‹¤ë¦¬ë¡œë§Œ â€œìœ„ìª½ í†µë¡œâ€)
      //addPlatform(low.x, lowTop + 1.35, low.w, 0.55);
	  // âœ… ì‚¬ë‹¤ë¦¬ êµ¬ë© ë‚¨ê¸°ëŠ” ì²œì¥(ì½”ì¸/ë“±ë°˜ í†µë¡œ í™•ë³´)
	/*	{
		  const gapW = 1.8;            // ì‚¬ë‹¤ë¦¬/ì½”ì¸ í†µë¡œ í­
		  const ceilY = lowTop + 2.0;  // ì½”ì¸ ë¼ì¸ë³´ë‹¤ ìœ„ë¡œ ì˜¬ë ¤ì„œ ì ˆëŒ€ ë§‰ì§€ ì•Šê²Œ
		  const ceilH = 0.55;

		  const leftEnd = (ladderX - gapW/2);
		  const rightStart = (ladderX + gapW/2);

		  const leftW = leftEnd - low.x;
		  if(leftW > 0.6) addPlatform(low.x, ceilY, leftW, ceilH);

		  const rightW = (low.x + low.w) - rightStart;
		  if(rightW > 0.6) addPlatform(rightStart, ceilY, rightW, ceilH);
		}
		{
		  const span = (highTop - lowTop);
		  const n = clamp(Math.floor(span / 0.85), 5, 10);
		  for(let i=0;i<n;i++){
			const t = (i+1) / (n+1);
			const yy = lerp(lowTop + 0.75, highTop - 0.75, t);
			safeAddCoin(ladderX, yy);
		  }
		}
*/
      // ì½”ì¸ íŒíŠ¸(ì‚¬ë‹¤ë¦¬ë¡œ ìœ ë„)
      for(let i=0;i<5;i++){
        //addCoin(ladderX, lowTop + 0.8 + i*0.75);
		safeAddCoin(ladderX, lowTop + 0.8 + i*0.75);
      }
      addCoin(high.x + high.w*0.5, highTop + 0.8);

      // ë‹¤ìŒìœ¼ë¡œ ì´ì–´ì§€ëŠ” ì¶œêµ¬ í”Œë«í¼
      const out = addPlatform(high.x + high.w + rand(2.2, 3.0), highTop-1.0, rand(4.2, 5.6), 1.0);
      if(rng() < clamp(0.18 + (diff-1)*0.08, 0.18, 0.45)){
        addEnemyOnPlatform(out, out.x + out.w*0.5);
      }
      return { endX: out.x + out.w, endTop: out.y + out.h, entry: low, exit: out };
    }

    // ----------------------------
    // í¼ì¦ ëª¨ë“ˆ: ìˆ™ì´ê¸° í•„ìˆ˜ í„°ë„
    // - ì„œìˆëŠ” ì¶©ëŒ ë†’ì´(STAND_H)ê°€ ëª» ë“¤ì–´ê°€ê²Œ
    // - ìˆ™ì´ê¸°(DUCK_H)ë§Œ í†µê³¼ ê°€ëŠ¥
    // - ìš°íšŒ í†µë¡œê°€ ì—†ë„ë¡ ë²½/ì§€í˜•ìœ¼ë¡œ ê°•ì œ
    // ----------------------------
    function buildDuckTunnelPuzzle(xStart, baseTop, diff){
      // ì…êµ¬ í”Œë«í¼
      const entry = addPlatform(xStart, baseTop-1.0, 6.0, 1.0);
      const entryTop = entry.y + entry.h;

      // í„°ë„ ë°”ë‹¥
      const floor = addPlatform(entry.x + entry.w + 1.4, baseTop-1.0, 9.0, 1.0);
      const floorTop = floor.y + floor.h;

      // clearance: STAND(1.55) ëª» ë“¤ì–´ê°€ê³  DUCK(1.00)ë§Œ ë“¤ì–´ê°€ê²Œ
      // í”Œë ˆì´ì–´ëŠ” ë°”ë‹¥ ê¸°ì¤€ìœ¼ë¡œ hê°€ ì ìš©ë˜ë¯€ë¡œ, ì‹¤ì§ˆ í†µê³¼ ë†’ì´ë¥¼ 1.10~1.18ë¡œ
      const clearance = 1.14;
      const ceilingY = floorTop + clearance;
      const ceiling = addPlatform(floor.x, ceilingY, floor.w, 0.6);

      // ì…êµ¬/ì¶œêµ¬ë¥¼ ê°•ì œí•˜ëŠ” ë²½(ìš°íšŒ ë°©ì§€)
      // ì…êµ¬ ë²½: ì²œì¥ ë†’ì´ê¹Œì§€ ë§‰ê³ , ì•„ë˜ë§Œ í†µê³¼ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ê¸°
      ////addBlockWall(floor.x - 0.55, floorTop, 0.55, clearance + 0.6);
      ////addBlockWall(floor.x + floor.w, floorTop, 0.55, clearance + 0.6);

      // ì¶œêµ¬ í”Œë«í¼(í„°ë„ ë)
      const exit = addPlatform(floor.x + floor.w + 1.6, baseTop-1.0, 6.0, 1.0);

      // ìš°íšŒ ì í”„ ì°¨ë‹¨(ìœ„ìª½ í° ì²œì¥)
      //addPlatform(floor.x - 0.6, ceilingY + 1.0, floor.w + 1.2, 0.8);

      // ì½”ì¸ ë¼ì¸(í„°ë„ ë‚´ë¶€)
      for(let i=0;i<8;i++){
        addCoin(floor.x + 1.0 + i*1.0, floorTop + 0.65);
      }

      // ë‚œì´ë„ì— ë”°ë¼ ì /ìŠ¤í”„ë§ ë°°ì¹˜
      if(rng() < clamp(0.10 + (diff-1)*0.05, 0.10, 0.25)){
        addSpringOnPlatform(exit, exit.x + exit.w*0.5);
      }else if(rng() < clamp(0.12 + (diff-1)*0.06, 0.12, 0.32)){
        addEnemyOnPlatform(exit, exit.x + exit.w*0.5);
      }

      return { endX: exit.x + exit.w, endTop: exit.y + exit.h, entry, exit };
    }


    // ----------------------------
    // ë§µíŒ©(Map Pack) ê¸°ë°˜ ë ˆë²¨ êµ¬ì„±
    // - LocalStorage(pm_map_pack_v1) ìš°ì„ 
    // - ì—†ìœ¼ë©´ EMBEDDED_MAP_PACK.maps ì‚¬ìš©
    // ----------------------------
    const MAP_PACK_LS_KEY = "pm_map_pack_v1";

    function deepClone(v){
      try{ return JSON.parse(JSON.stringify(v)); }catch(_e){ return v; }
    }
    function _num(v, d){ v = Number(v); return Number.isFinite(v) ? v : d; }
    function _str(v, d){ return (typeof v === "string" && v.trim()) ? v : d; }
    function _arr(v){ return Array.isArray(v) ? v : []; }

    function normalizeMap(m){
      const nowId = () => `map-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
      m = (m && typeof m === "object") ? m : {};
      const ground = m.ground || {};
      const out = {
        schema: 1,
        id: _str(m.id, nowId()),
        name: _str(m.name, "ìƒˆ ë§µ"),
        ground: {
          x: _num(ground.x, -80),
          y: _num(ground.y, -2.8),
          w: _num(ground.w, 160),
          h: _num(ground.h, 2.2),
        },
        spawn: {
          x: _num(m.spawn?.x, -15.5),
          y: _num(m.spawn?.y,  2.6),
        },
        platforms: _arr(m.platforms).map(p => ({
          x:_num(p.x, 0), y:_num(p.y, 0), w:Math.max(0.2,_num(p.w, 4)), h:Math.max(0.2,_num(p.h, 1))
        })),
        coins: _arr(m.coins).map(c => ({ x:_num(c.x, 0), y:_num(c.y, 1) })),
        enemies: _arr(m.enemies).map(e => ({ x:_num(e.x, 0), y:_num(e.y, 1) })),
        springs: _arr(m.springs).map(s => ({ x:_num(s.x, 0), y:_num(s.y, 1) })),
        ladders: _arr(m.ladders).map(l => ({
          x:_num(l.x, 0), y:_num(l.y, 0),
          w:Math.max(0.2,_num(l.w, 1.2)), h:Math.max(0.2,_num(l.h, 4.0)),
          topLow: _num(l.topLow, _num(l.y,0)),
          topHigh: _num(l.topHigh, _num(l.y,0) + Math.max(0.2,_num(l.h,4.0))),
        })),
        goal: {
          x: _num(m.goal?.x, 50),
          y: _num(m.goal?.y,  1.0),
        }
      };
      // ìµœì†Œ 1ê°œ ë°œíŒ(ì¤‘ì•™) ë³´ì¥(ì—ë””í„° UX)
      if(out.platforms.length === 0){
        out.platforms.push({ x:-18, y:(out.ground.y+out.ground.h) - 1.0 + 0.6, w:6.0, h:1.0 });
      }
      return out;
    }

    function normalizePack(p){
      p = (p && typeof p === "object") ? p : {};
      const maps = _arr(p.maps).map(normalizeMap);
      return { version: 1, maps };
    }

    function loadPackFromLocalStorage(){
      try{
        const s = localStorage.getItem(MAP_PACK_LS_KEY);
        if(!s) return null;
        const obj = JSON.parse(s);
        const pack = normalizePack(obj);
        if(!pack.maps.length) return null;
        return pack;
      }catch(_e){
        return null;
      }
    }

    function savePackToLocalStorage(pack){
      try{
        const norm = normalizePack(pack);
        localStorage.setItem(MAP_PACK_LS_KEY, JSON.stringify(norm));
        return true;
      }catch(_e){
        return false;
      }
    }

    // ğŸ‘‡ ì—¬ê¸° EMBEDDED_MAP_PACK.maps ë°°ì—´ì— ë§µ JSONì„ ì¶”ê°€í•˜ë©´, ê²Œì„ì— "ë‚´ì¥ ë§µ"ìœ¼ë¡œ í¬í•¨ë©ë‹ˆë‹¤.
    const EMBEDDED_MAP_PACK = normalizePack({
      version: 1,
      maps: [
        {
          id: "demo-001",
          name: "ì´ˆì› ìŠ¤íƒ€íŠ¸",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-15.5, y: 2.6 },
          platforms: [
            { x:-18, y:-1.0, w:6.0, h:1.0 },
            { x:-8,  y: 0.2, w:5.0, h:1.0 },
            { x: 2,  y: 1.3, w:5.6, h:1.0 },
            { x: 12, y: 2.4, w:6.0, h:1.0 },
            { x: 28, y: 1.2, w:6.5, h:1.0 },
            { x: 40, y:-1.0, w:7.0, h:1.0 }
          ],
          coins: [
            { x:-15.5, y: 0.9 },
            { x:-5.5,  y: 2.0 },
            { x: 4.6,  y: 3.1 },
            { x: 14.8, y: 4.1 },
            { x: 31.0, y: 3.0 },
            { x: 43.0, y: 1.0 }
          ],
          enemies: [{ x: 14.5, y: 3.0 }],
          springs: [{ x: -5.5, y: 1.1 }],
          ladders: [],
          goal: { x: 45.6, y: 0.8 }
        },
        {
          id: "demo-002",
          name: "ì‚¬ë‹¤ë¦¬ ì í”„",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-10.0, y: 2.4 },
          platforms: [
            { x:-12, y:-1.0, w:7.0, h:1.0 },
            { x:  2, y: 4.0,  w:7.0, h:1.0 },
            { x: 16, y: 2.2,  w:6.0, h:1.0 },
            { x: 30, y:-1.0,  w:8.0, h:1.0 }
          ],
          ladders: [
            { x: -8.1, y: 0.0, w: 1.2, h: 5.0, topLow: 0.0, topHigh: 5.0 }
          ],
          coins: [
            { x:-8.1, y: 2.2 },
            { x: 5.6, y: 6.2 },
            { x:18.8, y: 4.2 },
            { x:33.0, y: 1.0 }
          ],
          enemies: [{ x: 18.6, y: 3.0 }],
          springs: [{ x: 33.5, y: 0.2 }],
          goal: { x: 36.5, y: 0.8 }
        },
        {
          id: "demo-003",
          name: "ëŸ¬ì‹œ ëŸ°",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-20.0, y: 2.6 },
          platforms: [
            { x:-22, y:-1.0, w:7.0, h:1.0 },
            { x:-10, y: 0.6, w:5.0, h:1.0 },
            { x:  0, y: 2.2, w:5.0, h:1.0 },
            { x: 10, y: 3.2, w:5.0, h:1.0 },
            { x: 20, y: 2.0, w:5.0, h:1.0 },
            { x: 32, y: 0.6, w:8.0, h:1.0 },
            { x: 48, y:-1.0, w:8.0, h:1.0 }
          ],
          coins: [
            { x:-18.3, y: 1.0 }, { x:-7.2, y: 2.4 },
            { x:  2.3, y: 3.9 }, { x: 12.4, y: 4.9 },
            { x: 22.3, y: 3.8 }, { x: 35.0, y: 2.0 },
            { x: 52.0, y: 1.0 }
          ],
          enemies: [{ x: 12.3, y: 4.0 }, { x: 22.3, y: 3.0 }],
          springs: [],
          ladders: [],
          goal: { x: 55.0, y: 0.8 }
        }
      ]
    });

    let activePack = loadPackFromLocalStorage() || EMBEDDED_MAP_PACK;

    function getMapForLevel(level){
      if(!activePack || !Array.isArray(activePack.maps) || activePack.maps.length === 0) return null;
      const idx = ((level|0) - 1) % activePack.maps.length;
      const map = activePack.maps[idx];
      if(!map) return null;
      return { map, index: idx, total: activePack.maps.length };
    }

    function addGoalAt(x, y){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 1.6),
        new THREE.MeshBasicMaterial({ map: texFlagOff, transparent:true })
      );
      mesh.position.set(x, y, 2.0);
      scene.add(mesh);
      world.goal = { x, y, w:0.8, h:1.2, mesh, active:false, base:null };
      return world.goal;
    }

    function findSupportPlatformAt(x, yHint){
      let best = null;
      let bestTop = -Infinity;
      const yMax = (Number.isFinite(yHint) ? yHint : (world.groundTop + 4));
      for(const p of world.platforms){
        const top = p.y + p.h;
        const inside = (x >= p.x + 0.35) && (x <= p.x + p.w - 0.35);
        if(!inside) continue;
        // yHint ê·¼ì²˜ ì•„ë˜ìª½ì—ì„œ ê°€ì¥ ë†’ì€ top ì„ íƒ
        if(top <= yMax + 0.8 && top > bestTop){
          bestTop = top;
          best = p;
        }
      }
      // ê·¸ë˜ë„ ì—†ìœ¼ë©´ (ì§€ë©´ í¬í•¨) ê°€ì¥ ê°€ê¹Œìš´ í”Œë«í¼
      if(!best && world.platforms.length){
        for(const p of world.platforms){
          const top = p.y + p.h;
          const inside = (x >= p.x) && (x <= p.x + p.w);
          if(!inside) continue;
          if(top > bestTop){
            bestTop = top;
            best = p;
          }
        }
      }
      return best;
    }

    function buildLevelFromJson(map, level=1, mapIndex=0, mapTotal=1){
      const m = normalizeMap(map);
      clearWorld();

      world.currentMap = m;

      // ground
      const g = m.ground;
      const groundTop = g.y + g.h;
      addPlatform(g.x, g.y, g.w, g.h);
      world.groundTop = groundTop;
      world.killY = g.y - 10.5;

      // platforms
      for(const p of m.platforms){
        // groundì™€ ì™„ì „íˆ ê²¹ì¹˜ëŠ” ê²½ìš°ëŠ” ì¤‘ë³µ ë°©ì§€(ê°„ë‹¨)
        if(Math.abs(p.x-g.x)<1e-6 && Math.abs(p.y-g.y)<1e-6 && Math.abs(p.w-g.w)<1e-6 && Math.abs(p.h-g.h)<1e-6) continue;
        addPlatform(p.x, p.y, p.w, p.h);
      }

      // ladders
      for(const l of m.ladders){
        addLadder(l.x, l.y, l.w, l.h, l.topLow, l.topHigh);
      }

      // coins
      for(const c of m.coins){
        addCoin(c.x, c.y);
      }

      // enemies / springs: support platform ì°¾ì•„ì„œ ì˜¬ë ¤ë†“ê¸°
      for(const e of m.enemies){
        const p = findSupportPlatformAt(e.x, e.y);
        if(p) addEnemyOnPlatform(p, e.x);
      }
      for(const s of m.springs){
        const p = findSupportPlatformAt(s.x, s.y);
        if(p) addSpringOnPlatform(p, s.x);
      }

      // goal
      if(m.goal) addGoalAt(m.goal.x, m.goal.y);

      // UI ì´ˆê¸°í™”
      world.collectedCoinsLevel = 0;
      const title = m.name ? ` Â· ${m.name}` : "";
      $stageText.textContent = `ë ˆë²¨ ${level} Â· ë§µ ${mapIndex+1}/${mapTotal}${title}`;
      updateCoinHUD();
    }


    // ----------------------------
    // ëœë¤ ë ˆë²¨ ìƒì„±(í¼ì¦ ëª¨ë“ˆ í¬í•¨)
    // ----------------------------
    function buildRandomLevel(level){
      // âœ… ë§µíŒ© ìš°ì„ : LocalStorage(pm_map_pack_v1) -> EMBEDDED_MAP_PACK
      const info = getMapForLevel(level);
      if(info){
        const diff = 1.0 + (level-1)*0.16;
        game.difficulty = diff;
        buildLevelFromJson(info.map, level, info.index, info.total);
        return;
      }

      clearWorld();
      world.currentMap = null;

      const diff = 1.0 + (level-1)*0.16;
      game.difficulty = diff;

      const groundY = -2.8;
      const groundH = 2.2;
      const groundTop = groundY + groundH;


      world.groundTop = groundTop;
      world.killY = groundY - 10.5;

      // ì‹œì‘ ì§€ë©´
      addPlatform(-80, groundY, 160, groundH);

      // ì‹œì‘ ë°œíŒ
      let x = -18;
      let top = groundTop + 0.6;
      let p = addPlatform(x, top-1.0, 6.0, 1.0);

      // ì¼ë°˜ êµ¬ê°„ ëª‡ ê°œ
      const normalSteps = 3 + Math.min(2, level|0);
      for(let i=0;i<normalSteps;i++){
        const w = rand(3.6, 5.8);
        const gap = rand(1.4, 2.4) + (diff-1)*0.25;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 0.9) * (1.0 + (diff-1)*0.45);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 4.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.85) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.10 + (diff-1)*0.04, 0.10, 0.22)) addEnemyOnPlatform(p, p.x + p.w*0.5);
      }

      // âœ… ì‚¬ë‹¤ë¦¬ í•„ìˆ˜ í¼ì¦(í•­ìƒ 1íšŒ)
      const ladderSeg = buildLadderPuzzle(p.x + p.w + rand(2.2, 3.0), groundTop + 0.6, diff);
      x = ladderSeg.endX;
      top = ladderSeg.endTop;
      p = ladderSeg.exit;

      // ì¤‘ê°„ ì¼ë°˜ êµ¬ê°„
      const midSteps = 2 + Math.min(2, (level-1)|0);
      for(let i=0;i<midSteps;i++){
        const w = rand(3.2, 5.6);
        const gap = rand(1.5, 2.8) + (diff-1)*0.30;
        x = p.x + p.w + gap;

        const dy = rand(-0.8, 0.9) * (1.0 + (diff-1)*0.55);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.88) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.12 + (diff-1)*0.05, 0.12, 0.28)) addSpringOnPlatform(p, p.x + p.w*0.5);
      }

      // âœ… ìˆ™ì´ê¸° í•„ìˆ˜ í¼ì¦(í•­ìƒ 1íšŒ)
      const duckSeg = buildDuckTunnelPuzzle(p.x + p.w + rand(2.4, 3.2), groundTop + 0.6, diff);
      x = duckSeg.endX;
      top = duckSeg.endTop;
      p = duckSeg.exit;

      // ê³¨ ì• ë§ˆì§€ë§‰ êµ¬ê°„
      const tailSteps = 2 + Math.min(3, level|0);
      for(let i=0;i<tailSteps;i++){
        const w = rand(3.4, 6.2);
        const gap = rand(1.5, 2.8) + (diff-1)*0.35;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 1.0) * (1.0 + (diff-1)*0.60);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.8);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.9){
          addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
          if(rng() < 0.25) addCoin(p.x + rand(0.8, p.w-0.8), top + 1.3);
        }
        if(rng() < clamp(0.16 + (diff-1)*0.06, 0.16, 0.40)) addEnemyOnPlatform(p, p.x + p.w*0.55);
      }

      // âœ… ê³¨ ë² ì´ìŠ¤ í”Œë«í¼ + ê¹ƒë°œ
      const goalBase = addPlatform(p.x + p.w + 3.0, groundTop-1.0, 7.0, 1.0);
      addGoalWithBase(goalBase);

      // ê³¨ ì£¼ë³€ ì½”ì¸(ë§ˆì§€ë§‰ ìœ ë„)
      addCoin(goalBase.x + 2.0, goalBase.y + goalBase.h + 0.9);
      addCoin(goalBase.x + 4.5, goalBase.y + goalBase.h + 1.4);

      // UI ì´ˆê¸°í™”
      world.collectedCoinsLevel = 0;
      $stageText.textContent = `ë ˆë²¨ ${level}`;
      updateCoinHUD();
    }

    // ----------------------------
    // ì½”ì¸ HUD(ë ˆë²¨/ëŸ°)
    // ----------------------------
    function updateCoinHUD(){
      const levelPart = `${world.collectedCoinsLevel} / ${world.totalCoinsLevel}`;
      if(policy.keepCoins){
        $coinText.textContent = `${levelPart} | ì´ ${world.totalCoinsRun}`;
      }else{
        $coinText.textContent = levelPart;
      }
    }

    // ----------------------------
    // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
    // ----------------------------
    function updatePlayer(dt){
      const canControl = (game.state === "play" || game.state === "boss" || game.state === "bossIntro");

      player.ladderLock = Math.max(0, player.ladderLock - dt);
      player.slideCd = Math.max(0, player.slideCd - dt);
      player.landSquashT = Math.max(0, player.landSquashT - dt);
      player.hurtT = Math.max(0, player.hurtT - dt);
      player.invuln = Math.max(0, player.invuln - dt);
      player.wallGrace = Math.max(0, player.wallGrace - dt);

      player.dashCd = Math.max(0, player.dashCd - dt);
      if(player.dashT > 0) player.dashT = Math.max(0, player.dashT - dt);

      // ì‚¬ë‹¤ë¦¬ ì˜¤ë²„ë©
      /*
	  let ladder = null;
      player.onLadder = false;
      if(player.ladderLock <= 0){
        const margin = 0.18;
        const px = (player.x - player.w*0.5) - margin;
        const py = (player.y - player.h*0.5);
        const pw = player.w + margin*2;
        const ph = player.h;
        for(const l of world.ladders){
          if(aabbIntersect(px, py, pw, ph, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }*/
	  let ladder = null;
      player.onLadder = false;
      if(player.ladderLock <= 0){
        const margin = 0.18;
        const px = (player.x - player.w*0.5) - margin;
        const py = (player.y - player.h*0.5);
        const pw = player.w + margin*2;
        const ph = player.h;
        for(const l of world.ladders){
          if(aabbIntersect(px, py, pw, ph, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }

      // âœ… [ì¶”ê°€] í”Œë«í¼ ìœ„ì—ì„œ â†“ ëˆ„ë¥´ë©´, ë°œë°‘ì— ìˆëŠ” ì‚¬ë‹¤ë¦¬ë¥¼ "í”„ë¡œë¸Œ"ë¡œ ì¡ê¸°
      if(!ladder && player.ladderLock <= 0 && canControl && player.onGround && input.down && player.dashT<=0){
        const GRAB_DEPTH = 0.65;     // ë°œë°‘ìœ¼ë¡œ ì–¼ë§ˆë‚˜ ë‚´ë ¤ë‹¤ë³¼ì§€(í•„ìš”ì‹œ 0.45~0.9 íŠœë‹)
        const X_MARGIN   = 0.12;     // ì¢Œìš° íŒì • ì—¬ìœ 
        const hw = player.w*0.5;
        const hh = player.h*0.5;

        const bottom = player.y - hh;

        // ë°œë°‘ ì–•ì€ ì§ì‚¬ê°í˜• í”„ë¡œë¸Œ(ëª¸í†µì´ ì•„ë‹ˆë¼ "ë°œ ì•„ë˜"ë§Œ ê²€ì‚¬)
        const px2 = (player.x - hw) - X_MARGIN;
        const py2 = bottom - GRAB_DEPTH;
        const pw2 = player.w + X_MARGIN*2;
        const ph2 = GRAB_DEPTH + 0.02;

        for(const l of world.ladders){
          // (ì„ íƒ) ì‚¬ë‹¤ë¦¬ ìµœìƒë‹¨ì´ ë°œë°‘ ê·¼ì²˜ì¼ ë•Œë§Œ ì¡íˆê²Œ í•„í„°
          const dTop = bottom - l.topHigh;
          if(dTop < -0.10 || dTop > GRAB_DEPTH + 0.10) continue;

          if(aabbIntersect(px2, py2, pw2, ph2, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }

      // ëŒ€ì‹œ ë¦¬í•„: ë•…/ì‚¬ë‹¤ë¦¬ ì ‘ì´‰ ì‹œ
      if(player.onGround || player.onLadder){
        player.dashCharges = DASH_CHARGES_MAX;
      }
      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;

      // í´ë¼ì„ ì‹œì‘/ì¢…ë£Œ
      if(player.isClimbing){
        if(!player.onLadder || !canControl) player.isClimbing = false;
      }else{
        if(player.onLadder && canControl && (input.up || input.down) && player.dashT<=0){
          player.isClimbing = true;
          player.vx = 0; player.vy = 0;
        }
      }

      // ìˆ™ì´ê¸°(ì¶©ëŒ ë°•ìŠ¤ ê°ì†Œ)
      if(canControl && !player.isClimbing && player.onGround && player.dashT<=0){
        if(input.down || player.slideT>0){
          if(!player.isDucking){
            const bottom = player.y - player.h*0.5;
            player.isDucking = true;
            player.h = DUCK_H;
            player.y = bottom + player.h*0.5;
          }
        }else{
          if(player.isDucking && canStandHere()){
            const bottom = player.y - player.h*0.5;
            player.isDucking = false;
            player.h = STAND_H;
            player.y = bottom + player.h*0.5;
          }
        }
      }else{
        if(!player.onGround && player.isDucking && player.slideT<=0){
          const bottom = player.y - player.h*0.5;
          player.isDucking = false;
          player.h = STAND_H;
          player.y = bottom + player.h*0.5;
        }
      }

      // ì í”„ ë²„í¼/ì½”ìš”í…Œ
      if(player.onGround && !player.isClimbing) player.coyote = COYOTE;
      else player.coyote = Math.max(0, player.coyote - dt);

      if(canControl && input.jumpPressed) player.jumpBuf = JUMP_BUF;
      else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

      // ìŠ¬ë¼ì´ë“œ(â†“+ëŒ€ì‹œ í‚¤: ê¸°ë³¸ X)
      if(canControl && player.onGround && !player.isClimbing && player.dashT<=0){
        if(input.dashPressed && input.down && player.slideCd<=0 && player.slideT<=0){
          player.slideT = SLIDE_TIME;
          player.slideCd = SLIDE_CD;
          player.isDucking = true;
          player.h = DUCK_H;
          player.vx = SLIDE_SPEED * player.facing;
          spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
          screenShake(0.08, 0.10);
          showToast("ìŠ¬ë¼ì´ë“œ!", 450);
        }
      }
      if(player.slideT > 0){
        player.slideT = Math.max(0, player.slideT - dt);
        player.vx = moveTowards(player.vx, 0, 26 * dt);
        if(player.slideT===0) spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 6);
      }

      // ë°©í–¥/ì´ë™
      const dir = canControl ? ((input.left ? -1 : 0) + (input.right ? 1 : 0)) : 0;
      if(dir !== 0 && !input.faceLock) player.facing = dir;
      else if(player.facing === 0) player.facing = 1;

      const speedMul = (player.isDucking ? DUCK_SPEED_MUL : 1.0);
      const targetVx = dir * MOVE_MAX * speedMul;

      if(!player.isClimbing && player.dashT <= 0 && player.slideT<=0){
        const reversing = (dir !== 0) && (player.vx !== 0) && (Math.sign(player.vx) !== Math.sign(targetVx));
        if(player.onGround){
          const accel = (dir!==0 ? GROUND_ACCEL : GROUND_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          const before = player.vx;
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
          if(reversing && Math.abs(before) > 5.5) spawnDust(player.x - sign(before)*0.15, player.y - player.h/2 + 0.02, 4);
        }else{
          const accel = (dir!==0 ? AIR_ACCEL : AIR_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
        }
      }

      // í´ë¼ì„
      if(player.isClimbing && ladder && canControl){
        const lx = ladder.x + ladder.w*0.5;
        player.x = lerp(player.x, lx, 1 - Math.exp(-LADDER_SNAP*dt));

        const v = (input.up?1:0) + (input.down?-1:0);
        player.vy = v * CLIMB_SPEED;

        // âœ… ë°”ë‹¥ í”Œë«í¼ ë‚´ë¶€ë¡œ ë“¤ì–´ê°€ì§€ ì•Šê²Œ + ë°©í–¥ ì•ˆì •í™”
		const minY = ladder.topLow  + (player.h*0.5) + 0.02;
		const maxY = ladder.topHigh + (player.h*0.5) + 0.02;
		player.y = clamp(player.y, minY, maxY);

		// âœ… ìœ„/ì•„ë˜ ì…ë ¥ ì—†ì´ ì¢Œ/ìš°ë¡œ ì›€ì§ì´ë©´ ì‚¬ë‹¤ë¦¬ì—ì„œ â€œì˜†ìœ¼ë¡œ ë¹ ì ¸ë‚˜ì˜¤ê¸°â€
		if((input.left || input.right) && !(input.up || input.down)){
		  player.isClimbing = false;
		  player.ladderLock = 0.12;
		}

        const nearTop = (player.y - player.h*0.5) >= (ladder.topHigh - LADDER_TOP_PAD);
        if(nearTop && input.up){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.vy = 0;
          player.y = ladder.topHigh + player.h*0.5 + 0.02;
        }

        if(input.jumpPressed){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.jumpBuf = 0; player.coyote = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          player.vy = JUMP_V;
          player.vx = MOVE_MAX * 0.70 * player.facing;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          screenShake(0.09, 0.10);
        }
      }else{
        // ë²½ ì í”„
        if(canControl && input.jumpPressed && player.wallGrace > 0 && !player.onGround && player.dashT<=0){
          const wd = player.wallDir || (dir!==0 ? -dir : -player.facing);
          player.vy = WALL_JUMP_V;
          player.vx = -wd * WALL_JUMP_H;
          player.facing = -wd;
          player.wallGrace = 0;
          player.jumpHold = JUMP_HOLD_TIME * 0.75;
          spawnDust(player.x + wd*0.25, player.y - player.h/2 + 0.12, 10);
          screenShake(0.10, 0.12);
          showToast("ë²½ ì í”„!", 520);
        }

        // ì í”„
        if(canControl && player.jumpBuf > 0 && (player.onGround || player.coyote > 0) && player.dashT<=0){
          player.vy = JUMP_V;
          player.onGround = false;
          player.coyote = 0;
          player.jumpBuf = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          spawnDust(player.x, player.y - player.h/2 + 0.02, 6);
          screenShake(0.09, 0.10);
          SFX.jump();
          showToast("ì í”„!", 450);
        }

        // ì í”„ ì»·
        if(input.jumpReleased && player.vy > 0){
          player.vy *= JUMP_CUT;
          player.jumpHold = 0;
        }

        // âœ… 8ë°©í–¥ ëŒ€ì‹œ(ê³µì¤‘ 1íšŒ)
        if(canControl && input.dashPressed && player.dashCd<=0 && player.dashT<=0 && player.dashCharges>0){
          // ë°©í–¥ ì…ë ¥ (ì—†ìœ¼ë©´ facing)
          let dx = (input.left?-1:0) + (input.right?1:0);
          let dy = (input.down?-1:0) + (input.up?1:0);
          if(dx===0 && dy===0) dx = player.facing;

          // ì •ê·œí™”
          const len = Math.hypot(dx,dy) || 1;
          dx /= len; dy /= len;

          player.dashT = DASH_TIME;
          player.dashCd = DASH_COOLDOWN;
          player.dashCharges--;

          player.isDucking = false;
          player.h = STAND_H;

          player.vx = dx * DASH_SPEED;
          player.vy = dy * DASH_SPEED;

          player.dashTrailT = 0.02;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);

          spawnParticles(player.x, player.y, 12, 1.2);
          screenShake(0.10, 0.12);
          SFX.dash();
          showToast("ëŒ€ì‹œ!", 420);
        }

        // ëŒ€ì‹œ ì¤‘(ì§§ê²Œ ì¤‘ë ¥ ì•½í™”)
        if(player.dashT > 0){
          player.vx = moveTowards(player.vx, player.vx, 0); // ìœ ì§€
          player.vy = moveTowards(player.vy, player.vy, 0);
          // ì‚´ì§ ê°ì‡ ë¡œ ì…€ë ˆìŠ¤íŠ¸ ëŠë‚Œ
          player.vx *= 0.995;
          player.vy *= 0.995;
        }else{
          // ì¤‘ë ¥
          let g = (player.vy > 0) ? GRAVITY_UP : GRAVITY_DOWN;

          if(!player.onGround && Math.abs(player.vy) <= APEX_VY){
            g *= APEX_GRAV_MULT;
          }

          if(player.vy > 0 && input.jump && player.jumpHold > 0){
            player.jumpHold = Math.max(0, player.jumpHold - dt);
            g *= JUMP_HOLD_GRAV;
          }else{
            player.jumpHold = 0;
          }

          if(!player.onGround && player.vy < 0 && input.down){
            g *= FAST_FALL_MULT;
          }

          player.vy += g * dt;
          player.vy = Math.max(player.vy, MAX_FALL_SPEED);
        }
      }

      // ëŒ€ì‹œ ì”ìƒ
      if(player.dashT > 0){
        player.dashTrailT -= dt;
        if(player.dashTrailT <= 0){
          player.dashTrailT = 0.03;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);
        }
      }

      // ì ë¶„ + ì¶©ëŒ
      const nextX = player.x + player.vx*dt;
      const nextY = player.y + player.vy*dt;
      const beforeGround = player.onGround;

      const res = resolveCollisions(nextX, nextY);
      player.x = res.x;
      player.y = res.y;

      if(!player.onGround && res.wallDir !== 0){
        player.wallDir = res.wallDir;
        player.wallGrace = WALL_GRACE;
      }else if(player.wallGrace <= 0){
        player.wallDir = 0;
      }

      player.onGround = res.onGround && !player.isClimbing;

      if(!beforeGround && player.onGround){
        player.landSquashT = 0.12;
        spawnParticles(player.x, player.y - player.h/2 + 0.05, 14, 1.0);
        spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
        screenShake(0.09, 0.10);
      }

      // ë²½ ìŠ¬ë¼ì´ë“œ 
      /*const wantsWall = (dir !== 0) ? dir : player.facing;
      if(!player.onGround && player.wallGrace > 0 && player.vy < 0 && !player.isClimbing){
        if(wantsWall === player.wallDir){
          player.vy = Math.max(player.vy, WALL_SLIDE_MAXFALL);
          if(rng() < 0.08) spawnDust(player.x + player.wallDir*0.22, player.y - player.h/2 + 0.35, 2);
        }
      }*/
	  // ë²½ ìŠ¬ë¼ì´ë“œ
		const wantsWall = (dir !== 0) ? dir : player.facing;
		if(!player.onGround && player.wallGrace > 0 && player.vy < 0 && !player.isClimbing){
		  if(wantsWall === player.wallDir){
			const maxFall = -Math.abs(WALL_SLIDE_MAXFALL); // â˜… í•µì‹¬
			player.vy = Math.max(player.vy, maxFall);

			if(rng() < 0.08) spawnDust(player.x + player.wallDir*0.22, player.y - player.h/2 + 0.35, 2);
		  }
		}
		
		

      // ì• ë‹ˆ ìƒíƒœ
      const isMoving = Math.abs(player.vx) > 0.65;
      const groundIdle = player.onGround && !player.isClimbing && !player.isDucking && !isMoving;
      const frontHold = groundIdle && input.up && canControl;

      if(player.isClimbing) player.state = "climb";
      else if(player.slideT>0) player.state = "slide";
      else if(player.isDucking && isMoving && player.onGround) player.state = "duckWalk";
      else if(player.isDucking) player.state = "duck";
      else if(frontHold) player.state = "frontHold";
      else if(!player.onGround) player.state = "jump";
      else if(isMoving) player.state = "walk";
      else player.state = "idle";

      player.idleStill = groundIdle ? (player.idleStill + dt) : 0;
      player.animT += dt;

      const showHit = player.hurtT > 0;

      if(showHit) setPlayerTex(TEX.hit);
      else if(player.state === "frontHold") setPlayerTex(TEX.front);
      else if(player.state === "idle") setPlayerTex(player.idleStill > 0.6 ? TEX.front : TEX.idle);
      else if(player.state === "jump") setPlayerTex(player.facing < 0 ? TEX.jumpBack : TEX.jump);
      else if(player.state === "walk"){
        const phase = Math.floor(player.animT*10) % 2;
        if(player.facing < 0){
          setPlayerTex(phase ? TEX.walkABack : TEX.walkBBack);
        }else{
          setPlayerTex(phase ? TEX.walkA : TEX.walkB);
        }
      }else if(player.state === "duck" || player.state === "duckWalk" || player.state === "slide"){
        setPlayerTex(TEX.duck);
      }else if(player.state === "climb"){
        const moving = Math.abs(player.vy) > 0.2;
        const phase = Math.floor(player.animT*10) % 2;
        setPlayerTex(moving ? (phase ? TEX.climbA : TEX.climbB) : TEX.climbA);
      }

      // ì‹œê° ìŠ¤ì¼€ì¼
      let baseScaleX = 1.65;
      let baseScaleY = 1.65;
      let yBob = 0;

      if(player.landSquashT > 0){
        const t = 1 - (player.landSquashT / 0.12);
        const squash = Math.sin(t * Math.PI);
        baseScaleY *= (1.0 - 0.10*squash);
        baseScaleX *= (1.0 + 0.06*squash);
      }

      if(player.state === "duckWalk"){
        const t = player.animT * 12.0;
        yBob = Math.sin(t) * 0.035;
        baseScaleY *= 0.90;
        baseScaleX *= 1.02;
        player.duckStepT -= dt;
        if(player.duckStepT <= 0){
          player.duckStepT = 0.09;
          spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 4);
        }
      }else if(player.state === "slide"){
        baseScaleY *= 0.88;
        baseScaleX *= 1.06;
        if(rng() < 0.25) spawnDust(player.x - player.facing*0.25, player.y - player.h/2 + 0.02, 2);
        player.duckStepT = 0;
      }else{
        player.duckStepT = 0;
      }

      // ì‹œì‘/ë¦¬ìŠ¤í° "ë¿…" ëª¨ì…˜(ìŠ¤ì¼€ì¼ 0â†’1 + ì•½ê°„ì˜ ì˜¤ë²„ìŠˆíŠ¸)
      if(player.spawnT > 0){
        player.spawnT = Math.max(0, player.spawnT - dt);
        const k = 1 - clamp(player.spawnT / SPAWN_DUR, 0, 1);
        const s = clamp(easeOutBack(k), 0, 1.25);
        baseScaleX *= s;
        baseScaleY *= s;
        // ì•½ê°„ ìœ„ë¡œ ëœ¨ëŠ” ëŠë‚Œ
        yBob += (1 - easeOutCubic(clamp(k,0,1))) * 0.18;
      }

      playerSprite.position.set(player.x, player.y + 0.08 + yBob, 3);
      playerSprite.scale.set(baseScaleX, baseScaleY, 1);
      {
        const map = playerSprite.material.map;
        const isBackTex = (map === TEX.jumpBack || map === TEX.walkABack || map === TEX.walkBBack);
        playerSprite.scale.x = Math.abs(playerSprite.scale.x) * (isBackTex ? 1 : (player.facing>=0 ? 1 : -1));
      }

      // ë¬´ì  ê¹œë¹¡ì„
      if(player.invuln > 0){
        const blink = (Math.floor(player.animT*16) % 2) ? 0.35 : 1.0;
        playerSprite.material.opacity = blink;
      }else{
        playerSprite.material.opacity = 1.0;
      }
    }

    // ----------------------------
    // ì½”ì¸/ì /ìŠ¤í”„ë§/ê³¨
    // ----------------------------
    function updateCoins(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const c of world.coins){
        if(c.dead) continue;
        c.t += dt;
        const bob = Math.sin(c.t*4.2)*0.10;
        c.mesh.position.y = c.y + bob;
        c.mesh.rotation.z = Math.sin(c.t*2.2)*0.08;

        const cx = c.x - c.r;
        const cy = (c.y+bob) - c.r;
        if(aabbIntersect(px,py,player.w,player.h, cx,cy,c.r*2,c.r*2)){
          c.dead = true;
          scene.remove(c.mesh);

          world.collectedCoinsLevel++;
          if(policy.keepCoins) world.totalCoinsRun++;
          updateCoinHUD();

          spawnParticles(c.x, c.y, 12, 1.1);
          screenShake(0.06, 0.08);
          SFX.coin();
        }
      }
    }
    
	function updateDebugOverlay(){
		  if(!debug.enabled) return;

		  resetDebugPool();

		  // í˜„ì¬ ë·° ë²”ìœ„(ê°€ê¹Œìš´ ê²ƒë§Œ ê·¸ë ¤ì„œ ê°€ë³ê²Œ)
		  const viewW = (camera.right - camera.left) / camera.zoom;
		  const viewH = (camera.top - camera.bottom) / camera.zoom;
		  const minX = camX - viewW*0.5 - 2.5;
		  const maxX = camX + viewW*0.5 + 2.5;
		  const minY = camY - viewH*0.5 - 2.5;
		  const maxY = camY + viewH*0.5 + 2.5;

		  // í”Œë ˆì´ì–´ AABB
		  {
			const px = player.x - player.w*0.5;
			const py = player.y - player.h*0.5;
			const r = getRect(MAT_PLAYER);
			setRect(r, px, py, player.w, player.h);
		  }

		  // ì†ë„ ë²¡í„°(í˜„ì¬ ì†ë„ ë°©í–¥ í™•ì¸ìš©)
		  {
			const sx = player.x;
			const sy = player.y;
			const scale = 0.12; // í™”ë©´ì—ì„œ ë³´ê¸° ì¢‹ì€ ìŠ¤ì¼€ì¼
			setVelLine(sx, sy, sx + player.vx*scale, sy + player.vy*scale);
		  }

		  // í”Œë«í¼(ì†”ë¦¬ë“œ)
		  for(const p of world.platforms){
			if(p.x > maxX || p.x+p.w < minX || p.y > maxY || p.y+p.h < minY) continue;
			const r = getRect(MAT_SOLID);
			setRect(r, p.x, p.y, p.w, p.h);
		  }

		  // ì‚¬ë‹¤ë¦¬
		  for(const l of world.ladders){
			if(l.x > maxX || l.x+l.w < minX || l.y > maxY || l.y+l.h < minY) continue;
			const r = getRect(MAT_LADDER);
			setRect(r, l.x, l.y, l.w, l.h);
		  }

		  // ì½”ì¸(ì›í˜• ëŒ€ì‹  ë°•ìŠ¤)
		  for(const c of world.coins){
			if(c.dead) continue;
			const size = c.r*2;
			const x = c.x - c.r;
			const y = c.y - c.r;
			if(x > maxX || x+size < minX || y > maxY || y+size < minY) continue;
			const r = getRect(MAT_COIN);
			setRect(r, x, y, size, size);
		  }

		  // ì 
		  for(const e of world.enemies){
			if(e.dead) continue;
			const x = e.x - e.w/2;
			const y = e.y - e.h/2;
			if(x > maxX || x+e.w < minX || y > maxY || y+e.h < minY) continue;
			const r = getRect(MAT_ENEMY);
			setRect(r, x, y, e.w, e.h);
		  }

		  // ê³¨
		  if(world.goal){
			const g = world.goal;
			const gx = g.x - g.w/2;
			const gy = g.y - g.h/2;
			if(!(gx > maxX || gx+g.w < minX || gy > maxY || gy+g.h < minY)){
			  const r = getRect(MAT_GOAL);
			  setRect(r, gx, gy, g.w, g.h);
			}
		  }
		}
	
    function hurtPlayer(fromX){
      if(player.invuln > 0 || (game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro")) return;
      player.hp = Math.max(0, player.hp - 1);
      $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));

      // HPê°€ 0ì´ ë˜ë©´ ì¦‰ì‹œ ì‚¬ë§ ì—°ì¶œ(ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ + ì‚¬ìš´ë“œ) í›„ ë¦¬ìŠ¤í°
      if(player.hp <= 0){
        startRespawn("ì²´ë ¥ì´ ë‹¤í–ˆì–´â€¦");
        return;
      }

      player.invuln = 1.0;
      player.hurtT = 0.22;

      const dir = sign(player.x - fromX) || 1;
      player.vx = dir * 10.5;
      player.vy = 9.5;
      screenShake(0.12, 0.15);
      spawnParticles(player.x, player.y, 18, 1.25);
      spawnDust(player.x, player.y - player.h/2 + 0.05, 10);
      SFX.hurt();
      showToast("í”¼ê²©!", 700);
    }

    function updateEnemies(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const e of world.enemies){
        // ì£½ìŒ ì—°ì¶œ(ë‚©ì‘) íƒ€ì´ë¨¸
        if(e.dead){
          e.deathTimer -= dt;
          if(e.deathTimer <= 0){
            scene.remove(e.mesh);
            e.deathTimer = 0;
          }
          continue;
        }

        e.x += e.vx * dt;
        if(e.x < e.roamMin || e.x > e.roamMax) e.vx *= -1;

        e.mesh.position.x = e.x;

        // âœ… ìŠ¬ë¼ì„ í…ìŠ¤ì³ ì• ë‹ˆë©”ì´ì…˜(ê±·ê¸°/íœ´ì‹)
        e.animT += dt;
        const moving = Math.abs(e.vx) > 0.05;

        // movingì´ë©´ walkA/walkB ë²ˆê°ˆì•„, ì•„ë‹ˆë©´ rest
        const phase = (Math.floor(e.animT*8) % 2);
        const nextTex = moving ? (phase ? texSlimeWalkA : texSlimeWalkB) : texSlimeRest;

        if(e.mesh.material.map !== nextTex){
          e.mesh.material.map = nextTex;
          e.mesh.material.needsUpdate = true;
        }

const ex = e.x - e.w/2;
        const ey = e.y - e.h/2;
        if(aabbIntersect(px,py,player.w,player.h, ex,ey,e.w,e.h)){
          const playerBottom = player.y - player.h*0.5;
          const enemyTop = e.y + e.h*0.5;

          if(player.vy < 0 && playerBottom > enemyTop - 0.25){
            e.dead = true;
            // âœ… ë‚©ì‘(Flat) ìŠ¤í”„ë¼ì´íŠ¸ë¡œ ì ê¹ ì—°ì¶œ í›„ ì œê±°
            e.mesh.material.map = texSlimeFlat;
            e.mesh.material.needsUpdate = true;
            e.mesh.scale.y = 0.55;
            e.deathTimer = 0.14;
            player.vy = 12.0;
            spawnParticles(e.x, e.y, 22, 1.35);
            spawnDust(e.x, e.y - 0.25, 10);
            screenShake(0.10, 0.12);
            SFX.stomp();
            showToast("ë°Ÿê¸°!", 500);
          }else{
            hurtPlayer(e.x);
          }
        }
      }
    }

    function updateSprings(){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const s of world.springs){
        const sx = s.x - s.w/2;
        const sy = s.y - s.h/2;
        if(aabbIntersect(px,py,player.w,player.h, sx,sy,s.w,s.h)){
          if(player.vy < 0){
            player.vy = 18.5;
            player.jumpHold = 0;
            spawnParticles(s.x, s.y+0.2, 18, 1.2);
            spawnDust(s.x, s.y, 10);
            screenShake(0.10, 0.14);
            showToast("ìŠ¤í”„ë§!", 600);
          }
        }
      }
    }

    function updateGoal(){
      if(!world.goal) return;

      const g = world.goal;

      // ë ˆë²¨ ì½”ì¸ ë‹¤ ëª¨ìœ¼ë©´ í™œì„±í™”(í¼ì¦/íƒìƒ‰ ëŠë‚Œ)
      if(!g.active && world.collectedCoinsLevel >= world.totalCoinsLevel){
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("ê³¨ í™œì„±í™”!", 900);
      }

      if(!g.active || game.state !== "play") return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

      if(aabbIntersect(px,py,player.w,player.h, gx,gy,g.w,g.h)){
        // âœ… ì½”ì¸ ì „ë¶€ ìˆ˜ì§‘ í›„ ê³¨ ë„ì°© â†’ ë³´ìŠ¤ì „ìœ¼ë¡œ ì „í™˜(ë ˆë²¨ì„ ë°”ë¡œ ë„˜ê¸°ì§€ ì•ŠìŒ)
        startBossFight();
      }
    }
    
	function jumpGoal(){
	    const g = world.goal;

      // ë ˆë²¨ ì½”ì¸ ë‹¤ ëª¨ìœ¼ë©´ í™œì„±í™”(í¼ì¦/íƒìƒ‰ ëŠë‚Œ)
      
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("ê³¨ í™œì„±í™”!", 900);
      

      

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

     
        startBossFight();
      
	}
	
    // ----------------------------
    // ë³´ìŠ¤ì „(ê±°ëŒ€í•œ ê³ ë˜)
    //  - ì½”ì¸ ì „ë¶€ ìˆ˜ì§‘ í›„ ê¹ƒë°œ ë„ì°© â†’ ë³´ìŠ¤ì „ ì§„ì…
    //  - í™”ë©´ ìš°ì¸¡ì—ì„œ ìƒí•˜ ì´ë™
    //  - ê±°í’ˆ ë¯¸ì‚¬ì¼ ë°œì‚¬(ë‚œì´ë„â†‘: ë°œì‚¬ ë¹ˆë„/ì†ë„/íŒ¨í„´ ê³ ë„í™”)
    //  - í”Œë ˆì´ì–´ëŠ” ëŒ€ì‹œë¡œ ëª¸í†µì— ë°•ì¹˜ê¸°í•˜ë©´ í”¼í•´
    // ----------------------------
    const texBubble = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);

      // ì™¸ê³½
      g.beginPath();
      g.arc(w/2,h/2,w*0.34,0,Math.PI*2);
      g.closePath();
      g.strokeStyle = "rgba(9,9,9,0.50)";
      g.lineWidth = w*0.03;
      g.stroke();

      // ë‚´ë¶€ ê·¸ë¼ë°ì´ì…˜
      const grd = g.createRadialGradient(w*0.38,h*0.38,w*0.05, w*0.5,h*0.5,w*0.38);
      grd.addColorStop(0, "rgba(220,245,255,0.55)");
      grd.addColorStop(0.55, "rgba(140,210,255,0.20)");
      grd.addColorStop(1, "rgba(40,120,190,0.10)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(w/2,h/2,w*0.33,0,Math.PI*2);
      g.fill();

      // í•˜ì´ë¼ì´íŠ¸
      g.fillStyle = "rgba(255,255,255,0.55)";
      g.beginPath();
      g.ellipse(w*0.38, h*0.35, w*0.10, h*0.07, -0.6, 0, Math.PI*2);
      g.fill();

      g.fillStyle = "rgba(255,255,255,0.28)";
      g.beginPath();
      g.ellipse(w*0.62, h*0.62, w*0.06, h*0.04, 0.7, 0, Math.PI*2);
      g.fill();
    });

    // ë¬¸ì–´ìš© "ì´ˆë¡ ë¬¼ë°©ìš¸" í…ìŠ¤ì²˜(ìº”ë²„ìŠ¤)
    const texDropletGreen = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx = w/2, cy = h/2;

      // ë¬¼ë°©ìš¸ ë³¸ì²´(ëˆˆì— ë„ëŠ” ì´ˆë¡ ê·¸ë¼ë°ì´ì…˜)
      const grd = g.createRadialGradient(cx - w*0.16, cy - h*0.18, w*0.06, cx, cy, w*0.52);
      grd.addColorStop(0.00, "rgba(230,255,230,0.95)");
      grd.addColorStop(0.35, "rgba(90,235,140,0.85)");
      grd.addColorStop(1.00, "rgba(20,120,60,0.35)");
      g.fillStyle = grd;
      g.beginPath();
      // teardrop path
      g.moveTo(cx, h*0.08);
      g.bezierCurveTo(w*0.18, h*0.34, w*0.18, h*0.78, cx, h*0.92);
      g.bezierCurveTo(w*0.82, h*0.78, w*0.82, h*0.34, cx, h*0.08);
      g.closePath();
      g.fill();

      // ì™¸ê³½
      g.strokeStyle = "rgba(10,10,10,0.45)";
      g.lineWidth = w*0.03;
      g.stroke();

      // í•˜ì´ë¼ì´íŠ¸
      g.fillStyle = "rgba(255,255,255,0.52)";
      g.beginPath();
      g.ellipse(cx - w*0.14, cy - h*0.12, w*0.10, h*0.08, -0.85, 0, Math.PI*2);
      g.fill();
    });


		
// ë“œë˜ê³¤ìš© íŒŒì´ì–´ë³¼ í…ìŠ¤ì²˜(ìº”ë²„ìŠ¤) - ê²€ì • ë°”íƒ• + ë¹¨ê°• í¬ì¸íŠ¸ (í° ë°°ê²½ ëŒ€ë¹„ ìµœê°•)
const texFireball = makeCanvasTexture((g,w,h)=>{
  g.clearRect(0,0,w,h);
  g.globalCompositeOperation = "source-over";

  const cx = w/2, cy = h/2;

  // 0) ì™„ì „ ë¶ˆíˆ¬ëª… ê²€ì • ì›(í˜•íƒœ ê³ ì •, í° ë°°ê²½ì—ì„œë„ ë¬´ì¡°ê±´ ë³´ì„)
  g.fillStyle = "rgba(0,0,0,1.0)";
  g.beginPath();
  g.arc(cx, cy, w*0.44, 0, Math.PI*2);
  g.fill();

  // 1) ë¹¨ê°• ì½”ì–´(ì¤‘ì‹¬ë¶€)
  const core = g.createRadialGradient(cx, cy, w*0.02, cx, cy, w*0.22);
  core.addColorStop(0.00, "rgba(255, 60, 60, 1.0)");
  core.addColorStop(0.35, "rgba(180, 0, 0, 1.0)");
  core.addColorStop(1.00, "rgba(80, 0, 0, 1.0)");
  g.fillStyle = core;
  g.beginPath();
  g.arc(cx, cy, w*0.22, 0, Math.PI*2);
  g.fill();

  // 2) ë¹¨ê°• ë§(ê²€ì • ìœ„ì— ì„ ëª…í•˜ê²Œ)
  g.strokeStyle = "rgba(255, 30, 30, 1.0)";
  g.lineWidth = w*0.06;
  g.beginPath();
  g.arc(cx, cy, w*0.32, 0, Math.PI*2);
  g.stroke();

  // 3) ì™¸ê³½ í…Œë‘ë¦¬(ì•„ì£¼ ì–‡ì€ ì§„íšŒìƒ‰) - ê²½ê³„ê°€ ë” ë˜ë ·í•´ì§
  g.strokeStyle = "rgba(40,40,40,1.0)";
  g.lineWidth = w*0.035;
  g.beginPath();
  g.arc(cx, cy, w*0.46, 0, Math.PI*2);
  g.stroke();

  // 4) ë¹¨ê°• ìŠ¤íŒŒí¬(ìš”ë€í•˜ê²Œ, ëŒ€ë¹„ í™•ì‹¤)
  for(let i=0;i<12;i++){
    const a = (i/12)*Math.PI*2;
    const r1 = w*0.10 + (i%3)*w*0.02;
    const r2 = w*0.46;

    const x1 = cx + Math.cos(a)*r1;
    const y1 = cy + Math.sin(a)*r1;
    const x2 = cx + Math.cos(a)*r2;
    const y2 = cy + Math.sin(a)*r2;

    // ê²€ì • ìŠ¤íŒŒí¬(êµµê²Œ)
    g.strokeStyle = "rgba(0,0,0,0.8)";
    g.lineWidth = w*0.02;
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();

    // ë¹¨ê°• í•˜ì´ë¼ì´íŠ¸(ì–‡ê²Œ)
    g.strokeStyle = "rgba(255, 40, 40, 1.0)";
    g.lineWidth = w*0.012;
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
  }

  // 5) ì¤‘ì‹¬ í•˜ì´ë¼ì´íŠ¸ ì (ë¹¨ê°•/í°ë¹› ì•½ê°„)
  g.fillStyle = "rgba(255,120,120,1.0)";
  g.beginPath();
  g.arc(cx - w*0.05, cy - h*0.05, w*0.06, 0, Math.PI*2);
  g.fill();
});
    

function setBossHUD(on, boss){
      if(!$bossHpWrap) return;
      $bossHpWrap.style.display = on ? "" : "none";
      if(on && boss){
        $bossHpText.textContent = "â– ".repeat(Math.max(0, boss.hp)) + "â–¡".repeat(Math.max(0, boss.maxHp - boss.hp));
        $bossLvText.textContent = `Lv${boss.diff}`;
      }
    }

    function buildBossArena(diff, kind='whale'){
      clearWorld();

      // ë°”ë‹¥/ë²½: ë²½ì í”„ ê°€ëŠ¥í•˜ê²Œ ê°„ë‹¨í•œ ê¸°ë‘¥ ì œê³µ
      const ground = addPlatform(-20, 0, 80, 1.0);
      world.groundTop = ground.y + ground.h;
      world.killY = -12;

      // ì¢Œì¸¡ ì‹œì‘ êµ¬ì—­ ê¸°ë‘¥(ë²½ì í”„ìš©)
      // (ìš”ì²­) ë³´ìŠ¤ì „ ì‹œì‘ êµ¬ì—­ ê¸°ë‘¥ ì œê±°
      // ì‘ì€ ë°œíŒ
      addPlatform(-8, 3.0, 5.0, 0.8);
      addPlatform( 2, 4.6, 4.2, 0.8);
	 
	  addPlatform(14, 1.8, 1.8, 0.5);
	  addPlatform(14, 2.8, 2.8, 0.5);
      addPlatform(14, 3.8, 1.8, 0.5);
	  addPlatform(14, 4.8, 2.8, 0.5);
	  addPlatform(14, 5.8, 1.8, 0.5);
	  addPlatform(14, 6.8, 2.8, 0.5);
	  addPlatform(14, 7.8, 1.8, 0.5);
	  addPlatform(14, 8.8, 1.8, 0.5);
	  addPlatform(14, 9.8, 1.8, 0.5);
	  addPlatform(14, 10.8, 1.8, 0.5);
      //addPlatform(14, 5.8, 4.8, 0.8);
      // í”Œë ˆì´ì–´ ìœ„ì¹˜
      player.x = -15.5;
      player.y = 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // (ì‚¬ë§ ë¦¬ìŠ¤í°) HP ì •ì±…: ë¬´ì¡°ê±´ 5ë¡œ íšŒë³µ
      if(game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "â¤â¤â¤â¤â¤";
        game.forceFullHP = false;
      }else{
        $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));
      }

      // "ë¿…" ë“±ì¥ ì´í™íŠ¸ + ëª¨ì…˜
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

	// ë³´ìŠ¤ ì¢…ë¥˜ì— ë”°ë¼ í…ìŠ¤ì²˜ êµì²´(ë¡œë”© ì‹¤íŒ¨ ì‹œ ê³ ë˜ë¡œ í´ë°±)
	if(kind === 'dragon' && BOSS_TEX_DRAGON){
	  BOSS_TEX = BOSS_TEX_DRAGON;
	}else if(kind === 'octopus' && BOSS_TEX_OCTOPUS){
	  BOSS_TEX = BOSS_TEX_OCTOPUS;
	}else{
	  BOSS_TEX = BOSS_TEX_WHALE || BOSS_TEX;
	  kind = 'whale';
	}

      // ë³´ìŠ¤ ìƒì„±
      const bossW = 7.2;
      const bossH = 5.2;
      const hitW  = 4.8;
      const hitH  = 3.4;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(bossW, bossH),
        new THREE.MeshBasicMaterial({ map: BOSS_TEX.idleA, transparent:true, color: 0xffffff })
      );
      mesh.position.set(18, 7.0, 1.2);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.boss = {
        diff,
        kind,
        // ë“œë˜ê³¤: ë” ë¹ ë¥´ê³  ìš”ë€í•¨ / ë¬¸ì–´: ê³ ë˜ íŒ¨í„´ ê¸°ë°˜ì´ì§€ë§Œ 20% ëŠë¦¼
        speedMul: (kind === 'dragon') ? 1.2 : (kind === 'octopus' ? 0.8 : 1.0),
        rateMul:  (kind === 'dragon') ? 1.2 : (kind === 'octopus' ? 0.8 : 1.0),
        shotMul:  1.0,
        hp: 5,
        maxHp: 5,
        x: mesh.position.x,
        y: mesh.position.y,
		baseX: mesh.position.x-12,   //15 âœ… ì¶”ê°€
        baseY: mesh.position.y-4,   //5 âœ… ì¶”ê°€
        w: bossW, h: bossH,
        hitW, hitH,
        mesh,
        t: 0,
        invuln: 0,
        hurtT: 0,
        chargeT: 0,
        fireCd: 1.1,
        patternCd: 3.2,
        pattern: "aim",
      };

      setBossHUD(true, world.boss);
    }

    
function startBossFight(){
  // ë‹¤ìŒ ë ˆë²¨ì€ ë³´ìŠ¤ ê²©íŒŒ í›„ ì§„í–‰
  game.pendingNextLevel = game.level + 1;

  // ëˆ„ì  ë‚œì´ë„(=ë³´ìŠ¤ ë ˆë²¨)
  const diff = Math.max(1, (game.bossDifficulty|0));

  // âœ… ê²Œì„ ë ˆë²¨ ê¸°ì¤€ ë³´ìŠ¤ ì¢…ë¥˜
  // - 3ì˜ ë°°ìˆ˜ ë ˆë²¨: ë¬¸ì–´
  // - ê·¸ ì™¸: 1(ê³ ë˜) â†’ 2(ë“œë˜ê³¤) â†’ 3(ë¬¸ì–´) ë°˜ë³µ
  let kind = 'whale';
  if((game.level % 3) === 0) kind = 'octopus';
  else if((game.level % 3) === 2) kind = 'dragon';

  // ë³´ìŠ¤ì „ìœ¼ë¡œ ì „í™˜
  game.state = "bossIntro";
  game.t = 1.2;

  // arena êµ¬ì„±
  buildBossArena(diff, kind);
  const kindLabel = (kind === 'dragon') ? 'ë“œë˜ê³¤' : (kind === 'octopus' ? 'ë¬¸ì–´' : 'ê³ ë˜');
  $stageText.textContent = `BOSS Lv ${diff} (${kindLabel})`;

  showBigMsg(true,
    kind === 'dragon' ? `BOSS ë“±ì¥! ìš”ë€í•œ ë“œë˜ê³¤ (Lv ${diff})`
    : (kind === 'octopus' ? `BOSS ë“±ì¥! ëŠë¦¿ëŠë¦¿ ë¬¸ì–´ (Lv ${diff})` : `BOSS ë“±ì¥! ê±°ëŒ€í•œ ê³ ë˜ (Lv ${diff})`)
  );

  if(kind === 'dragon'){
    showToast("ë³´ìŠ¤ì „! ë¶ˆê½ƒì„ í”¼í•˜ê³  ëŒ€ì‹œë¡œ ê³µê²©! (ë“œë˜ê³¤ì€ ë¹ ë¦„)", 15000);
  }else if(kind === 'octopus'){
    showToast("ë³´ìŠ¤ì „! ì´ˆë¡ ë¬¼ë°©ìš¸ì„ í”¼í•˜ê³  ëŒ€ì‹œë¡œ ê³µê²©! (ë¬¸ì–´ëŠ” ëŠë¦¼)", 15000);
  }else{
    showToast("ë³´ìŠ¤ì „! ê±°í’ˆ ë¯¸ì‚¬ì¼ì„ í”¼í•˜ê³  ëŒ€ì‹œë¡œ ê³µê²©!", 15000);
  }

  showToast("ëŒ€ì‹œ!! ", 15000);
  screenShake(0.99, 0.99);
  screenShake(0.18, 0.20);
  SFX.clear();
}

function spawnBubble(x,y, vx,vy, r=0.42, homing=0){
      const geo = new THREE.PlaneGeometry(r*2, r*2);
      const mat = new THREE.MeshBasicMaterial({ map: texBubble, transparent:true, opacity:0.95 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, 1.1);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.bossBullets.push({
        type:'bubble',
        x,y,r,vx,vy, homing,
        life: 8.0,
        spin: rand(-5,5),
        wob: rand(0,Math.PI*2),
        mesh
      });
    }

function spawnGreenDroplet(x,y, vx,vy, r=0.42, homing=0){
      const geo = new THREE.PlaneGeometry(r*2, r*2);
      const mat = new THREE.MeshBasicMaterial({ map: texDropletGreen, transparent:true, opacity:0.97 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, 1.1);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.bossBullets.push({
        type:'droplet',
        x,y,r,vx,vy, homing,
        life: 8.0,
        spin: rand(-5,5),
        wob: rand(-Math.PI,Math.PI),
        mesh
      });
    }

    

function spawnFireball(x,y, vx,vy, r=0.38, homing=0){
  const geo = new THREE.PlaneGeometry(r*2, r*2);
  const mat = new THREE.MeshBasicMaterial({
    map: texFireball,
    transparent:true,
    //opacity:0.92,
	opacity:0.92,
    //blending: THREE.AdditiveBlending,
    depthWrite:false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, 1.12);
  mesh.frustumCulled = false;
  scene.add(mesh);

  world.bossBullets.push({
    type:'fire',
    x,y,r,vx,vy, homing,
    life: 7.0,
    spin: rand(-9,9),
    wob: rand(0,Math.PI*2),
    mesh
  });
}

function spawnBossShot(b, x,y, vx,vy, r, homing){
  if(b && b.kind === "dragon"){
    spawnFireball(x,y, vx,vy, r*0.92, homing);
    // ìš”ë€í•¨: ë°œì‚¬ ìˆœê°„ ì‘ì€ í”ë“¤ë¦¼/íŒŒí¸
    screenShake(0.04, 0.05);
    spawnParticles(x, y, 10, 0.9);
  }else if(b && b.kind === "octopus"){
    spawnGreenDroplet(x,y, vx,vy, r, homing);
  }else{
    spawnBubble(x,y, vx,vy, r, homing);
  }
}

    function chooseBossPattern(diff){
      // diffê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ íŒ¨í„´ í’€ í™•ëŒ€
      const pool = ["aim"];
      if(diff >= 2) pool.push("triple");
      if(diff >= 3) pool.push("wave");
      if(diff >= 4) pool.push("homing");
      if(diff >= 6) pool.push("spray");
      return pool[(Math.random()*pool.length)|0];
    }

    function fireBoss(b){
      // ê³µí†µ íŒŒë¼ë¯¸í„°(ë‚œì´ë„ ìŠ¤ì¼€ì¼)
      const spd = (7.8 + b.diff*0.85) * (b.speedMul || 1.0);
      const rateBase = Math.max(0.34, 1.05 - b.diff*0.06) / (b.rateMul || 1.0);
      b.fireCd = rateBase * rand(0.85, 1.15);

      // ê³µê²© ì—°ì¶œ: ì ê¹ charge í”„ë ˆì„
      b.chargeT = 0.14;

      // ë“œë˜ê³¤ì€ ë” ë¹ ë¥´ê²Œ ì¬ì¶©ì „(ìš”ë€í•¨)
      if(b.kind === 'dragon') b.chargeT = 0.15;

      const dx0 = (player.x - b.x);
      const dy0 = (player.y - b.y);
      const len = Math.hypot(dx0, dy0) || 1;
      const ux = dx0/len, uy = dy0/len;

      if(b.pattern === "aim"){
        spawnBossShot(b, b.x - 2.1, b.y + 0.2, ux*spd, uy*spd, 0.44, 0);
      }else if(b.pattern === "triple"){
        const a = Math.atan2(uy, ux);
        for(const da of [-0.18, 0, 0.18]){
          const vx = Math.cos(a+da)*spd;
          const vy = Math.sin(a+da)*spd;
          spawnBossShot(b, b.x - 2.1, b.y + 0.2, vx, vy, 0.42, 0);
        }
      }else if(b.pattern === "wave"){
        // ì¢Œâ†’ìš° íŒŒë„ì²˜ëŸ¼ í”ë“¤ë¦¬ëŠ” 5ë°œ
        for(let i=0;i<5;i++){
          const vy = (i-2)*1.25 + Math.sin((b.t+i)*1.1)*0.6;
          spawnBossShot(b, b.x - 2.1, b.y + 0.2 + (i-2)*0.25, -spd*(0.95+0.05*i), vy, 0.40, 0);
        }
      }else if(b.pattern === "homing"){
        // ëŠë¦¬ì§€ë§Œ ì¶”ì 
        spawnBossShot(b, b.x - 2.1, b.y + 0.2, ux*(spd*0.75), uy*(spd*0.75), 0.50, 1);
        // ë³´ì¡°íƒ„ 1ë°œ(ë‚œì´ë„ ë†’ì„ìˆ˜ë¡)
        if(b.diff >= 5){
          spawnBossShot(b, b.x - 2.1, b.y - 0.5, ux*(spd*0.70), uy*(spd*0.70), 0.46, 1);
        }
      }else if(b.pattern === "spray"){
        // ë„“ì€ ë¶€ì±„ê¼´ ì—°ì‚¬
        const base = Math.atan2(uy, ux);
        const count = 7 + Math.min(5, b.diff-6);
        const spread = 0.75;
        for(let i=0;i<count;i++){
          const t = (count<=1)?0:(i/(count-1));
          const da = (t-0.5)*spread;
          const s = spd*(0.85 + 0.25*Math.random());
          spawnBossShot(b, b.x - 2.1, b.y + 0.2, Math.cos(base+da)*s, Math.sin(base+da)*s, 0.38, 0);
        }
      }
    }

    function bossTakeHit(b, hitX, hitY){
      if(b.invuln > 0) return;

      b.hp--;
      b.invuln = 0.28;
      b.hurtT = 0.18;

      setBossHUD(true, b);
      screenShake(0.12, 0.18);
      spawnParticles(hitX, hitY, 30, 1.6);
      spawnDust(hitX, hitY-0.25, 14);
      SFX.stomp();

      // ë§ìœ¼ë©´ í”Œë ˆì´ì–´ íŠ•ê¹€(ëŒ€ì‹œ ê³µê²© ëŠë‚Œ)
      player.vx = -12.0;
      player.vy = 9.0;
      player.dashT = 0;
      player.dashCd = Math.max(player.dashCd, 0.12);

      if(b.hp <= 0){
        // ë³´ìŠ¤ ê²©íŒŒ
        game.state = "bossDefeat";
        game.t = 2.3;

        // ë‹¤ìŒë¶€í„° ë” ì–´ë ¤ì›€
        game.bossDifficulty = (game.bossDifficulty|0) + 1;

        showBigMsg(true, `ê²©íŒŒ ì„±ê³µ! ë‹¤ìŒ ë³´ìŠ¤ Lv ${game.bossDifficulty}`);
        showToast("ë³´ìŠ¤ ê²©íŒŒ! ë‹¤ìŒ ë ˆë²¨ë¡œ...", 1200);

        // íƒ„ ì œê±°
        for(const bb of world.bossBullets){
          if(bb.mesh) scene.remove(bb.mesh);
        }
        world.bossBullets = [];

        screenShake(0.20, 0.22);
        spawnFirework(hitX, hitY+2.0);
        spawnFirework(hitX-1.2, hitY+2.4);
        SFX.clear();
      }
    }

    function updateBoss(dt){
      const b = world.boss;
      if(!b) return;

      b.t += dt;
      b.invuln = Math.max(0, b.invuln - dt);
      b.hurtT  = Math.max(0, b.hurtT  - dt);
      b.chargeT= Math.max(0, b.chargeT- dt);
		// ì´ë™(ë“œë˜ê³¤ì€ ë¹ ë¥´ê³  ìš”ë€í•˜ê²Œ / ë¬¸ì–´ëŠ” ê³ ë˜ íŒ¨í„´ ê¸°ë°˜ì´ì§€ë§Œ 20% ëŠë¦¿ëŠë¦¿)
		const isDragon = (b.kind === 'dragon');
		const isOctopus = (b.kind === 'octopus');
		const baseX = b.baseX;
		const baseY = b.baseY;

		let amp  = 1.6 + b.diff*0.10;
		let spdY = 0.8 + b.diff*0.05;

		if(isDragon){
		  amp  *= 1.35;
		  spdY *= (b.speedMul || 2.0);
		  b.x = baseX + Math.sin(b.t*2.7) * (0.85 + b.diff*0.05) + Math.sin(b.t*12.0) * 0.08;
		}else{
		  // ê³ ë˜/ë¬¸ì–´: ìš°ì¸¡ ê³ ì • + ìƒí•˜ ì‚¬ì¸ ì´ë™
		  b.x = baseX;
		  spdY *= (b.speedMul || 1.0); // ë¬¸ì–´ëŠ” speedMul=0.8ë¡œ ëŠë¦¬ê²Œ
		  if(isOctopus) amp *= 0.92;
		}

		b.y = baseY + Math.sin(b.t * spdY) * amp;
		if(isOctopus) b.y += Math.sin(b.t * 0.35) * 0.12; // ëŠë¦¿ëŠë¦¿ 2ì°¨ í”ë“¤ë¦¼
		b.mesh.position.x = b.x;
		b.mesh.position.y = b.y;

      // í”„ë ˆì„(ì—°ì¶œ)
	  
      const mat = b.mesh.material;
      
	  /*
	  if(b.hurtT > 0){
        mat.map = BOSS_TEX.hurt;
        mat.color.setHex(0xff6b6b); // ë¶‰ì€ íƒ€ê²©
      }else if(b.chargeT > 0){
        mat.map = BOSS_TEX.charge;
        mat.color.setHex(0xffffff);
      }else{
        mat.color.setHex(0xffffff);
        const phase = (Math.floor(b.t*2.2) % 2);
        // ê³µê²© ì¤‘ì—” attack í”„ë ˆì„ì„ ì„ê¸°
        if(b.fireCd < 0.18){
          mat.map = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
        }else{
          mat.map = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
        }
      }
	  */
	  const phase = (Math.floor(b.t*2.2) % 2);
		let baseMap;

		if (b.fireCd < 0.18) {
		  baseMap = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
		} else {
		  baseMap = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
		}

		// chargeë„ ëª¸í†µ í”„ë ˆì„ ìœ ì§€(ì›í•˜ë©´ attackAë¡œ ê³ ì •)
		if (b.chargeT > 0) {
		  baseMap = BOSS_TEX.attackA;
		}

		mat.map = baseMap;

		// hurtëŠ” í”„ë ˆì„ì„ ë°”ê¾¸ì§€ ë§ê³  â€œë¶‰ì€ìƒ‰ íƒ€ê²©â€ë§Œ
		if (b.hurtT > 0) {
		  mat.color.setHex(0xff6b6b);
		} else {
		  mat.color.setHex(0xffffff);
		}

	
      mat.needsUpdate = true;

      
// íŒ¨í„´ ê°±ì‹ (ë‚œì´ë„â†‘ì¼ìˆ˜ë¡ ë” ìì£¼/ë” ë‹¤ì–‘)
const rateMul = (b.rateMul || 1.0);
b.patternCd -= dt * rateMul;
if(b.patternCd <= 0){
  b.pattern = chooseBossPattern(b.diff);
  b.patternCd = (Math.max(2.0, 3.6 - b.diff*0.12) * rand(0.85, 1.2)) / rateMul;
}

      // ë°œì‚¬
      if(game.state === "boss"){
        b.fireCd -= dt;
        if(b.fireCd <= 0){
          fireBoss(b);
        }
      }

      // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ(ëŒ€ì‹œ ê³µê²©/í”¼ê²©)
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const bx = b.x - b.hitW*0.5;
      const by = b.y - b.hitH*0.5;

      if(aabbIntersect(px,py,player.w,player.h, bx,by,b.hitW,b.hitH)){
        if(player.dashT > 0){
          bossTakeHit(b, player.x + player.facing*0.35, player.y + 0.4);
        }else{
          hurtPlayer(b.x);
        }
      }
    }

    function updateBossBullets(dt){
      if(world.bossBullets.length === 0) return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(let i=world.bossBullets.length-1; i>=0; i--){
        const bb = world.bossBullets[i];
        bb.life -= dt;

        // ì•½ê°„ í”ë“¤ë¦¬ëŠ” ê±°í’ˆ ëŠë‚Œ
        bb.wob += dt * 2.2;
        const wobV = Math.sin(bb.wob) * 0.55;

        if(bb.homing){
          const dy = (player.y - bb.y);
          bb.vy += clamp(dy*0.8, -6, 6) * dt * (0.7 + (world.boss?.diff||1)*0.08);
        }

        bb.x += bb.vx * dt;
        bb.y += (bb.vy + wobV) * dt;

        if(bb.mesh){
          bb.mesh.position.x = bb.x;
          bb.mesh.position.y = bb.y;
          bb.mesh.rotation.z += bb.spin * dt * 0.2;
          const s = 1.0 + Math.sin(bb.wob*1.7)*0.04;
          bb.mesh.scale.set(s,s,1);
        }

        // ì¶©ëŒ
        const bx = bb.x - bb.r;
        const by = bb.y - bb.r;
        if(aabbIntersect(px,py,player.w,player.h, bx,by,bb.r*2,bb.r*2)){
          hurtPlayer(bb.x);
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
          continue;
        }

        // ìˆ˜ëª…/í™”ë©´ ë°–
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;
        const minX = camX - viewW/2 - 4;
        const maxX = camX + viewW/2 + 4;
        const minY = camY - viewH/2 - 4;
        const maxY = camY + viewH/2 + 4;

        if(bb.life <= 0 || bb.x < minX || bb.x > maxX || bb.y < minY || bb.y > maxY){
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
        }
      }
    }

    
    // ----------------------------
    // ì¶”ë½(í™”ë©´ ì•„ë˜) => íŒ¡! => ë¦¬ìŠ¤íƒ€íŠ¸
    // ----------------------------
    function startRespawn(reason=""){
      const wasBoss = (game.state === "boss" || game.state === "bossIntro");
      if(game.state !== "play" && !wasBoss) return;
      game.respawnBoss = wasBoss;
      game.state = "respawn";
      game.t = RESPAWN_DELAY;

      // (ì‚¬ìš©ì ì„ íƒ) ì‚¬ë§í•˜ë©´ ë¬´ì¡°ê±´ HP 5ë¡œ íšŒë³µ
      game.forceFullHP = true;

      // ê³¼í•œ í­ë°œ ëŒ€ì‹  "ì•„ì‰¬ìš´" ì—°ì¶œ + ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ëª¨ì…˜
      spawnDeathPoof(player.x, player.y);
      SFX.death();
      screenShake(0.08, 0.12);

      // í”Œë ˆì´ì–´ ìˆ¨ê¸°ê³  ì‚¬ë§ ìŠ¤í”„ë¼ì´íŠ¸ í‘œì‹œ
      playerSprite.visible = false;
      beginDeathAnim(player.x, player.y + 0.08, player.facing);

      showToast(reason || "ì‚¬ë§...", 900);
    }

    function checkFallDeath(){
      if(game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro") return;

      const viewBottom = camY + (camera.bottom / camera.zoom);

      // í™”ë©´ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ ë¦¬ìŠ¤íƒ€íŠ¸
      if(player.y + player.h*0.5 < viewBottom - 0.8){
        startRespawn("ì¶”ë½! íŒ¡!");
        return;
      }

      // ì•ˆì „ì¥ì¹˜(ì›”ë“œ ë°”ë‹¥ ì•„ë˜)
      if(player.y < world.killY){
        startRespawn("ì¶”ë½! íŒ¡!");
        return;
      }
    }

// ----------------------------
    // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
    // ----------------------------
    function updateParticles(dt){
      for(const p of world.particles){
        p.life -= dt;
        if(p.life <= 0){
          scene.remove(p.mesh);
          p.dead = true;
          continue;
        }

        if(p.kind==="firework"){
          // í­ì£½: ë“œë˜ê·¸ + ì¤‘ë ¥
          p.vx *= p.drag;
          p.vy *= p.drag;
          p.vy += (GRAVITY_DOWN*0.20)*dt;
        }else if(p.kind==="petal" || p.kind==="petalRain"){
          p.vy += (GRAVITY_DOWN*0.18)*dt;
          const sway = Math.sin((performance.now()*0.001) * (p.sway||8) + p.x*1.3) * 0.55;
          p.vx += sway * dt;
        }else if(p.kind==="popFlash"){
          // í”Œë˜ì‹œ: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="spawnRing"){
          // ë“±ì¥ ë§: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="spawnRingSmall"){
          // ì‚¬ë§ ì”ê´‘ ë§: ìœ„ì¹˜ ê³ ì •(ì¤‘ë ¥ X)
        }else if(p.kind==="popSpark"){
          // íŒ¡! ìŠ¤íŒŒí¬: ì§§ê²Œ íŠ•ê¸°ê³  ì‚¬ë¼ì§
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += (GRAVITY_DOWN*0.15)*dt;
        }else{
          p.vy += (GRAVITY_DOWN*0.35)*dt;
        }

        p.x += p.vx*dt;
        p.y += p.vy*dt;

        p.mesh.position.set(p.x, p.y, p.mesh.position.z);
        if(p.spin) p.mesh.rotation.z += p.spin*dt;
        // í˜ì´ë“œ/ìŠ¤ì¼€ì¼
        if(p.kind==="popFlash"){
          const k = 1 - clamp(p.life/0.22, 0, 1);
          p.mesh.scale.setScalar(2.1 + k*6.0);
        }else if(p.kind==="spawnRing"){
          const k = 1 - clamp(p.life/0.34, 0, 1);
          p.mesh.scale.setScalar(0.85 + k*2.4);
        }else if(p.kind==="spawnRingSmall"){
          const k = 1 - clamp(p.life/0.26, 0, 1);
          p.mesh.scale.setScalar(0.55 + k*1.6);
        }

        let fadeBase = 0.55;
        if(p.kind==="petal" || p.kind==="petalRain") fadeBase = 2.2;
        else if(p.kind==="firework") fadeBase = 1.6;
        else if(p.kind==="popFlash") fadeBase = 0.22;
        else if(p.kind==="spawnRing") fadeBase = 0.34;
        else if(p.kind==="spawnRingSmall") fadeBase = 0.26;
        else if(p.kind==="popSpark") fadeBase = 0.45;
        p.mesh.material.opacity = clamp(p.life/fadeBase, 0, 1);
      }
      world.particles = world.particles.filter(p=>!p.dead);
    }

    function updateAfterimages(dt){
      for(const a of world.afterimages){
        a.life -= dt;
        if(a.life <= 0){
          scene.remove(a.sp);
          a.dead = true;
          continue;
        }
        a.sp.material.opacity = clamp(a.life / 0.22, 0, 1) * 0.35;
      }
      world.afterimages = world.afterimages.filter(a=>!a.dead);
    }

    // ----------------------------
    // ì¹´ë©”ë¼/ë°°ê²½
    // ----------------------------
    let camX=0, camY=0;
    let perfT=0;
    let camZoom=1.0;

    function updateCamera(dt){
      const lookAhead = clamp(player.vx*0.08, -1.2, 1.2);
      const targetX = player.x + lookAhead + (player.facing*0.25);
      let targetY = player.y + 1.1;
      const minCamY = (world.groundTop ?? -0.6) + 1.1;
      if(targetY < minCamY) targetY = minCamY;

      camX = lerp(camX, targetX, 1 - Math.exp(-7.5*dt));
      camY = lerp(camY, targetY, 1 - Math.exp(-7.0*dt));

      if(shakeT > 0){
        shakeT = Math.max(0, shakeT - dt);
        const s = (shakeT>0) ? shakeP : 0;
        camX += rand(-1,1)*s;
        camY += rand(-1,1)*s;
        shakeP *= 0.92;
      }else{
        shakeP = 0;
      }

      camera.position.set(camX, camY, 10);

      const speed = Math.abs(player.vx) + Math.abs(player.vy)*0.15;
      const dashBoost = (player.dashT > 0) ? 0.12 : 0;
      const targetZoom = clamp(1.02 - speed*0.008 - dashBoost, 0.84, 1.08);
      camZoom = lerp(camZoom, targetZoom, 1 - Math.exp(-6.5*dt));
      camera.zoom = camZoom;
      camera.updateProjectionMatrix();

      bgTex.offset.x = camX * 0.02;
      bgTex.offset.y = camY * 0.01;

      waterTex.offset.x = camX * 0.04;
      waterTex.offset.y = Math.sin(perfT*0.8)*0.02;
    }

    // ----------------------------
    // ë ˆë²¨ ì‹œì‘/ë¦¬ì…‹
    // ----------------------------
    function resetPlayer(){
      player.vx = 0; player.vy = 0;
      player.facing = 1;

      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;
      player.jumpHold = 0;

      player.dashT = 0;
      player.dashCd = 0;
      player.dashTrailT = 0;
      player.dashCharges = DASH_CHARGES_MAX;

      player.invuln = 0;
      player.hurtT = 0;

      player.isDucking = false;
      player.isClimbing = false;
      player.ladderLock = 0;

      player.slideT = 0;
      player.slideCd = 0;

      player.wallDir = 0;
      player.wallGrace = 0;

      player.landSquashT = 0;
      player.idleStill = 0;
      player.state = "idle";
      player.animT = 0;
      player.duckStepT = 0;

      player.h = STAND_H;

      playerSprite.material.opacity = 1.0;
      setPlayerTex(TEX.idle);
    }

    function startLevel(level, hardReset=false, seedOverride=null, fromDeath=false){
      showBigMsg(false);
      setBossHUD(false);
      game.level = level;
      game.state = "play";
      game.t = 0;
      game.flowerRainT = 0;
      game.fireworkT = 0;

      // ì •ì±…: HP
      if(hardReset || !policy.keepHP || game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "â¤â¤â¤â¤â¤";
        game.forceFullHP = false;
      }else{
        // ìœ ì§€ ì‹œ í˜„ì¬ hp ê·¸ëŒ€ë¡œ
        $hearts.textContent = "â¤".repeat(Math.max(0, player.hp)) + "â™¡".repeat(Math.max(0, 5-player.hp));
      }

      // ì •ì±…: ì½”ì¸
      if(hardReset || !policy.keepCoins){
        world.totalCoinsRun = 0;
      }


      // ë ˆë²¨ ì‹œë“œ:
      //  - ë ˆë²¨ í´ë¦¬ì–´(ë ˆë²¨ ì¦ê°€) ì‹œ: ë‚˜ë…¸ì´ˆ ê¸°ë°˜ìœ¼ë¡œ í° ëœë¤ ë³€í™”
      //  - ì¶”ë½/ë¦¬ìŠ¤íƒ€íŠ¸(fromDeath) ì‹œ: ë™ì¼ ì‹œë“œë¡œ ë™ì¼ ë§µ ì¬ìƒì„±
      if(seedOverride != null){
        game.levelSeed = (seedOverride >>> 0) || 1;
        seedRng(game.levelSeed);
      }else{
        game.levelSeed = seedFromNano((level * 0x9e3779b9) >>> 0);
      }

      // ì¶”ë½ ë¦¬ìŠ¤íƒ€íŠ¸ ì‹œ ì½”ì¸ íŒŒë° ë°©ì§€: ë ˆë²¨ ì‹œì‘ ì‹œì ìœ¼ë¡œ ë˜ëŒë¦¼
      if(!fromDeath){
        world.totalCoinsRunAtLevelStart = world.totalCoinsRun;
      }else{
        world.totalCoinsRun = world.totalCoinsRunAtLevelStart;
      }

      buildRandomLevel(level);

      // ì‹œì‘ ìœ„ì¹˜(ë§µ ìŠ¤í° ìš°ì„ )
      const sp = world.currentMap?.spawn;
      player.x = (sp && Number.isFinite(sp.x)) ? sp.x : -15.5;
      player.y = (sp && Number.isFinite(sp.y)) ? sp.y : 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // "ë¿…" ë“±ì¥ ì´í™íŠ¸ + ëª¨ì…˜
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;
      showToast(fromDeath ? "ë¦¬ìŠ¤íƒ€íŠ¸!" : `ë ˆë²¨ ${level} ì‹œì‘!`, fromDeath ? 650 : 900);
    }

    // ----------------------------
    // ë£¨í”„(ê³ ì • íƒ€ì„ìŠ¤í…)
    // ----------------------------
    const fixed = 1/120;
    let acc = 0;
    let last = performance.now()/1000;

    function step(dt){
      if(toastT > 0){
        toastT -= dt;
        if(toastT <= 0) $toast.style.opacity = "0";
      }

      // DEV ì—ë””í„°ê°€ ì¼œì ¸ìˆìœ¼ë©´ ê²Œì„ ë¡œì§ì„ ì¼ì‹œì •ì§€í•˜ê³ , ì—ë””í„° ë Œë”/ì…ë ¥ë§Œ ì²˜ë¦¬
      if(window.__DEV_EDITOR && window.__DEV_EDITOR.enabled){
        window.__DEV_EDITOR.step(dt);
        // ì…ë ¥ í”Œë˜ê·¸ ì”ìƒ ë°©ì§€
        input.jumpPressed = false;
        input.jumpReleased = false;
        input.dashPressed = false;
        updateDebugOverlay();
        return;
      }

      if(game.state === "celebrate"){
        game.t -= dt;

        // ì—°ì¶œ ì¤‘ ê½ƒë¹„ + í­ì£½ ì§€ì†
        game.flowerRainT -= dt;
        game.fireworkT -= dt;

        // í˜„ì¬ ë·° í¬ê¸° ì¶”ì •
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;

        if(game.flowerRainT <= 0){
          game.flowerRainT = 0.08;
          spawnFlowerRain(camX, camY, viewW, viewH, 10);
        }
        if(game.fireworkT <= 0){
          game.fireworkT = 0.35;
          spawnFirework(camX + rand(-viewW*0.35, viewW*0.35), camY + rand(0.6, viewH*0.45));
        }

        // ì—°ì¶œ ë™ì•ˆ ìºë¦­í„° ì‚´ì§ ê°ì†
        player.vx *= 0.93;
        player.vy *= 0.93;

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "next";
          game.t = 0.75;
        }
      }else if(game.state === "bossIntro"){
        game.t -= dt;

        // ì¸íŠ¸ë¡œ ì¤‘ì—ë„ ì´ë™/ì í”„/ë²½ì¹˜ê¸° ê°€ëŠ¥(ë°œì‚¬ë§Œ ì ê¹ ëŒ€ê¸°)
        updatePlayer(dt);
        updateBoss(dt);

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "boss";
          showToast("START! (ëŒ€ì‹œë¡œ ê³ ë˜ ëª¸í†µì— ë°•ì¹˜ê¸°)", 900);
        }
      }else if(game.state === "boss"){
        updatePlayer(dt);
        updateBoss(dt);
        updateBossBullets(dt);
      }else if(game.state === "bossDefeat"){
        game.t -= dt;

        // ê²©íŒŒ ì—°ì¶œ(í­ì£½ ì¡°ê¸ˆ ë”)
        game.fireworkT -= dt;
        if(game.fireworkT <= 0){
          game.fireworkT = 0.22;
          spawnFirework(camX + rand(-2.2, 2.2), camY + rand(1.0, 4.4));
        }

        // ë³´ìŠ¤ ì„œì„œíˆ ì‚¬ë¼ì§
        if(world.boss?.mesh){
          const a = clamp(game.t/2.3, 0, 1);
          world.boss.mesh.material.opacity = a;
          world.boss.mesh.material.needsUpdate = true;
        }

        // ìºë¦­í„° ê°ì†
        player.vx *= 0.95;
        player.vy *= 0.95;

        if(game.t <= 0){
          showBigMsg(false);
          setBossHUD(false);
          // ë‹¤ìŒ ë ˆë²¨ ì§„í–‰
          startLevel(game.pendingNextLevel, false);
          return;
        }
      }else if(game.state === "next"){
        game.t -= dt;
        if(game.t <= 0){
          startLevel(game.level + 1, false);
        }
      }else if(game.state === "respawn"){
        game.t -= dt;

        // ì—°ì¶œ ë™ì•ˆ ìºë¦­í„° ê°ì†(ì…€ë ˆìŠ¤íŠ¸ ëŠë‚Œ)
        player.vx *= 0.88;
        player.vy *= 0.88;

        if(game.t <= 0){
          // ì‚¬ë§ ìŠ¤í”„ë¼ì´íŠ¸ ì •ë¦¬(í˜¹ì‹œ ë‚¨ì•„ìˆìœ¼ë©´)
          endDeathAnim();

          if(game.respawnBoss){

				/*const diff = Math.max(1, (game.bossDifficulty|0));
				const kind = (diff % 2 === 0) ? 'dragon' : 'whale';
				game.respawnBoss = false;
				game.state = "bossIntro";
				game.t = 0.9;

				buildBossArena(diff, kind);
				$stageText.textContent = `BOSS Lv ${diff} (${kind === 'dragon' ? 'ë“œë˜ê³¤' : 'ê³ ë˜'})`;
				showBigMsg(true, kind === 'dragon' ? `BOSS ì¬ë„ì „! ìš”ë€í•œ ë“œë˜ê³¤ (Lv ${diff})` : `BOSS ì¬ë„ì „! ê±°ëŒ€í•œ ê³ ë˜ (Lv ${diff})`);
				showToast(kind === 'dragon' ? "ë‹¤ì‹œ ë„ì „! ë¶ˆê½ƒì„ ì¡°ì‹¬!" : "ë‹¤ì‹œ ë„ì „!", 900);
				return;
				*/
				const diff = Math.max(1, (game.bossDifficulty|0));

				// 1: ê³ ë˜, 2: ë“œë˜ê³¤, 3: ë¬¸ì–´(3ì˜ ë°°ìˆ˜)
				const kind =
				  (diff % 3 === 1) ? 'whale' :
				  (diff % 3 === 2) ? 'dragon' :
									'octopus';

				game.respawnBoss = false;
				game.state = "bossIntro";
				game.t = 0.9;

				buildBossArena(diff, kind);

				const kindKo = (kind === 'dragon') ? 'ë“œë˜ê³¤' : (kind === 'octopus') ? 'ë¬¸ì–´' : 'ê³ ë˜';
				$stageText.textContent = `BOSS Lv ${diff} (${kindKo})`;

				const introMsg =
				  (kind === 'dragon')  ? `BOSS ì¬ë„ì „! ìš”ë€í•œ ë“œë˜ê³¤ (Lv ${diff})` :
				  (kind === 'octopus') ? `BOSS ì¬ë„ì „! ëŠë¦¿ëŠë¦¿ ë¬¸ì–´ (Lv ${diff})` :
										 `BOSS ì¬ë„ì „! ê±°ëŒ€í•œ ê³ ë˜ (Lv ${diff})`;

				showBigMsg(true, introMsg);

				const toastMsg =
				  (kind === 'dragon')  ? "ë‹¤ì‹œ ë„ì „! ë¶ˆê½ƒì„ ì¡°ì‹¬!" :
				  (kind === 'octopus') ? "ë‹¤ì‹œ ë„ì „! ì´ˆë¡ ë¬¼ë°©ìš¸ ì¡°ì‹¬!" :
										 "ë‹¤ì‹œ ë„ì „!";

				showToast(toastMsg, 900);
				return;
          }

          startLevel(game.level, false, game.levelSeed, true);
          return;
        }
      }else{
        updatePlayer(dt);
        updateSprings();
        updateEnemies(dt);
        updateCoins(dt);
        updateGoal();
      }

      updateParticles(dt);
      updateAfterimages(dt);
      updateDeathAnim(dt);

      input.jumpPressed = false;
      input.jumpReleased = false;
      input.dashPressed = false;

      updateCamera(dt);

      if(game.state === "play" || game.state === "boss" || game.state === "bossIntro") checkFallDeath();
      updateDebugOverlay();
    }

    function animate(){
      const now = performance.now()/1000;
      let dt = now - last;
      last = now;

      dt = clamp(dt, 0, 0.05);
      acc += dt;
      perfT += dt;

      while(acc >= fixed){
        step(fixed);
        acc -= fixed;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }


    // ----------------------------
    // DEV ë§µ ì—ë””í„° (F2 í† ê¸€)
    //  - ë§µ ì œì‘ â†’ JSON ë‹¤ìš´ë¡œë“œ(ë§µ/íŒ©)
    //  - ì €ì¥(LocalStorage) â†’ ê²Œì„ì—ì„œ ì¦‰ì‹œ ì‚¬ìš©
    // ----------------------------
    (function initDevMapEditor(){
      const $panel = document.getElementById("devPanel");
      const $toggle = document.getElementById("devToggle");
      const $test = document.getElementById("devTest");
      const $status = document.getElementById("devStatus");
      const $tools = document.getElementById("devTools");
      const $props = document.getElementById("devProps");
      const $mapList = document.getElementById("devMapList");
      const $mapInfo = document.getElementById("devMapInfo");
      const $snap = document.getElementById("devSnap");
      const $grid = document.getElementById("devGrid");
      const $freeCam = document.getElementById("devFreeCam");
      const $mini = document.getElementById("devMiniMap");
      const $importFile = document.getElementById("devImportFile");
      const $btnSave = document.getElementById("devSave");
      const $btnNew = document.getElementById("devNew");
      const $btnDup = document.getElementById("devDup");
      const $btnDel = document.getElementById("devDel");
      const $btnExportMap = document.getElementById("devExportMap");
      const $btnExportPack = document.getElementById("devExportPack");
      const $toast2 = document.getElementById("devToast2");
      const $tabBar = document.getElementById("devTabs");
      const $tabButtons = $tabBar ? [...$tabBar.querySelectorAll(".tab")] : [];
      const $tabPages = $panel ? [...$panel.querySelectorAll(".tabPage")] : [];

      if(!$panel || !$mini) return;

      const miniCtx = $mini.getContext("2d");

      function toast2(msg, ms=900){
        if(!$toast2) return;
        $toast2.textContent = msg;
        $toast2.style.opacity = "1";
        clearTimeout(toast2._t);
        toast2._t = setTimeout(()=>{ $toast2.style.opacity = "0"; }, ms);
      }

      function downloadJson(filename, obj){
        const s = JSON.stringify(obj, null, 2);
        const blob = new Blob([s], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 500);
      }

      function ensurePack(){
        activePack = normalizePack(activePack || EMBEDDED_MAP_PACK);
        if(!activePack.maps.length){
          activePack.maps.push(normalizeMap({ name:"ìƒˆ ë§µ" }));
        }
        return activePack;
      }

      const state = {
        enabled: false,
        tool: "platform",
        tab: "edit",
        snap: true,
        grid: 0.5,
        freeCam: true,
        pack: ensurePack(),
        mapIndex: 0,
        map: null,
        sel: null,
        drag: null,
        camX: 0,
        camY: 0,
        miniDrag: null,
        ghostFill: null,
        ghostLine: null,
        gridLines: null,
        prevGameState: null,
        prevPolicy: null,
      };

      function setTab(id){
        if(!id) return;
        state.tab = id;
        for(const b of $tabButtons){
          b.classList.toggle("on", b.dataset.tabTarget === id);
        }
        for(const p of $tabPages){
          p.classList.toggle("on", p.dataset.tab === id);
        }
      }
      for(const b of $tabButtons){
        b.addEventListener("click", ()=> setTab(b.dataset.tabTarget));
      }
      setTab(state.tab || "edit");

      const TOOLSET = [
        { id:"select",   label:"ì„ íƒ" },
        { id:"platform", label:"í”Œë«í¼" },
        { id:"ladder",   label:"ì‚¬ë‹¤ë¦¬" },
        { id:"coin",     label:"ì½”ì¸" },
        { id:"enemy",    label:"ì " },
        { id:"spring",   label:"ìŠ¤í”„ë§" },
        { id:"spawn",    label:"ìŠ¤í°" },
        { id:"goal",     label:"ê¹ƒë°œ" },
        { id:"delete",   label:"ì‚­ì œ" },
      ];

      function setTool(id){
        state.tool = id;
        [...$tools.querySelectorAll(".tool")].forEach(b=>{
          b.classList.toggle("on", b.dataset.id === id);
        });
        const cur = state.tool;
        const curCursor = (cur === "platform" || cur === "ladder") ? "crosshair" :
                          (cur === "delete") ? "not-allowed" :
                          (cur === "select") ? "pointer" : "copy";
        renderer.domElement.style.cursor = state.enabled ? curCursor : "";
      }

      function syncToggles(){
        state.snap = !!$snap.checked;
        state.grid = Math.max(0.1, Number($grid.value) || 0.5);
        state.freeCam = !!$freeCam.checked;
      }

      function clamp01(v){ return Math.max(0, Math.min(1, v)); }

      function worldFromScreen(clientX, clientY){
        const rect = renderer.domElement.getBoundingClientRect();
        const ndcX = ((clientX - rect.left) / rect.width) * 2 - 1;
        const ndcY = -(((clientY - rect.top) / rect.height) * 2 - 1);
        const v = new THREE.Vector3(ndcX, ndcY, 0);
        v.unproject(camera);
        return { x: v.x, y: v.y };
      }

      function snapVal(v){
        return state.snap ? (Math.round(v / state.grid) * state.grid) : v;
      }

      function ensureGhost(){
        if(state.ghostFill) return;

        const fill = new THREE.Mesh(
          new THREE.PlaneGeometry(1,1),
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.18 })
        );
        fill.position.set(0,0,3.0);
        fill.visible = false;
        scene.add(fill);

        const geom = new THREE.BufferGeometry();
        const pos = new Float32Array(5*3); // loop
        geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        const line = new THREE.Line(
          geom,
          new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.45 })
        );
        line.position.set(0,0,3.01);
        line.visible = false;
        scene.add(line);

        state.ghostFill = fill;
        state.ghostLine = line;
      }

      function setGhostRect(x, y, w, h, on){
        ensureGhost();
        const fill = state.ghostFill;
        const line = state.ghostLine;

        fill.visible = !!on;
        line.visible = !!on;
        if(!on) return;

        fill.scale.set(w, h, 1);
        fill.position.set(x + w/2, y + h/2, 3.0);

        const arr = line.geometry.attributes.position.array;
        // local coords relative to line position (0,0)
        const pts = [
          [x, y], [x+w, y], [x+w, y+h], [x, y+h], [x, y]
        ];
        for(let i=0;i<5;i++){
          arr[i*3+0] = pts[i][0];
          arr[i*3+1] = pts[i][1];
          arr[i*3+2] = 0;
        }
        line.geometry.attributes.position.needsUpdate = true;
      }

      function ensureGridLinesForMap(m){
        if(state.gridLines){
          scene.remove(state.gridLines);
          state.gridLines.geometry.dispose();
          state.gridLines.material.dispose();
          state.gridLines = null;
        }
        // ë‹¨ìˆœ ê·¸ë¦¬ë“œ: ë§µ ë²”ìœ„ ê¸°ë°˜
        const b = computeBounds(m);
        const step = Math.max(0.5, state.grid);
        const minX = Math.floor((b.minX - 6)/step)*step;
        const maxX = Math.ceil((b.maxX + 6)/step)*step;
        const minY = Math.floor((b.minY - 6)/step)*step;
        const maxY = Math.ceil((b.maxY + 6)/step)*step;

        const lines = [];
        for(let x=minX; x<=maxX+1e-6; x+=step){
          lines.push(x, minY, 0,  x, maxY, 0);
        }
        for(let y=minY; y<=maxY+1e-6; y+=step){
          lines.push(minX, y, 0,  maxX, y, 0);
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(lines), 3));
        const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.12 });
        const grid = new THREE.LineSegments(geom, mat);
        grid.position.z = 2.95;
        grid.frustumCulled = false;
        scene.add(grid);
        state.gridLines = grid;
      }

      function computeBounds(m){
        const g = m.ground;
        let minX = g.x, maxX = g.x+g.w;
        let minY = g.y, maxY = g.y+g.h;

        const expandRect = (x,y,w,h)=>{
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x+w);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y+h);
        };
        const expandPt = (x,y)=>{
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        };

        for(const p of m.platforms) expandRect(p.x,p.y,p.w,p.h);
        for(const l of m.ladders) expandRect(l.x,l.y,l.w,l.h);
        for(const c of m.coins) expandPt(c.x,c.y);
        for(const e of m.enemies) expandPt(e.x,e.y);
        for(const s of m.springs) expandPt(s.x,s.y);
        expandPt(m.spawn.x, m.spawn.y);
        expandPt(m.goal.x, m.goal.y);

        // padding
        const groundTop = g.y + g.h;
        minY = Math.max(minY, groundTop);
        const padX = 8, padYTop = 6, padYBottom = 0;
        return {
          minX: minX - padX,
          maxX: maxX + padX,
          minY: minY - padYBottom,
          maxY: maxY + padYTop
        };
      }

      function drawMiniMap(){
        const m = state.map;
        if(!m) return;

        const W = $mini.width, H = $mini.height;
        miniCtx.clearRect(0,0,W,H);

        // background
        miniCtx.fillStyle = "rgba(255,255,255,0.85)";
        miniCtx.fillRect(0,0,W,H);

        const b = computeBounds(m);
        const spanX = Math.max(1e-6, b.maxX - b.minX);
        const spanY = Math.max(1e-6, b.maxY - b.minY);
        const sx = W / spanX;
        const sy = H / spanY;
        const s = Math.min(sx, sy);
        const ox = (W - spanX*s) * 0.5;
        const oy = (H - spanY*s) * 0.5;

        const toX = x => ox + (x - b.minX) * s;
        const toY = y => H - (oy + (y - b.minY) * s);

        // grid
        const step = Math.max(0.5, state.grid);
        miniCtx.strokeStyle = "rgba(0,0,0,0.06)";
        miniCtx.lineWidth = 1;
        miniCtx.beginPath();
        for(let x = Math.floor(b.minX/step)*step; x <= b.maxX+1e-6; x += step){
          const px = toX(x);
          miniCtx.moveTo(px, 0);
          miniCtx.lineTo(px, H);
        }
        for(let y = Math.floor(b.minY/step)*step; y <= b.maxY+1e-6; y += step){
          const py = toY(y);
          miniCtx.moveTo(0, py);
          miniCtx.lineTo(W, py);
        }
        miniCtx.stroke();

        // ground + platforms
        miniCtx.fillStyle = "rgba(0,0,0,0.20)";
        const g = m.ground;
        const groundTop = g.y + g.h;
        const stripH = Math.max(2, Math.min(4, g.h*s*0.15));
        miniCtx.fillRect(toX(g.x), toY(groundTop) - stripH, g.w*s, stripH);

        miniCtx.fillStyle = "rgba(0,0,0,0.26)";
        for(const p of m.platforms){
          miniCtx.fillRect(toX(p.x), toY(p.y+p.h), p.w*s, p.h*s);
        }

        // ladders
        miniCtx.fillStyle = "rgba(45,123,255,0.25)";
        for(const l of m.ladders){
          miniCtx.fillRect(toX(l.x), toY(l.y+l.h), l.w*s, l.h*s);
        }

        // points
        function dot(x,y,r,fill){
          miniCtx.beginPath();
          miniCtx.arc(toX(x), toY(y), r, 0, Math.PI*2);
          miniCtx.closePath();
          miniCtx.fillStyle = fill;
          miniCtx.fill();
        }
        for(const c of m.coins) dot(c.x,c.y, 3.2, "rgba(255,170,0,0.85)");
        for(const e of m.enemies) dot(e.x,e.y, 3.2, "rgba(255,70,70,0.85)");
        for(const s of m.springs) dot(s.x,s.y, 3.2, "rgba(135,70,255,0.85)");

        dot(m.spawn.x, m.spawn.y, 4.2, "rgba(0,180,90,0.88)");
        dot(m.goal.x,  m.goal.y,  4.2, "rgba(0,0,0,0.75)");

        // camera viewport
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;

        const cx = state.freeCam ? state.camX : camX;
        const cy = state.freeCam ? state.camY : camY;

        const vx = cx - viewW/2;
        const vy = cy - viewH/2;

        miniCtx.strokeStyle = "rgba(0,0,0,0.70)";
        miniCtx.lineWidth = 2;
        miniCtx.strokeRect(toX(vx), toY(vy+viewH), viewW*s, viewH*s);
      }

      function pickAt(x, y){
        const m = state.map;
        if(!m) return null;

        // ìš°ì„ : spawn/goal
        const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
        const thr2 = (state.grid*0.7)*(state.grid*0.7);

        if(dist2(x,y,m.spawn.x,m.spawn.y) < thr2) return { kind:"spawn" };
        if(dist2(x,y,m.goal.x,m.goal.y) < thr2) return { kind:"goal" };

        // points
        const findPoint = (arr, kind)=>{
          let best = -1, bestD = Infinity;
          for(let i=0;i<arr.length;i++){
            const d = dist2(x,y,arr[i].x,arr[i].y);
            if(d < bestD){ bestD = d; best = i; }
          }
          if(best >= 0 && bestD < thr2*2.5) return { kind, i: best };
          return null;
        };
        let hit = findPoint(m.coins, "coin");
        if(hit) return hit;
        hit = findPoint(m.enemies, "enemy");
        if(hit) return hit;
        hit = findPoint(m.springs, "spring");
        if(hit) return hit;

        // rects (platform, ladder)
        const inRect = (r)=> x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h;
        for(let i=m.platforms.length-1;i>=0;i--){
          const p = m.platforms[i];
          if(inRect(p)) return { kind:"platform", i };
        }
        for(let i=m.ladders.length-1;i>=0;i--){
          const l = m.ladders[i];
          if(inRect(l)) return { kind:"ladder", i };
        }
        return null;
      }

      function setSelection(sel){
        state.sel = sel;
        renderProps();
      }

      function renderProps(){
        const sel = state.sel;
        const m = state.map;

        if(!sel || !m){
          $props.innerHTML = `<div class="tag">ì„ íƒëœ ì˜¤ë¸Œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
          return;
        }

        function row(label, value, onChange){
          const div = document.createElement("div");
          div.className = "propRow";
          const lab = document.createElement("label");
          lab.textContent = label;
          const input = document.createElement("input");
          input.type = "number";
          input.step = String(state.grid);
          input.value = String(value);
          input.addEventListener("change", ()=>{
            const v = Number(input.value);
            if(Number.isFinite(v)) onChange(v);
          });
          div.appendChild(lab);
          div.appendChild(input);
          return div;
        }

        $props.innerHTML = "";
        const box = document.createElement("div");
        box.className = "tag";
        box.textContent = `${sel.kind}` + (Number.isFinite(sel.i) ? ` #${sel.i}` : "");
        $props.appendChild(box);

        const apply = ()=>{
          // ladder topLow/topHigh ìë™ ì •í•©(ê¸°ë³¸)
          if(sel.kind === "ladder"){
            const l = m.ladders[sel.i];
            if(l){
              l.topLow = (Number.isFinite(l.topLow) ? l.topLow : l.y);
              l.topHigh = (Number.isFinite(l.topHigh) ? l.topHigh : (l.y+l.h));
            }
          }
          rebuild(false);
        };

        if(sel.kind === "platform"){
          const p = m.platforms[sel.i];
          $props.appendChild(row("x", p.x, v=>{ p.x=v; apply(); }));
          $props.appendChild(row("y", p.y, v=>{ p.y=v; apply(); }));
          $props.appendChild(row("w", p.w, v=>{ p.w=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("h", p.h, v=>{ p.h=Math.max(0.2,v); apply(); }));
        }else if(sel.kind === "ladder"){
          const l = m.ladders[sel.i];
          $props.appendChild(row("x", l.x, v=>{ l.x=v; apply(); }));
          $props.appendChild(row("y", l.y, v=>{ l.y=v; apply(); }));
          $props.appendChild(row("w", l.w, v=>{ l.w=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("h", l.h, v=>{ l.h=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("topLow", l.topLow, v=>{ l.topLow=v; apply(); }));
          $props.appendChild(row("topHigh", l.topHigh, v=>{ l.topHigh=v; apply(); }));
        }else if(sel.kind === "coin"){
          const c = m.coins[sel.i];
          $props.appendChild(row("x", c.x, v=>{ c.x=v; apply(); }));
          $props.appendChild(row("y", c.y, v=>{ c.y=v; apply(); }));
        }else if(sel.kind === "enemy"){
          const e = m.enemies[sel.i];
          $props.appendChild(row("x", e.x, v=>{ e.x=v; apply(); }));
          $props.appendChild(row("y", e.y, v=>{ e.y=v; apply(); }));
        }else if(sel.kind === "spring"){
          const s = m.springs[sel.i];
          $props.appendChild(row("x", s.x, v=>{ s.x=v; apply(); }));
          $props.appendChild(row("y", s.y, v=>{ s.y=v; apply(); }));
        }else if(sel.kind === "spawn"){
          $props.appendChild(row("x", m.spawn.x, v=>{ m.spawn.x=v; apply(); }));
          $props.appendChild(row("y", m.spawn.y, v=>{ m.spawn.y=v; apply(); }));
        }else if(sel.kind === "goal"){
          $props.appendChild(row("x", m.goal.x, v=>{ m.goal.x=v; apply(); }));
          $props.appendChild(row("y", m.goal.y, v=>{ m.goal.y=v; apply(); }));
        }
      }

      function rebuild(alsoUpdateList=true){
        // í˜„ì¬ ë§µì„ ë¹Œë“œ(ê²Œì„ ì›”ë“œë¡œ ë°˜ì˜)
        buildLevelFromJson(state.map, state.mapIndex+1, state.mapIndex, state.pack.maps.length);

        // DEV ëª¨ë“œì—ì„œëŠ” í”Œë ˆì´ì–´ë¥¼ ë©€ë¦¬ ë³´ë‚´ì„œ ì½”ì¸/ì¶©ëŒ ì˜í–¥ ìµœì†Œí™”
        player.x = 9999;
        player.y = 9999;
        player.vx = 0; player.vy = 0;

        // ì¹´ë©”ë¼
        if(state.freeCam){
          camera.position.set(state.camX, state.camY, 10);
          camX = state.camX; camY = state.camY;
        }

        setGhostRect(0,0,1,1,false);
        ensureGridLinesForMap(state.map);

        if(alsoUpdateList) renderMapList();
        drawMiniMap();
      }

      function openDev(){
        syncToggles();
        state.pack = ensurePack();
        state.mapIndex = Math.max(0, Math.min(state.mapIndex, state.pack.maps.length-1));
        state.map = deepClone(state.pack.maps[state.mapIndex]);
        state.sel = null;

        state.prevGameState = game.state;
        game.state = "dev";

        // ì •ì±… ì˜í–¥ ìµœì†Œí™”(DEV ì¤‘ ì½”ì¸ ëˆ„ì  ë“±)
        state.prevPolicy = { ...policy };
        policy.keepCoins = false;
        policy.keepHP = true;

        state.enabled = true;
        $panel.style.display = "block";
        $panel.setAttribute("aria-hidden","false");
        $status.textContent = "ON";
        $status.style.background = "rgba(45,123,255,.14)";
        $mapInfo.textContent = `maps:${state.pack.maps.length}`;

        // ì¹´ë©”ë¼ ì´ˆê¸°
        state.camX = camX;
        state.camY = camY;

        // íˆ´ë°” ë Œë”
        if(!$tools.dataset.ready){
          $tools.dataset.ready = "1";
          $tools.innerHTML = "";
          for(const t of TOOLSET){
            const b = document.createElement("button");
            b.className = "tool";
            b.textContent = t.label;
            b.dataset.id = t.id;
            b.addEventListener("click", ()=>{
              setTool(t.id);
              toast2(`ë„êµ¬: ${t.label}`, 700);
            });
            $tools.appendChild(b);
          }
        }
        setTool(state.tool);

        rebuild(true);
        toast2("DEV ë§µ ì—ë””í„° ON (F2ë¡œ ì¢…ë£Œ)", 1100);
      }

      function closeDev(restart=true){
        if(!state.enabled) return;

        state.enabled = false;
        $panel.style.display = "none";
        $panel.setAttribute("aria-hidden","true");
        $status.textContent = "OFF";
        $status.style.background = "";

        // ì •ì±… ë³µì›
        if(state.prevPolicy){
          Object.assign(policy, state.prevPolicy);
        }

        // DEV ë³´ì¡° ì˜¤ë¸Œì íŠ¸ ì •ë¦¬(ghostëŠ” ë‚¨ê²¨ë„ ë¬´ë°©í•˜ë‚˜, ê¹”ë”íˆ)
        if(state.gridLines){
          scene.remove(state.gridLines);
          state.gridLines.geometry.dispose();
          state.gridLines.material.dispose();
          state.gridLines = null;
        }
        setGhostRect(0,0,1,1,false);
        renderer.domElement.style.cursor = "";

        // ê²Œì„ ë³µì›
        game.state = state.prevGameState || "play";
        playerSprite.visible = true;

        if(restart){
          // í˜„ì¬ ë ˆë²¨ ë‹¤ì‹œ ë¹Œë“œí•´ì„œ ì¦‰ì‹œ í”Œë ˆì´ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
          startLevel(game.level, false, game.levelSeed);
        }

        toast2("DEV OFF", 700);
      }

      function toggleDev(){
        if(state.enabled) closeDev(true);
        else openDev();
      }

      // ìº”ë²„ìŠ¤ ì…ë ¥
      renderer.domElement.addEventListener("contextmenu", (e)=>{ if(state.enabled) e.preventDefault(); });

      renderer.domElement.addEventListener("pointerdown", (e)=>{
        if(!state.enabled) return;

        syncToggles();

        // ìš°í´ë¦­: ì‚­ì œ
        if(e.button === 2){
          const p = worldFromScreen(e.clientX, e.clientY);
          const wx = snapVal(p.x), wy = snapVal(p.y);
          const sel = pickAt(wx, wy);
          if(sel){
            removeSelection(sel);
            setSelection(null);
            rebuild(false);
            toast2("ì‚­ì œ", 500);
          }else{
            toast2("ì‚­ì œ ëŒ€ìƒ ì—†ìŒ", 500);
          }
          e.preventDefault();
          return;
        }

        // ë¯¸ë‹ˆë§µ ë“œë˜ê·¸ëŠ” ë³„ë„
        if(e.target === $mini){
          return;
        }

        const p = worldFromScreen(e.clientX, e.clientY);
        const wx = snapVal(p.x), wy = snapVal(p.y);
        if(state.tool === "select"){
          const sel = pickAt(wx, wy);
          setSelection(sel);
          toast2(sel ? `ì„ íƒ: ${sel.kind}` : "ì„ íƒ ì—†ìŒ", 650);
          e.preventDefault();
          return;
        }

        if(state.tool === "platform" || state.tool === "ladder"){
          state.drag = { x0: wx, y0: wy, x1: wx, y1: wy, kind: state.tool };
          setGhostRect(wx, wy, 0.001, 0.001, true);
          e.preventDefault();
          return;
        }

        if(state.tool === "delete"){
          const sel = pickAt(wx, wy);
          if(sel){
            removeSelection(sel);
            setSelection(null);
            rebuild(false);
            toast2("ì‚­ì œ", 500);
          }else{
            toast2("ì‚­ì œ ëŒ€ìƒ ì—†ìŒ", 500);
          }
          e.preventDefault();
          return;
        }

        // í¬ì¸íŠ¸ ë°°ì¹˜
        placePoint(state.tool, wx, wy);
        e.preventDefault();
      });

      renderer.domElement.addEventListener("pointermove", (e)=>{
        if(!state.enabled) return;
        if(!state.drag) return;
        const p = worldFromScreen(e.clientX, e.clientY);
        const wx = snapVal(p.x), wy = snapVal(p.y);
        state.drag.x1 = wx;
        state.drag.y1 = wy;

        const x = Math.min(state.drag.x0, state.drag.x1);
        const y = Math.min(state.drag.y0, state.drag.y1);
        const w = Math.max(0.001, Math.abs(state.drag.x1 - state.drag.x0));
        const h = Math.max(0.001, Math.abs(state.drag.y1 - state.drag.y0));
        setGhostRect(x, y, w, h, true);
      });

      renderer.domElement.addEventListener("pointerup", (e)=>{
        if(!state.enabled) return;
        if(!state.drag) return;

        const d = state.drag;
        state.drag = null;

        const x = Math.min(d.x0, d.x1);
        const y = Math.min(d.y0, d.y1);
        const w = Math.abs(d.x1 - d.x0);
        const h = Math.abs(d.y1 - d.y0);

        if(w < 0.15 || h < 0.15){
          setGhostRect(0,0,1,1,false);
          toast2("ë„ˆë¬´ ì‘ì•„ì„œ ì·¨ì†Œ", 650);
          return;
        }

        if(d.kind === "platform"){
          state.map.platforms.push({ x, y, w, h });
          setSelection({ kind:"platform", i: state.map.platforms.length-1 });
          rebuild(false);
          toast2("í”Œë«í¼ ì¶”ê°€", 650);
        }else if(d.kind === "ladder"){
          state.map.ladders.push({ x, y, w, h, topLow:y, topHigh:(y+h) });
          setSelection({ kind:"ladder", i: state.map.ladders.length-1 });
          rebuild(false);
          toast2("ì‚¬ë‹¤ë¦¬ ì¶”ê°€", 650);
        }
      });

      function removeSelection(sel){
        const m = state.map;
        if(!m || !sel) return;
        if(sel.kind === "platform") m.platforms.splice(sel.i,1);
        else if(sel.kind === "ladder") m.ladders.splice(sel.i,1);
        else if(sel.kind === "coin") m.coins.splice(sel.i,1);
        else if(sel.kind === "enemy") m.enemies.splice(sel.i,1);
        else if(sel.kind === "spring") m.springs.splice(sel.i,1);
        else if(sel.kind === "spawn") { /* noop: spawnì€ ì‚­ì œ ëŒ€ì‹  ì´ë™ */ }
        else if(sel.kind === "goal") { /* noop */ }
      }

      function placePoint(kind, x, y){
        const m = state.map;
        if(!m) return;

        if(kind === "coin"){
          m.coins.push({ x, y });
          setSelection({ kind:"coin", i: m.coins.length-1 });
          rebuild(false);
          toast2("ì½”ì¸ ì¶”ê°€", 600);
          return;
        }
        if(kind === "enemy"){
          m.enemies.push({ x, y });
          setSelection({ kind:"enemy", i: m.enemies.length-1 });
          rebuild(false);
          toast2("ì  ì¶”ê°€", 600);
          return;
        }
        if(kind === "spring"){
          m.springs.push({ x, y });
          setSelection({ kind:"spring", i: m.springs.length-1 });
          rebuild(false);
          toast2("ìŠ¤í”„ë§ ì¶”ê°€", 600);
          return;
        }
        if(kind === "spawn"){
          m.spawn.x = x; m.spawn.y = y;
          setSelection({ kind:"spawn" });
          rebuild(false);
          toast2("ìŠ¤í° ì´ë™", 600);
          return;
        }
        if(kind === "goal"){
          m.goal.x = x; m.goal.y = y;
          setSelection({ kind:"goal" });
          rebuild(false);
          toast2("ê¹ƒë°œ ì´ë™", 600);
          return;
        }

        // ê¸°íƒ€: ì„ íƒ
        const sel = pickAt(x, y);
        if(sel){
          setSelection(sel);
          toast2(`ì„ íƒ: ${sel.kind}`, 600);
        }else{
          setSelection(null);
        }
      }

      // ë¯¸ë‹ˆë§µ ë“œë˜ê·¸ë¡œ ì¹´ë©”ë¼ ì´ë™
      $mini.addEventListener("pointerdown", (e)=>{
        if(!state.enabled) return;
        syncToggles();

        const pos = miniMapWorldFromEvent(e);
        if(pos && state.freeCam){
          state.camX = pos.worldX;
          state.camY = pos.worldY;
          camX = pos.worldX; camY = pos.worldY;
          camera.position.set(camX, camY, 10);
          drawMiniMap();
        }

        const rect = $mini.getBoundingClientRect();
        state.miniDrag = { x0: e.clientX - rect.left, y0: e.clientY - rect.top };
        $mini.setPointerCapture(e.pointerId);
      });
      function miniMapWorldFromEvent(e){
        const m = state.map;
        if(!m) return null;
        const rect = $mini.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * ($mini.width / rect.width);
        const my = (e.clientY - rect.top) * ($mini.height / rect.height);

        const b = computeBounds(m);
        const spanX = Math.max(1e-6, b.maxX - b.minX);
        const spanY = Math.max(1e-6, b.maxY - b.minY);
        const sx = $mini.width / spanX;
        const sy = $mini.height / spanY;
        const s = Math.min(sx, sy);
        const ox = ($mini.width - spanX*s) * 0.5;
        const oy = ($mini.height - spanY*s) * 0.5;

        const worldX = b.minX + (mx - ox) / s;
        const worldY = b.minY + (($mini.height - my) - oy) / s;
        return { worldX, worldY };
      }

      $mini.addEventListener("pointermove", (e)=>{
        if(!state.enabled || !state.miniDrag) return;
        const pos = miniMapWorldFromEvent(e);
        if(!pos) return;
        const { worldX, worldY } = pos;

        if(state.freeCam){
          state.camX = worldX;
          state.camY = worldY;
          camX = worldX; camY = worldY;
          camera.position.set(camX, camY, 10);
          drawMiniMap();
        }
      });
      $mini.addEventListener("pointerup", (e)=>{
        if(!state.enabled) return;
        state.miniDrag = null;
      });

      // ë²„íŠ¼/íŒŒì¼ ì´ë²¤íŠ¸
      $toggle.addEventListener("click", ()=> toggleDev());
      $test.addEventListener("click", ()=>{
        // í˜„ì¬ ë§µì„ íŒ©ì— ë°˜ì˜(ë©”ëª¨ë¦¬) í›„ í”Œë ˆì´
        commitCurrentMapToPack();
        closeDev(true);
      });

      $snap.addEventListener("change", ()=>{ syncToggles(); drawMiniMap(); });
      $grid.addEventListener("change", ()=>{ syncToggles(); rebuild(false); });
      $freeCam.addEventListener("change", ()=>{ syncToggles(); drawMiniMap(); });

      function commitCurrentMapToPack(){
        state.pack = ensurePack();
        state.pack.maps[state.mapIndex] = normalizeMap(state.map);
        activePack = normalizePack(state.pack);
      }

      $btnSave.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const ok = savePackToLocalStorage(activePack);
        toast2(ok ? "ì €ì¥ ì™„ë£Œ (LocalStorage)" : "ì €ì¥ ì‹¤íŒ¨", 1000);
        if(ok){
          $mapInfo.textContent = `maps:${activePack.maps.length}`;
        }
      });

      $btnNew.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const nm = normalizeMap({ name:"ìƒˆ ë§µ" });
        activePack.maps.push(nm);
        state.pack = activePack;
        state.mapIndex = activePack.maps.length - 1;
        state.map = deepClone(activePack.maps[state.mapIndex]);
        setSelection(null);
        rebuild(true);
        toast2("ìƒˆ ë§µ ìƒì„±", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnDup.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const cur = activePack.maps[state.mapIndex];
        const copy = normalizeMap(deepClone(cur));
        copy.id = `copy-${Date.now().toString(36)}`;
        copy.name = `${cur.name || "ë§µ"} (copy)`;
        activePack.maps.splice(state.mapIndex+1, 0, copy);
        state.mapIndex++;
        state.map = deepClone(copy);
        setSelection(null);
        rebuild(true);
        toast2("ë³µì œ ì™„ë£Œ", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnDel.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        if(activePack.maps.length <= 1){
          toast2("ìµœì†Œ 1ê°œ ë§µì€ í•„ìš”í•©ë‹ˆë‹¤.", 900);
          return;
        }
        activePack.maps.splice(state.mapIndex, 1);
        state.mapIndex = Math.max(0, state.mapIndex-1);
        state.map = deepClone(activePack.maps[state.mapIndex]);
        setSelection(null);
        rebuild(true);
        toast2("ì‚­ì œ ì™„ë£Œ", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnExportMap.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        downloadJson(`${state.map.id || "map"}.json`, normalizeMap(state.map));
      });
      $btnExportPack.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        downloadJson(`map_pack.json`, normalizePack(activePack));
      });

      $importFile.addEventListener("change", async ()=>{
        const f = $importFile.files && $importFile.files[0];
        $importFile.value = "";
        if(!f) return;
        try{
          const txt = await f.text();
          const obj = JSON.parse(txt);

          // pack or single map
          if(obj && typeof obj === "object" && Array.isArray(obj.maps)){
            activePack = normalizePack(obj);
            state.pack = activePack;
            state.mapIndex = 0;
            state.map = deepClone(activePack.maps[0] || normalizeMap({ name:"ìƒˆ ë§µ" }));
            setSelection(null);
            rebuild(true);
            toast2("ë§µíŒ© ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ", 1000);
            $mapInfo.textContent = `maps:${activePack.maps.length}`;
          }else{
            const m = normalizeMap(obj);
            commitCurrentMapToPack();
            activePack.maps.push(m);
            state.mapIndex = activePack.maps.length-1;
            state.map = deepClone(m);
            setSelection(null);
            rebuild(true);
            toast2("ë§µ ì¶”ê°€ ì™„ë£Œ", 1000);
            $mapInfo.textContent = `maps:${activePack.maps.length}`;
          }
        }catch(_e){
          toast2("JSON íŒŒì‹± ì‹¤íŒ¨", 1000);
        }
      });

      function renderMapList(){
        $mapList.innerHTML = "";
        for(let i=0;i<state.pack.maps.length;i++){
          const m = state.pack.maps[i];
          const el = document.createElement("div");
          el.className = "item" + (i===state.mapIndex ? " on" : "");
          el.innerHTML = `<span>${i+1}. ${m.name || m.id}</span><span class="tag">${m.coins.length}c</span>`;
          el.addEventListener("click", ()=>{
            commitCurrentMapToPack();
            state.mapIndex = i;
            state.map = deepClone(state.pack.maps[i]);
            setSelection(null);
            rebuild(true);
            toast2(`ë§µ ì„ íƒ: ${state.map.name || state.map.id}`, 700);
          });
          $mapList.appendChild(el);
        }
      }

      function stepDev(dt){
        // ì¹´ë©”ë¼ ê³ ì • ëª¨ë“œì¼ ë•Œë§Œ state.camX/Y ì‚¬ìš©
        if(state.enabled && state.freeCam){
          camera.position.set(state.camX, state.camY, 10);
          camX = state.camX; camY = state.camY;
        }
        // ghostëŠ” pointer ì´ë²¤íŠ¸ë¡œ ê°±ì‹ ë¨
        drawMiniMap();
      }

      // ì™¸ë¶€ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ í•¸ë“¤
      window.__DEV_EDITOR = {
        get enabled(){ return state.enabled; },
        step: stepDev,
        toggle: toggleDev
      };

      // í‚¤ ë°”ì¸ë”©
      document.addEventListener("keydown", (e)=>{
        if(e.code === "F2"){
          e.preventDefault();
          toggleDev();
        }
      });

      // ì´ˆê¸° ì•ˆë‚´(í•œ ë²ˆë§Œ)
      toast2("F2: DEV ë§µ ì—ë””í„°", 1400);
    })();


    // ì‹œì‘
    // - ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„: showReadyToStart()ì—ì„œ Start ë²„íŠ¼ í™œì„±í™”
    // - ê²Œì„ ì‹œì‘: Start ë²„íŠ¼ í´ë¦­ â†’ startFromTitle()
    syncPolicyUI(); // ì´ˆê¸° UI ë°˜ì˜(ê²Œì„ ì‹œì‘ì€ ë²„íŠ¼ í´ë¦­ í›„)
  </script>

  <!-- DEV MAP EDITOR UI -->
  <div id="devToast2"></div>
  <div id="devPanel" aria-hidden="true">
    <h3>DEV ë§µ ì—ë””í„° <span class="tag" id="devMapInfo">F2</span></h3>

    <div class="row2">
      <button class="btn primary" id="devToggle">DEV ì¢…ë£Œ(F2)</button>
      <button class="btn" id="devTest">í˜„ì¬ ë§µ í…ŒìŠ¤íŠ¸</button>
      <span class="tag" id="devStatus">OFF</span>
    </div>

    <div class="tabPage on" data-tab="edit">
      <canvas id="devMiniMap" width="640" height="320"></canvas>
    </div>

    <div id="devTabs">
      <button class="tab on" data-tab-target="edit">í¸ì§‘</button>
      <button class="tab" data-tab-target="map">ë§µ</button>
      <button class="tab" data-tab-target="save">ì €ì¥</button>
    </div>

    <div class="tabPage on" data-tab="edit">
      <div class="row2">
        <label class="tag">ìŠ¤ëƒ…</label>
        <input type="checkbox" id="devSnap" checked />
        <label class="tag">ê²©ì</label>
        <input type="number" id="devGrid" value="0.5" step="0.1" min="0.1" style="width:86px;border-radius:10px;border:1px solid rgba(0,0,0,.12);padding:6px 8px;font-size:12px;" />
        <label class="tag">ì¹´ë©”ë¼ ê³ ì •</label>
        <input type="checkbox" id="devFreeCam" checked />
      </div>

      <div id="devTools"></div>

      <div class="row2">
        <span class="tag">ì„ íƒ ì†ì„±</span>
      </div>
      <div id="devProps">
        <div class="tag">ì„ íƒëœ ì˜¤ë¸Œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
      </div>

      <div class="row2">
        <span class="tag">TIP</span>
        <span class="tag">í”Œë«í¼/ì‚¬ë‹¤ë¦¬: ì¢Œí´ë¦­ ë“œë˜ê·¸</span>
        <span class="tag">ì½”ì¸/ì /ìŠ¤í”„ë§/ìŠ¤í°/ê¹ƒë°œ: ì¢Œí´ë¦­</span>
        <span class="tag">ì‚­ì œ: ìš°í´ë¦­</span>
      </div>
    </div>

    <div class="tabPage" data-tab="map">
      <div class="row2">
        <span class="tag">ë§µ ëª©ë¡</span>
      </div>
      <div id="devMapList"></div>

      <div class="row2">
        <button class="btn" id="devNew">ìƒˆ ë§µ</button>
        <button class="btn" id="devDup">ë³µì œ</button>
        <button class="btn danger" id="devDel">ì‚­ì œ</button>
      </div>
    </div>

    <div class="tabPage" data-tab="save">
      <div class="row2">
        <button class="btn" id="devSave">ì €ì¥(LocalStorage)</button>
      </div>

      <div class="row2">
        <button class="btn" id="devExportMap">JSON ë‹¤ìš´ë¡œë“œ(ë§µ)</button>
        <button class="btn" id="devExportPack">JSON ë‹¤ìš´ë¡œë“œ(íŒ©)</button>
        <label class="btn" for="devImportFile" style="cursor:pointer;">JSON ë¶ˆëŸ¬ì˜¤ê¸°</label>
        <input id="devImportFile" type="file" accept="application/json" style="display:none;" />
      </div>
    </div>
  </div>

</body>
</html>
