<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,  viewport-fit=cover ,initial-scale=1 , maximum-scale=1, minimum-scale=1, user-scalable=no" />
  <title>Tiny Hero : Dash & Run</title>
	<!-- Copyright ¬© 2025 Kwak Nae Hun. All rights reserved. -->
  <style>
    :root{
      --bg:#bfe4ff;
      --ink:#1d1d1f;
      --shadow: rgba(0,0,0,.18);
      --hud: rgba(255,255,255,.78);
      --hud2: rgba(255,255,255,.55);
    }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; touch-action:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif; }
    #wrap{ position:fixed; inset:0; }
    canvas{ width:100%; height:100%; display:block; }

    #hud{
      position:fixed; inset:0;
      pointer-events:none;
      color:var(--ink);
      text-shadow: 0 2px 0 rgba(0,0,0,.08);
    }
    #hud .row{
      position:absolute; left:0; right:0;
      display:flex; justify-content:space-between; align-items:center;
      padding: 14px 16px;
      gap: 12px;
    }
    #hud .left, #hud .right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill{
      background: var(--hud);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 999px;
      padding: 8px 12px;
      display:inline-flex; align-items:center; gap:8px;
      backdrop-filter: blur(8px);
    }
    .small{ font-size:12px; opacity:.85; }
    .kbd{
      display:inline-block;
      min-width: 18px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.85);
      box-shadow: 0 2px 0 rgba(0,0,0,.08);
      font-weight: 700;
      font-size: 12px;
      line-height: 1.4;
      margin: 0 2px;
    }
    .clickable{
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
    }
    .onTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(35, 199, 99, .18);
      border: 1px solid rgba(35, 199, 99, .25);
    }
    .offTag{
      font-weight: 900;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255, 99, 99, .18);
      border: 1px solid rgba(255, 99, 99, .25);
    }

    #subtitle{
      position:absolute;
      left: 16px;
      right: 16px;
      bottom: 16px;
      background: var(--hud2);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 10px 30px var(--shadow);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      font-size: 12px;
      line-height: 1.55;
      opacity: 1;
      transform: translateY(0);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
    }
    #subtitle.subHidden{
      opacity:0;
      transform: translateY(10px);
    }
    #infoPill{
      display:none;
      width: 36px; height: 36px;
      padding: 0;
      justify-content:center;
      font-size: 16px;
    }
    #toast{
      position:absolute;
      left:50%; top: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      color:white;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 18px;
      opacity:0;
      transition: opacity .12s ease;
      white-space:nowrap;
      pointer-events:none;
    }

    #bigMsg{
      position:fixed;
      left:50%; top:38%;
      transform: translate(-50%,-50%);
      padding: 18px 22px;
      border-radius: 18px;
      background: rgba(253, 47, 143, .71); //rgba(253, 47, 143, 0.71)
      color: #fff;
      font-weight: 700;
      font-size: 30px;
      letter-spacing: .5px;
      box-shadow: 0 18px 60px rgba(0,0,0,.25);
      opacity: 0;
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
      text-align:center;
      white-space:nowrap;
    }
    #bigMsg.on{
      opacity: 1;
      transform: translate(-50%,-50%) scale(1.02);
    }

    #pauseMsg{
      position:fixed;
      left:50%; top:42%;
      transform: translate(-50%,-50%);
      padding: 14px 20px;
      border-radius: 14px;
      background: rgba(0,0,0,.62);
      color: #fff;
      font-weight: 800;
      font-size: 26px;
      letter-spacing: .4px;
      box-shadow: 0 16px 50px rgba(0,0,0,.28);
      opacity: 0;
      transition: opacity .16s ease, transform .16s ease;
      pointer-events:none;
      text-align:center;
      white-space:nowrap;
    }
    #pauseMsg.on{
      opacity: 1;
      transform: translate(-50%,-50%) scale(1.02);
    }

    #touch{ position:fixed; inset:0; pointer-events:none; display:none; }
    #touch .btn{
      pointer-events:auto;
      width: 64px; height: 64px;
      border-radius: 18px;
      background: rgba(255,255,255,.70);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      backdrop-filter: blur(8px);
    }
    #touch .cluster{ position:absolute; bottom: 16px; display:flex; gap: 10px; }
    #touch .leftCluster{ left: 16px; }
    #touch .rightCluster{ right: 16px; }
    #touch .col{ display:flex; flex-direction:column; gap:10px; }
  
    /* ÌÉÄÏù¥ÌãÄ/Î°úÎî© Ïò§Î≤ÑÎ†àÏù¥ */
    #loader{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      z-index:9999;
      color:#fff;
      overflow:hidden;
    }
    #loader .bg{
      position:absolute; inset:-40px;
      background:url("title_image.png") center/cover no-repeat;
      filter: blur(18px) brightness(0.88) saturate(1.05);
      transform: scale(1.10);
    }
    #loader .shade{
      position:absolute; inset:0;
      background: radial-gradient(circle at 50% 35%, rgba(0,0,0,.25), rgba(0,0,0,.72));
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    #loader .panel{
      position:relative;
      width:min(760px, 92vw);
      padding:18px 18px 16px;
      border-radius:24px;
      background:rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 20px 70px rgba(0,0,0,.46);
      text-align:center;
    }
    #loader .titleArt{
      display:block;
      width:min(680px, 86vw);
      max-height:52vh;
      object-fit:contain;
      margin: 0 auto 14px;
      border-radius:22px;
      box-shadow: 0 16px 55px rgba(0,0,0,.50);
      background: rgba(255,255,255,.05);
    }
    #loader .bar{
      height:12px;
      border-radius:999px;
      background:rgba(255,255,255,.20);
      overflow:hidden;
    }
    #barFill{
      height:100%;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg, rgba(0,255,200,.95), rgba(120,220,255,.95), rgba(180,120,255,.95));
      transition: width .12s ease;
    }
    #loader .small{
      font-size: 12px;
      opacity: .92;
      text-align:center;
      margin-top: 10px;
      color: rgba(255,255,255,.92);
    }
    #loader .actions{
      display:flex;
      justify-content:center;
      margin-top: 12px;
    }
    #btnStart{
      pointer-events:auto;
      font-weight: 900;
      font-size: 18px;
      padding: 12px 20px;
      border-radius: 999px;
      border: 0;
      color: #0c1020;
      background: rgba(255,255,255,.93);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      cursor: pointer;
      transition: transform .12s ease, opacity .12s ease;
    }
    #btnStart:active{ transform: scale(0.98); }
    #btnStart:disabled{
      opacity: 0.45;
      cursor: not-allowed;
      filter: grayscale(0.55);
      box-shadow: none;
    }



    /* Î™®Î∞îÏùº Í∞ÄÎ≥Ä UI */
    @media (max-width: 768px){
      #hud .row{
        padding: calc(10px + env(safe-area-inset-top)) 12px 10px;
        gap: 10px;
      }
      .pill{ padding: 7px 10px; }
      #touch .cluster{ bottom: calc(14px + env(safe-area-inset-bottom)); }
      #touch .leftCluster{ left: calc(14px + env(safe-area-inset-left)); }
      #touch .rightCluster{ right: calc(14px + env(safe-area-inset-right)); }
      #touch .btn{
        width: clamp(52px, 11vw, 82px);
        height: clamp(52px, 11vw, 82px);
        border-radius: clamp(14px, 3.8vw, 22px);
        font-size: clamp(18px, 4.8vw, 30px);
      }
      /* Î™®Î∞îÏùºÏóêÏÑúÎäî ÎèÑÏõÄÎßêÏù¥ Ïª®Ìä∏Î°§ Î≤ÑÌäºÏùÑ Í∞ÄÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù ÏúÑÎ°ú Ïò¨Î¶º */
      #subtitle{ bottom: calc(118px + env(safe-area-inset-bottom)); }
      #infoPill{ width: 34px; height: 34px; font-size: 16px; }
    }
    @media (orientation: landscape) and (max-height: 480px){
      #touch .cluster{ bottom: calc(10px + env(safe-area-inset-bottom)); }
      #subtitle{ bottom: calc(96px + env(safe-area-inset-bottom)); font-size: 11px; }
    }
    @media (max-width: 420px){
      #subtitle{ bottom: calc(138px + env(safe-area-inset-bottom)); }
    }


    /* =========================
       DEV MAP EDITOR (F2)
       ========================= */
    #devPanel{
      position:fixed;
      right:14px;
      top:64px;
      width:min(420px, calc(100vw - 28px));
      max-height: calc(100vh - 92px);
      overflow:auto;
      background: rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 18px 55px rgba(0,0,0,.22);
      border-radius: 16px;
      padding: 12px;
      display:none;
      z-index: 9999;
      pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    #devPanel h3{
      margin: 2px 0 10px;
      font-size: 14px;
      letter-spacing: -0.2px;
    }
    #devTabs{
      display:flex;
      gap:2px;
      flex-wrap:wrap;
      margin: 8px 0 10px;
      padding: 4px;
      border-radius: 12px;
      background: rgba(0,0,0,.04);
      border: 1px solid rgba(0,0,0,.10);
    }
    #devTabs .tab{
      border:1px solid transparent;
      background: transparent;
      border-radius: 10px;
      padding: 7px 12px;
      font-size: 12px;
      cursor:pointer;
      box-shadow: none;
      color: rgba(0,0,0,.72);
    }
    #devTabs .tab.on{
      background: #fff;
      border-color: rgba(0,0,0,.12);
      color: #1d1d1f;
      box-shadow: 0 6px 16px rgba(0,0,0,.08);
    }
    .tabPage{ display:none; }
    .tabPage.on{ display:block; }
    #devPanel .row2{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin: 8px 0;
    }
    #devPanel .btn{
      pointer-events:auto;
      user-select:none;
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.10);
    }
    #devPanel .btn.primary{
      background: rgba(45,123,255,.12);
      border-color: rgba(45,123,255,.35);
    }
    #devPanel .btn.danger{
      background: rgba(255,60,60,.10);
      border-color: rgba(255,60,60,.35);
    }
    #devPanel .btn:active{ transform: translateY(1px); }
    #devPanel .tag{
      font-size: 12px;
      background: rgba(0,0,0,.06);
      border:1px solid rgba(0,0,0,.06);
      padding: 5px 8px;
      border-radius: 999px;
    }
    #devTools{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin: 8px 0 10px;
    }
    #devTools .tool{
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor:pointer;
    }
    #devTools .tool.on{
      background: rgba(45,123,255,.16);
      border-color: rgba(45,123,255,.55);
    }
    #devMiniMap{
      width:100%;
      height: 170px;
      border-radius: 12px;
      background: rgba(0,0,0,.04);
      border:1px solid rgba(0,0,0,.08);
      display:block;
      cursor: grab;
    }
    #devMiniMap:active{ cursor: grabbing; }
    #devProps{
      border:1px dashed rgba(0,0,0,.15);
      border-radius: 12px;
      padding: 10px;
      margin-top: 8px;
      background: rgba(255,255,255,.65);
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 10px;
    }
    #devProps .propRow{
      display:grid;
      grid-template-columns: 76px 1fr;
      align-items:center;
      gap:10px;
      margin: 0;
    }
    #devProps .tag{
      grid-column: 1 / -1;
      margin-bottom: 4px;
    }
    #devProps label{
      font-size: 12px;
      opacity: .78;
      text-align: right;
      padding-right: 4px;
    }
    #devProps input{
      flex:1;
      border-radius: 10px;
      border:1px solid rgba(0,0,0,.12);
      padding: 7px 10px;
      font-size: 12px;
      background: rgba(255,255,255,.95);
      width: 100%;
    }
    #devMapList{
      max-height: 140px;
      overflow:auto;
      border:1px solid rgba(0,0,0,.10);
      border-radius: 12px;
      background: rgba(255,255,255,.65);
      padding: 6px;
    }
    #devMapList .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding: 7px 8px;
      border-radius: 10px;
      cursor:pointer;
      font-size: 12px;
    }
    #devMapList .item:hover{ background: rgba(0,0,0,.05); }
    #devMapList .item.on{ background: rgba(45,123,255,.14); border:1px solid rgba(45,123,255,.25); }
    #devToast2{
      position:fixed;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.70);
      color: #fff;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 12px;
      pointer-events:none;
      opacity: 0;
      transition: opacity .18s ease;
      z-index: 10000;
      white-space: nowrap;
    }

</style>
</head>

<body>
  <div id="wrap"></div>

  <!-- ÌÉÄÏù¥ÌãÄ/Î°úÎî© Ïò§Î≤ÑÎ†àÏù¥: Î¶¨ÏÜåÏä§ Î°úÎî© ÏôÑÎ£å ÌõÑ "Dash & Run" Î≤ÑÌäºÏúºÎ°ú ÏãúÏûë -->
  <div id="loader" aria-label="Î°úÎî©">
    <div class="bg" aria-hidden="true"></div>
    <div class="shade" aria-hidden="true"></div>
    <div class="panel">
      <img class="titleArt" src="title_image.png" alt="Tiny Hero: Dash & Run" />
      <div class="bar"><div id="barFill"></div></div>
      <div id="loadText" class="small">Î¶¨ÏÜåÏä§ Î°úÎî© Ï§ë...</div>
      <div class="actions">
        <button id="btnStart" disabled>Dash &amp; Run</button>
      </div>
    </div>
  </div>


  <div id="hud">
    <div class="row">
      <div class="left">
        <div class="pill">
          <span style="font-weight:900">ü™ô</span>
          <span id="coinText" style="font-weight:900">0</span>
        </div>
        <div class="pill small" id="stageText">Level 1</div>

        <div class="pill small clickable" id="policyPill" title="Click Toggle (key: H/C)" style="display:none">
          <span style="font-weight:900">Policy</span>
          <span>HP</span><span id="hpPolicyTag" class="onTag">Stay</span>
          <span>Coin</span><span id="coinPolicyTag" class="onTag">Stay</span>
        </div>

        <div class="pill small">
          <span style="font-weight:900">Dash</span>
          <span id="dashText">1/1</span>
        </div>
        <div class="pill small" id="bossHpWrap" style="display:none">
          <span style="font-weight:900">BOSS</span>
          <span id="bossHpText" style="font-weight:900">‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†</span>
          <span id="bossLvText" class="small" style="opacity:.75">Lv1</span>
        </div>
        <div class="pill small clickable" id="soundPill" title="Sound Toggle: Click=All ON/OFF, M=Music, N=SFX, +/-=Vol">
          <span id="soundIcon" style="font-weight:900">üîä</span>
          <span id="soundLabel" style="font-weight:900">ON</span>
          <span id="soundVolText" class="small" style="opacity:.75">85%</span>
        </div>
      </div>

      <div class="right">
        <div class="pill clickable" id="infoPill" title="play/Manual">‚ÑπÔ∏è</div>
        <div class="pill" id="heartWrap" aria-label="Life">
          <span id="hearts" style="color:red">‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§</span>
        </div>
      </div>
    </div>

    <div id="toast">Ready!</div>

    <div id="subtitle">
      instant Boss <span class="kbd">Z</span> / <b>Map Create</b> <span class="kbd">F2</span> / Move <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> ¬∑
      Jump <span class="kbd">Space</span> ¬∑
      Crouch <span class="kbd">S</span>/<span class="kbd">‚Üì</span> (crash box‚Üì) ¬∑
      Dash <span class="kbd">X</span> (alt: <span class="kbd">K</span>, 8 Arrow, Air 1) ¬∑
      Slide <span class="kbd">‚Üì</span>+<span class="kbd">X</span> ¬∑
      Wall Slide ‚Üí <span class="kbd">Space</span> WallJump ¬∑
      Up/Dn <span class="kbd">W</span><span class="kbd">S</span> / <span class="kbd">‚Üë</span><span class="kbd">‚Üì</span> ¬∑
      Policy <span class="kbd">H</span>(HP) <span class="kbd">C</span>(Coin) ¬∑ Restart <span class="kbd">R</span> ¬∑ Sound <span class="kbd">M</span>(Music) <span class="kbd">N</span>(SFX) <span class="kbd">+</span>/<span class="kbd">-</span>(Vol)
    </div>
  </div>

  <div id="bigMsg">Congratuation !!</div>
  <div id="pauseMsg">ÏùºÏãúÏ†ïÏßÄ</div>

  <div id="touch">
    <div class="cluster leftCluster">
      <div class="btn" id="tLeft">‚óÄ</div>
      <div class="btn" id="tRight">‚ñ∂</div>
    </div>

    <div class="cluster rightCluster">
      <div class="col">
        <div class="btn" id="tUp">‚ñ≤</div>
        <div class="btn" id="tDown">‚ñº</div>
      </div>
      <div class="col">
        <div class="btn" id="tJump">‚§¥</div>
        <div class="btn" id="tDash">‚ü∂</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";

    // ----------------------------
    // Í≤åÏûÑ ÏÉÅÌÉú
    // ----------------------------
    // (ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù) ÏÇ¨Îßù Î¶¨Ïä§Ìè∞ ÎîúÎ†àÏù¥: 1.5Ï¥à
    const RESPAWN_DELAY = 1.3;
    // ÏãúÏûë/Î¶¨Ïä§Ìè∞ Ïãú "ÎøÖ" Îì±Ïû• Î™®ÏÖò
    const SPAWN_DUR = 1.62;

    const game = {
      level: 1,
      levelSeed: 1,
      difficulty: 1.0,
      bossDifficulty: 1,
      pendingNextLevel: 2,
      respawnBoss: false,
      // (ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù) ÏÇ¨ÎßùÌïòÎ©¥ Î¨¥Ï°∞Í±¥ HP 5Î°ú ÌöåÎ≥µ
      forceFullHP: false,
      state: "play",     // play | celebrate | bossIntro | boss | bossDefeat | next | respawn
      paused: false,
      t: 0,
      // Ïó∞Ï∂ú Ïä§Ìè∞ ÌÉÄÏù¥Î®∏
      flowerRainT: 0,
      fireworkT: 0,
    };
	
	
	// ----------------------------
    // Ïú†Ìã∏
    // ----------------------------

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const sign = (v)=> (v>0)-(v<0);

    // Ïù¥Ïßï(Îì±Ïû•/ÏÇ¨Îßù Ïó∞Ï∂ú)
    const easeOutCubic = (t)=>1 - Math.pow(1-t, 3);
    const easeOutBack = (t)=>{
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
    };

    // ----------------------------
    // ÎÇúÏàò(ÏãúÎìú Í∏∞Î∞ò)
    //  - "ÎÇòÎÖ∏Ï¥à" Ï†ïÎ∞ÄÎèÑÎäî Î∏åÎùºÏö∞Ï†Ä/ÌôòÍ≤ΩÏóê Îî∞Îùº Ï†úÌïúÎê† Ïàò ÏûàÏùå(ÌôïÏã§ÌïòÏßÄ ÏïäÏùå).
    //  - performance.timeOrigin + performance.now()Î•º ns(ÌôòÏÇ∞)Î°ú Î≥¥Í≥† 32bit ÏãúÎìúÎ•º ÎßåÎì≠ÎãàÎã§.
    // ----------------------------
    let RNG_SEED = 1 >>> 0;

    function seedFromNano(extra = 0){
      const tMs = (performance.timeOrigin || 0) + performance.now(); // ms

      // ns(ÌôòÏÇ∞) Ï†ïÎ∞ÄÎèÑÎäî ÌôòÍ≤ΩÏóê Îî∞Îùº Ï†úÌïúÎê† Ïàò ÏûàÏùå(ÌôïÏã§ÌïòÏßÄ ÏïäÏùå).
      // BigInt ÏóÜÏù¥ÎèÑ ÎèôÏûëÌïòÎèÑÎ°ù, ÏÑúÎ°ú Îã§Î•∏ Ïä§ÏºÄÏùº/ÏÜåÏàòÎ∂ÄÎ•º ÏÑûÏñ¥ 32bit ÏãúÎìúÎ•º ÎßåÎì≠ÎãàÎã§.
      const a = (tMs * 1000) | 0;      // us-ish
      const b = (tMs * 1000000) | 0;   // ns-ish (ÌïòÏúÑÎπÑÌä∏ ÏúÑÏ£º)
      let s = (a ^ (b << 11) ^ (b >>> 7) ^ (extra >>> 0)) >>> 0;

      // xorshift ÎØπÏã±
      s ^= (s << 13) >>> 0;
      s ^= (s >>> 17) >>> 0;
      s ^= (s << 5) >>> 0;
      RNG_SEED = (s >>> 0) || 1;
      return RNG_SEED;
    }


    function seedRng(seed){
      RNG_SEED = (seed >>> 0) || 1;
    }

    function rng(){
      // xorshift32
      let x = RNG_SEED >>> 0;
      x ^= (x << 13) >>> 0;
      x ^= (x >>> 17) >>> 0;
      x ^= (x << 5) >>> 0;
      RNG_SEED = x >>> 0;
      return RNG_SEED / 4294967296;
    }

    const rand = (a,b)=>a + rng()*(b-a);
    const choice = (arr)=>arr[(rng()*arr.length)|0];


    function moveTowards(current, target, maxDelta){
      const d = target - current;
      if(Math.abs(d) <= maxDelta) return target;
      return current + Math.sign(d) * maxDelta;
    }
	function aabbIntersect(ax,ay,aw,ah, bx,by,bw,bh, eps=1e-5){
	  return ax < bx + bw - eps &&
			 ax + aw > bx + eps &&
			 ay < by + bh - eps &&
			 ay + ah > by + eps;
	}


    // ----------------------------
    // HUD
    // ----------------------------
    const $coinText = document.getElementById("coinText");
    const $hearts = document.getElementById("hearts");
    const $toast = document.getElementById("toast");
    const $stageText = document.getElementById("stageText");
    const $bigMsg = document.getElementById("bigMsg");
    const $pauseMsg = document.getElementById("pauseMsg");
    const $dashText = document.getElementById("dashText");
    const $bossHpWrap = document.getElementById("bossHpWrap");
    const $bossHpText = document.getElementById("bossHpText");
    const $bossLvText = document.getElementById("bossLvText");

    const $soundPill = document.getElementById("soundPill");
    const $soundIcon = document.getElementById("soundIcon");
    const $soundLabel = document.getElementById("soundLabel");
    const $soundVolText = document.getElementById("soundVolText");


    const $policyPill = document.getElementById("policyPill");
    const $hpPolicyTag = document.getElementById("hpPolicyTag");
    const $coinPolicyTag = document.getElementById("coinPolicyTag");

    let toastT = 0;
    function showToast(msg, ms=1000){
      $toast.textContent = msg;
      toastT = ms/1000;
      $toast.style.opacity = "1";
    }
    function showBigMsg(on, msg=null){
      if(msg != null) $bigMsg.textContent = msg;
      if(on) $bigMsg.classList.add("on");
      else $bigMsg.classList.remove("on");
    }

    // ----------------------------
    // Ï†ïÏ±Ö(Ïú†ÏßÄ/Î¶¨ÏÖã)
    // ----------------------------
    const policy = {
      keepHP: true,
      keepCoins: true,
    };
    function syncPolicyUI(){
      $hpPolicyTag.className = policy.keepHP ? "onTag" : "offTag";
      $hpPolicyTag.textContent = policy.keepHP ? "Ïú†ÏßÄ" : "Î¶¨ÏÖã";
      $coinPolicyTag.className = policy.keepCoins ? "onTag" : "offTag";
      $coinPolicyTag.textContent = policy.keepCoins ? "Ïú†ÏßÄ" : "Î¶¨ÏÖã";
      showToast(`Ï†ïÏ±Ö: HP ${policy.keepHP?"Ïú†ÏßÄ":"Î¶¨ÏÖã"} / ÏΩîÏù∏ ${policy.keepCoins?"Ïú†ÏßÄ":"Î¶¨ÏÖã"}`, 900);
    }
    $policyPill.addEventListener("click", ()=>{
      // ÌÅ¥Î¶≠ÏùÄ Îëò Îã§ ÌÜ†Í∏Ä
      policy.keepHP = !policy.keepHP;
      policy.keepCoins = !policy.keepCoins;
      syncPolicyUI();

    
    });

// ----------------------------
    // ÏÇ¨Ïö¥Îìú(Î∏åÎùºÏö∞Ï†Ä Ï†úÏïΩ: Ï≤´ ÏûÖÎ†• ÌõÑ ÏãúÏûë)
    // - BGM/SFXÎäî WebAudioÎ°ú "ÏßÅÏ†ë Ìï©ÏÑ±"(Ï†ÄÏûëÍ∂å Ïù¥Ïäà ÏóÜÏùå)
    // ----------------------------
    const sound = {
      enabled: true,
      musicEnabled: true,
      sfxEnabled: true,
      masterVol: 0.85,
      musicVol: 0.45,
      sfxVol: 0.85,

      ctx: null,
      master: null,
      musicBus: null,
      sfxBus: null,
      comp: null,
      convolver: null,
      noiseBuf: null,

      started: false,
      bgmTimer: null,
      bgmNextT: 0,
      bgmStep: 0,
      bpm: 124,
      rng: null,

      last: Object.create(null),
    };


    // Î°úÏª¨ Ï†ÄÏû•(ÏÑ†ÌÉù)
    (function loadSoundSettings(){
      try{
        const v = JSON.parse(localStorage.getItem("pm_sound_v1") || "null");
        if(v){
          sound.enabled = !!v.enabled;
          sound.musicEnabled = !!v.musicEnabled;
          sound.sfxEnabled = !!v.sfxEnabled;
          sound.masterVol = clamp(+v.masterVol || 0.85, 0, 1);
          sound.musicVol = clamp(+v.musicVol || 0.45, 0, 1);
          sound.sfxVol   = clamp(+v.sfxVol   || 0.85, 0, 1);
        }
      }catch(_){}
    })();

    function saveSoundSettings(){
      try{
        localStorage.setItem("pm_sound_v1", JSON.stringify({
          enabled: sound.enabled,
          musicEnabled: sound.musicEnabled,
          sfxEnabled: sound.sfxEnabled,
          masterVol: sound.masterVol,
          musicVol: sound.musicVol,
          sfxVol: sound.sfxVol,
        }));
      }catch(_){}
    }

    function syncSoundUI(){
      if(!$soundPill) return;
      const on = sound.enabled;
      const icon = on ? "üîä" : "üîá";
      $soundIcon.textContent = icon;
      $soundLabel.textContent = on ? "ON" : "OFF";
      const pct = Math.round(sound.masterVol*100);
      $soundVolText.textContent = pct + "%";
      $soundPill.style.opacity = on ? "1" : "0.65";
    }

    function nowNanoSeed32(){
      // "ÎÇòÎÖ∏Ï¥à"Îäî Î∏åÎùºÏö∞Ï†Ä/OSÏóê Îî∞Îùº Ï†ïÎ∞ÄÎèÑÍ∞Ä Ï†úÌïúÎê† Ïàò ÏûàÏùå(ÌôïÏã§ÌïòÏßÄ ÏïäÏùå).
      // ÎåÄÏã† Date.now(ms) + performance.now(ÏÑúÎ∏åms)Î•º ÏÑûÏñ¥ 32ÎπÑÌä∏ ÏãúÎìúÎ°ú ÏÇ¨Ïö©.
      const epochMs = BigInt(Date.now());
      const perf = performance.now();
      const fracNs = BigInt(Math.floor((perf - Math.floor(perf)) * 1e6)); // 0~999,999ns Í∑ºÏÇ¨
      const ns = epochMs * 1000000n + fracNs; // epoch Í∏∞Ï§Ä ns(Í∑ºÏÇ¨)
      let x = Number(ns & 0xffffffffn) >>> 0;
      x ^= x << 13; x >>>= 0;
      x ^= x >>> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return x >>> 0;
    }

    function mulberry32(a){
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

    function makeImpulse(ctx, dur=1.2, decay=2.4){
      const rate = ctx.sampleRate;
      const len = Math.floor(rate * dur);
      const buf = ctx.createBuffer(2, len, rate);
      for(let c=0;c<2;c++){
        const data = buf.getChannelData(c);
        for(let i=0;i<len;i++){
          const t = i/len;
          const amp = Math.pow(1 - t, decay);
          data[i] = (Math.random()*2-1) * amp;
        }
      }
      return buf;
    }

    function makeNoiseBuffer(ctx){
      const len = Math.floor(ctx.sampleRate * 1.2);
      const buf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i] = Math.random()*2 - 1;
      return buf;
    }

    function applySoundGains(){
      // ‚úÖ MP3 BGM Î≥ºÎ•®/ÌÜ†Í∏Ä(Ïò§ÎîîÏò§ Ïª®ÌÖçÏä§Ìä∏ ÏóÜÏù¥ÎèÑ Ï†ÅÏö©)
      if(sound.bgmEl){
        const v = (sound.enabled && sound.musicEnabled) ? clamp(sound.masterVol * sound.musicVol, 0, 1) : 0;
        try{ sound.bgmEl.volume = v; }catch(_){}
        if(v <= 0.0001){
          try{ sound.bgmEl.pause(); }catch(_){}
        }else if(sound.started){
          // autoplay Ï†ïÏ±Ö: Ï≤´ ÏûÖÎ†• Ïù¥ÌõÑ(sound.started)Îßå Ïû¨ÏÉù ÏãúÎèÑ
          sound.bgmEl.play().catch(()=>{});
        }
      }

      // SFXÎäî WebAudio Î≤ÑÏä§Ïóê Ï†ÅÏö©
      if(sound.ctx){
        sound.master.gain.setTargetAtTime(sound.enabled ? sound.masterVol : 0, sound.ctx.currentTime, 0.02);
        sound.musicBus.gain.setTargetAtTime((sound.enabled && sound.musicEnabled) ? sound.musicVol : 0, sound.ctx.currentTime, 0.02);
        sound.sfxBus.gain.setTargetAtTime((sound.enabled && sound.sfxEnabled) ? sound.sfxVol : 0, sound.ctx.currentTime, 0.02);
      }

      syncSoundUI();
      saveSoundSettings();
    }


    function ensureAudio(){
      if(sound.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if(!Ctx) return;

      const ctx = new Ctx();
      sound.ctx = ctx;

      sound.master = ctx.createGain();
      sound.musicBus = ctx.createGain();
      sound.sfxBus = ctx.createGain();

      sound.master.gain.value = sound.masterVol;
      sound.musicBus.gain.value = sound.musicVol;
      sound.sfxBus.gain.value = sound.sfxVol;

      // Î¶¨ÎØ∏ÌÑ∞/Ïª¥ÌîÑÎ†àÏÑúÎ°ú "Í≤ΩÏæå+Í≥†ÏùåÏßà" ÎäêÎÇå(ÌÅ¥Î¶¨Ìïë Î∞©ÏßÄ)
      sound.comp = ctx.createDynamicsCompressor();
      sound.comp.threshold.value = -18;
      sound.comp.knee.value = 18;
      sound.comp.ratio.value = 4.2;
      sound.comp.attack.value = 0.006;
      sound.comp.release.value = 0.14;

      // Î¶¨Î≤ÑÎ∏å(Í∞ÄÎ≤ºÏö¥ Í≥µÍ∞ÑÍ∞ê)
      sound.convolver = ctx.createConvolver();
      sound.convolver.buffer = makeImpulse(ctx, 1.15, 2.2);
      const rv = ctx.createGain();
      rv.gain.value = 0.22;

      // ÎùºÏö∞ÌåÖ
      sound.musicBus.connect(rv);
      rv.connect(sound.convolver);
      sound.convolver.connect(sound.master);

      sound.musicBus.connect(sound.master);
      sound.sfxBus.connect(sound.master);

      sound.master.connect(sound.comp);
      sound.comp.connect(ctx.destination);

      sound.noiseBuf = makeNoiseBuffer(ctx);

      // BGMÏö© RNG(Î†àÎ≤®ÎßàÎã§ seed Í∞±Ïã† Í∞ÄÎä•)
      sound.rng = mulberry32(nowNanoSeed32());

      applySoundGains();
        syncSoundUI();
        saveSoundSettings();
      syncSoundUI();
    }

    function unlockAudio(){
      if(!sound.enabled) return;
      ensureAudio();
      if(!sound.ctx) return;
      if(sound.ctx.state === "suspended"){
        sound.ctx.resume().catch(()=>{});
      }
      if(!sound.started){
        startBGM();
        sound.started = true;
      }
    }

    // --- ÏïÖÍ∏∞ Í∏∞Î≥∏ ---
    function envGain(g, t, a=0.004, d=0.08, s=0.0, r=0.06, peak=1.0){
      g.gain.cancelScheduledValues(t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(peak, t+a);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, peak*(0.25+s)), t+a+d);
      g.gain.exponentialRampToValueAtTime(0.0001, t+a+d+r);
    }

    function playOsc({t,freq=440,dur=0.12,type="triangle",gain=0.22,detune=0,slideTo=null,slideTime=0.06,filterHz=null,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const out = bus || sound.musicBus;

      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      if(slideTo){
        o.frequency.exponentialRampToValueAtTime(Math.max(20, slideTo), t + slideTime);
      }
      if(detune) o.detune.setValueAtTime(detune, t);

      let node = o;
      if(filterHz){
        const f = ctx.createBiquadFilter();
        f.type = "lowpass";
        f.frequency.setValueAtTime(filterHz, t);
        node.connect(f);
        node = f;
      }else{
        o.connect(g);
        node = g;
      }
      if(filterHz){
        node.connect(g);
      }
      g.connect(out);

      envGain(g, t, 0.004, dur*0.45, 0.0, dur*0.55, gain);

      o.start(t);
      o.stop(t + dur + 0.12);
    }

    function playNoise({t,dur=0.09,gain=0.22,band="high",hz=6000,bus=null}){
      if(!sound.ctx) return;
      const ctx = sound.ctx;
      const src = ctx.createBufferSource();
      src.buffer = sound.noiseBuf;
      const f = ctx.createBiquadFilter();
      const g = ctx.createGain();

      if(band==="high"){ f.type="highpass"; f.frequency.setValueAtTime(hz, t); }
      else if(band==="band"){ f.type="bandpass"; f.frequency.setValueAtTime(hz, t); f.Q.setValueAtTime(1.2, t); }
      else { f.type="lowpass"; f.frequency.setValueAtTime(hz, t); }

      src.connect(f);
      f.connect(g);
      g.connect(bus || sound.sfxBus);

      envGain(g, t, 0.002, dur*0.25, 0.0, dur*0.65, gain);

      src.start(t);
      src.stop(t + dur + 0.05);
    }

    function limit(name, sec){
      if(!sound.ctx) return false;
      const t = sound.ctx.currentTime;
      const last = sound.last[name] || -999;
      if(t - last < sec) return true;
      sound.last[name] = t;
      return false;
    }

    // --- BGM(Î∞ùÍ≥† Í≤ΩÏæåÌïú Ï∫êÏ£ºÏñº) ---
    function startBGM(){
      // ‚úÖ MP3 BGM Ïû¨ÏÉù (WebAudio Ìï©ÏÑ± BGM Ï†úÍ±∞)
      if(!sound.bgmEl) return;
      if(!sound.enabled || !sound.musicEnabled) return;
      const v = clamp(sound.masterVol * sound.musicVol, 0, 1);
      try{ sound.bgmEl.volume = v; }catch(_){}
      // autoplay Ï†ïÏ±Ö: unlockAudio(Ï≤´ ÏûÖÎ†•) Ïù¥ÌõÑÏóêÎßå Ï†ïÏÉÅ Ïû¨ÏÉùÎê©ÎãàÎã§.
      sound.bgmEl.play().catch(()=>{});
    }

    function stopBGM(){
      if(sound.bgmEl){
        try{ sound.bgmEl.pause(); }catch(_){}
      }
    }

    function scheduleBgmStep(t, s){
      const step = s % 64;            // 4ÎßàÎîî(16*4)
      const bar = Math.floor(step/16);
      const pos = step % 16;

      // ÏΩîÎìú ÏßÑÌñâ: C - G - Am - F (Î∞ùÍ≥† ÏùµÏàô)
      const prog = [
        {root: 60, type:"maj"}, // C
        {root: 67, type:"maj"}, // G
        {root: 69, type:"min"}, // A
        {root: 65, type:"maj"}, // F
      ];
      const ch = prog[bar];

      // ÎìúÎüº(Í∞ÄÎ≤ºÏö¥ ÌÇ•/Ïä§ÎÑ§Ïñ¥/ÌïòÏù¥Ìñá)
      if(pos===0 || pos===8){
        // kick
        playOsc({ t, freq: 120, slideTo: 48, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.32, bus: sound.musicBus });
      }
      if(pos===4 || pos===12){
        // snare
        playNoise({ t, dur: 0.10, gain: 0.20, band:"band", hz: 1800, bus: sound.musicBus });
        playOsc({ t, freq: 220, dur: 0.08, type:"triangle", gain: 0.10, bus: sound.musicBus });
      }
      if(pos%2===0){
        // hat
        playNoise({ t, dur: 0.045, gain: 0.10, band:"high", hz: 6500, bus: sound.musicBus });
      }

      // Î≤†Ïù¥Ïä§(ÏøºÌÑ∞)
      if(pos%4===0){
        const bassMidi = (ch.root - 24); // Ï†ÄÏó≠
        playOsc({ t, freq: midiToFreq(bassMidi), dur: 0.14, type:"triangle", gain: 0.20, filterHz: 700, bus: sound.musicBus });
      }

      // Ìå®Îìú(ÎßàÎîî ÏãúÏûë)
      if(pos===0){
        const tri = (ch.type==="maj") ? [0,4,7] : [0,3,7];
        for(let i=0;i<3;i++){
          const m = ch.root + tri[i];
          playOsc({ t, freq: midiToFreq(m), dur: 0.55, type:"sawtooth", gain: 0.055, filterHz: 1400, detune: (i-1)*6, bus: sound.musicBus });
        }
      }

      // Î¶¨Îìú(Ïã±ÏΩîÌéòÏù¥ÏÖò + ÌéúÌÉÄÌÜ†Îãâ)
      const leadSlots = [2,6,10,14];
      if(leadSlots.includes(pos)){
        const scale = [0,2,4,7,9]; // major pentatonic
        const pick = scale[Math.floor((sound.rng ? sound.rng() : Math.random()) * scale.length)];
        const base = ch.root + 12; // Ìïú Ïò•ÌÉÄÎ∏å ÏúÑ
        const m = base + pick + (pos===14 ? 12 : 0)*( (sound.rng ? sound.rng() : Math.random())>0.85 ? 1:0);
        const f = midiToFreq(m);
        playOsc({ t, freq: f, dur: 0.13, type:"square", gain: 0.12, filterHz: 2600, detune: (sound.rng ? (sound.rng()-0.5)*8 : (Math.random()-0.5)*8), bus: sound.musicBus });
        // ÏûëÏùÄ ÌïòÎ™®Îãà(Í∞ÄÎÅî)
        if((sound.rng ? sound.rng() : Math.random()) > 0.72){
          playOsc({ t, freq: midiToFreq(m-12), dur: 0.12, type:"triangle", gain: 0.06, filterHz: 2400, bus: sound.musicBus });
        }
      }
    }

    // --- SFX(Í≤ΩÏæå + Í≥†ÏùåÏßà) ---
    const SFX = {
      jump(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("jump", 0.03)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 420, slideTo: 860, slideTime: 0.06, dur: 0.10, type:"triangle", gain: 0.22, filterHz: 3200, bus: sound.sfxBus });
        playNoise({ t, dur: 0.045, gain: 0.06, band:"high", hz: 7000, bus: sound.sfxBus });
      },
      coin(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("coin", 0.02)) return;
        const t = sound.ctx.currentTime;
        const base = 880;
        playOsc({ t, freq: base, dur: 0.08, type:"sine", gain: 0.16, bus: sound.sfxBus });
        playOsc({ t: t+0.035, freq: base*1.25, dur: 0.08, type:"sine", gain: 0.14, bus: sound.sfxBus });
        playOsc({ t: t+0.070, freq: base*1.50, dur: 0.09, type:"triangle", gain: 0.10, bus: sound.sfxBus });
      },
      dash(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("dash", 0.06)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.11, gain: 0.16, band:"band", hz: 1300, bus: sound.sfxBus });
        playOsc({ t, freq: 220, slideTo: 90, slideTime: 0.10, dur: 0.12, type:"sawtooth", gain: 0.10, filterHz: 900, bus: sound.sfxBus });
      },
      fastRun(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("fastRun", 0.08)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.09, gain: 0.07, band:"band", hz: 1800, bus: sound.sfxBus });
        playOsc({ t, freq: 260, slideTo: 140, slideTime: 0.10, dur: 0.12, type:"sawtooth", gain: 0.05, filterHz: 1200, bus: sound.sfxBus });
      },
      spring(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spring", 0.06)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 260, slideTo: 980, slideTime: 0.08, dur: 0.14, type:"square", gain: 0.18, filterHz: 2600, bus: sound.sfxBus });
      },
      stomp(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("stomp", 0.05)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 140, slideTo: 70, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.24, bus: sound.sfxBus });
        playNoise({ t, dur: 0.06, gain: 0.10, band:"band", hz: 900, bus: sound.sfxBus });
      },
      hurt(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("hurt", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 520, slideTo: 220, slideTime: 0.11, dur: 0.16, type:"sawtooth", gain: 0.18, filterHz: 1600, bus: sound.sfxBus });
        playNoise({ t, dur: 0.10, gain: 0.14, band:"band", hz: 700, bus: sound.sfxBus });
      },
      pop(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("pop", 0.12)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 380, slideTo: 110, slideTime: 0.06, dur: 0.12, type:"triangle", gain: 0.20, bus: sound.sfxBus });
        playNoise({ t, dur: 0.09, gain: 0.12, band:"high", hz: 5200, bus: sound.sfxBus });
        // sparkle
        for(let i=0;i<3;i++){
          const dt = 0.02*i;
          playOsc({ t: t+dt, freq: 1200 + i*320, dur: 0.06, type:"sine", gain: 0.06, bus: sound.sfxBus });
        }
      },
      spawn(){
        // Î¶¨Ïä§Ìè∞/ÏãúÏûë "ÎøÖ"(Í∞ÄÎ≤ºÏö¥ Î∞òÏßù)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("spawn", 0.10)) return;
        const t = sound.ctx.currentTime;
        playOsc({ t, freq: 880, slideTo: 1320, slideTime: 0.08, dur: 0.12, type:"sine", gain: 0.11, bus: sound.sfxBus });
        playOsc({ t: t+0.03, freq: 1760, dur: 0.08, type:"triangle", gain: 0.06, bus: sound.sfxBus });
      },
      death(){
        // ÏÇ¨Îßù "ÏÇêÏö© ÏÇêÏö© ÏÇêÏö©~" (ÏïÑÏâ¨Ïö¥ ÌÜ§)
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("death", 0.30)) return;
        const t = sound.ctx.currentTime;
        const seq = [780, 640, 520];
        for(let i=0;i<3;i++){
          playOsc({ t: t+i*0.11, freq: seq[i], slideTo: seq[i]*0.72, slideTime: 0.14, dur: 0.24, type:"triangle", gain: 0.16, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.05, band:"high", hz: 5200, bus: sound.sfxBus });
      },
      clear(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("clear", 0.35)) return;
        const t = sound.ctx.currentTime;
        // ÏûëÏùÄ Ìå¨ÌéòÏñ¥(Í≤ΩÏæå)
        const notes = [880, 1108, 1318, 1760];
        for(let i=0;i<notes.length;i++){
          playOsc({ t: t+i*0.08, freq: notes[i], dur: 0.18, type:"square", gain: 0.11, filterHz: 3200, bus: sound.sfxBus });
          playOsc({ t: t+i*0.08, freq: notes[i]*0.5, dur: 0.18, type:"triangle", gain: 0.06, filterHz: 2200, bus: sound.sfxBus });
        }
        playNoise({ t: t+0.02, dur: 0.18, gain: 0.08, band:"high", hz: 7600, bus: sound.sfxBus });
      },
      firework(){
        if(!sound.enabled || !sound.sfxEnabled) return;
        unlockAudio();
        if(!sound.ctx || limit("fw", 0.08)) return;
        const t = sound.ctx.currentTime;
        playNoise({ t, dur: 0.10, gain: 0.10, band:"high", hz: 6800, bus: sound.sfxBus });
        playOsc({ t, freq: 980, slideTo: 420, slideTime: 0.09, dur: 0.14, type:"sine", gain: 0.09, bus: sound.sfxBus });
      }
    };

    // UI/Îã®Ï∂ïÌÇ§
    syncSoundUI();
    if($soundPill){
      $soundPill.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        unlockAudio();
        sound.enabled = !sound.enabled;
        applySoundGains();
        showToast(sound.enabled ? "ÏÇ¨Ïö¥Îìú ON" : "ÏÇ¨Ïö¥Îìú OFF", 800);
      });
    }


    // ----------------------------
    // ÏûÖÎ†•
    // ----------------------------
    const input = {
      left:false, right:false, up:false, down:false,
      jump:false, jumpPressed:false, jumpReleased:false,
      dash:false, dashPressed:false,
      faceLock:false
    };

   const keyMap = {
      "ArrowLeft":"left","KeyA":"left",
      "ArrowRight":"right","KeyD":"right",
      "ArrowUp":"up","KeyW":"up",
      "ArrowDown":"down","KeyS":"down",
      "Space":"jump",
      // ‚úÖ Windows 'Í≥†Ï†ïÌÇ§(Sticky Keys)' ÌåùÏóÖÏùÑ Í∑ºÎ≥∏Ï†ÅÏúºÎ°ú ÌîºÌïòÎ†§Î©¥
      //    'Shift' Í∞ôÏùÄ Î™®ÎîîÌååÏù¥Ïñ¥ ÌÇ§Î•º ÎåÄÏãúÎ°ú Ïì∞ÏßÄ ÏïäÎäî Í≤å Í∞ÄÏû• ÌôïÏã§Ìï©ÎãàÎã§.
      //    Í∏∞Î≥∏ ÎåÄÏãú ÌÇ§: X (ÎåÄÏ≤¥: K)
      "KeyX":"dash",
      "KeyK":"dash",
      "AltLeft":"faceLock","AltRight":"faceLock",
      "KeyR":"restart",
	  "KeyZ":"boss"
    };

    // Shift ÌÇ§Î•º Ïó∞ÌÉÄ/Í∏∏Í≤å ÎàÑÎ•º Îïå Windows Í≥†Ï†ïÌÇ§/ÌïÑÌÑ∞ÌÇ§ ÌåùÏóÖÏù¥ Îú∞ Ïàò ÏûàÏñ¥ÏÑú,
    // Í≤åÏûÑ ÎÇ¥ÏóêÏÑúÎäî ShiftÎ•º 'ÎåÄÏãú'Î°ú ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎèÑÎ°ù Ï∞®Îã®ÌïòÍ≥† ÏïàÎÇ¥ ÌÜ†Ïä§Ìä∏Îßå ÎùÑÏõÅÎãàÎã§.
    let _shiftWarned = false;    
	
	
	
    addEventListener("keydown", (e)=>{
      // ÎîîÎ≤ÑÍ∑∏ ÌÜ†Í∏Ä: ` (Backquote)
		if(e.code === "Backquote"){
		  debug.enabled = !debug.enabled;
		  showToast(debug.enabled ? "ÎîîÎ≤ÑÍ∑∏ ON (`)" : "ÎîîÎ≤ÑÍ∑∏ OFF (`)", 900);
		  // Î∞îÎ°ú Î∞òÏòÅ
		  if(!debug.enabled){
			resetDebugPool();
			if(debug.velLine) debug.velLine.visible = false;
		  }
		  return;
		}

	  // ‚úÖ Shift Ï∞®Îã®(ÏúàÎèÑÏö∞ Í≥†Ï†ïÌÇ§/ÌïÑÌÑ∞ÌÇ§ ÌåùÏóÖ Î∞©ÏßÄ)
	  // Î∏åÎùºÏö∞Ï†Ä ÏΩîÎìúÎ°ú OS ÌåùÏóÖ ÏûêÏ≤¥Î•º 'ÏôÑÏ†Ñ Ï∞®Îã®'Ìï† ÏàòÎäî ÏóÜÏñ¥ÏÑú(Windows Í∏∞Îä•),
	  // Í≤åÏûÑ Ï°∞ÏûëÏóêÏÑúÎäî ShiftÎ•º Ïì∞ÏßÄ ÏïäÍ≥† X/KÎ°ú ÎåÄÏãúÌïòÎèÑÎ°ù Ïú†ÎèÑÌï©ÎãàÎã§.
	  if(e.code === "ShiftLeft" || e.code === "ShiftRight"){
		if(!_shiftWarned){
		  showToast("ÏúàÎèÑÏö∞ Í≥†Ï†ïÌÇ§ ÌåùÏóÖ Î∞©ÏßÄ: ÎåÄÏãúÎäî X(ÎòêÎäî K) ÌÇ§!", 1600);
		  _shiftWarned = true;
		}
		e.preventDefault();
		return;
	  }

      // ÏÇ¨Ïö¥Îìú(Ï≤´ ÏûÖÎ†• Ïãú Ïò§ÎîîÏò§ Ïñ∏ÎùΩ)

      if(sound.enabled) unlockAudio();

      // ÏÇ¨Ïö¥Îìú Îã®Ï∂ïÌÇ§
      if(e.code === "KeyM"){
        sound.musicEnabled = !sound.musicEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.musicEnabled ? "BGM ON" : "BGM OFF", 800);
        return;
      }
      if(e.code === "KeyN"){
        sound.sfxEnabled = !sound.sfxEnabled;
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast(sound.sfxEnabled ? "SFX ON" : "SFX OFF", 800);
        return;
      }
      if(e.code === "Equal" || e.code === "NumpadAdd"){
        sound.masterVol = clamp(sound.masterVol + 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("Î≥ºÎ•® " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }
      if(e.code === "Minus" || e.code === "NumpadSubtract"){
        sound.masterVol = clamp(sound.masterVol - 0.05, 0, 1);
        applySoundGains();
        syncSoundUI();
        saveSoundSettings();
        showToast("Î≥ºÎ•® " + Math.round(sound.masterVol*100) + "%", 600);
        return;
      }

// Ï†ïÏ±Ö Îã®Ï∂ïÌÇ§
      if(e.code==="KeyH"){
        policy.keepHP = !policy.keepHP;
        syncPolicyUI();
        return;
      }
      if(e.code==="KeyC"){
        policy.keepCoins = !policy.keepCoins;
        syncPolicyUI();
        return;
      }
	  
	  if(e.code==="KeyZ"){
        if(game.state === "boss" || game.state === "bossIntro" || game.state === "bossDefeat"){
          game.level += 1;
          game.bossDifficulty = (game.bossDifficulty|0) + 1;
          startBossFight();
        }else{
          jumpGoal();
        }
        return;
      }


      if(e.code==="KeyP"){
        game.paused = !game.paused;
        if($pauseMsg) $pauseMsg.classList.toggle("on", game.paused);
        showToast(game.paused ? "Paused" : "Resume", 600);
        return;
      }

      const k = keyMap[e.code];
      if(!k) return;

      if(k==="restart"){
        startLevel(1, true);
        showToast("Î¶¨ÏÖã!", 800);
        return;
      }

      if(k==="jump"){ if(!input.jump) input.jumpPressed=true; input.jump=true; return; }
      if(k==="dash"){ if(!input.dash) input.dashPressed=true; input.dash=true; return; }

      input[k] = true;
    });

    addEventListener("keyup", (e)=>{
      const k = keyMap[e.code];
      if(!k) return;

      if(k==="jump"){ input.jump=false; input.jumpReleased=true; return; }
      if(k==="dash"){ input.dash=false; return; }

      input[k] = false;
    });

    // Î™®Î∞îÏùº ÎèÑÏõÄÎßê(Info Î≤ÑÌäº)
    // - Î™®Î∞îÏùºÏóêÏÑúÎäî ÏÑ§Î™ÖÏùÑ Í∏∞Î≥∏ Ïà®ÍπÄ
    // - ‚ÑπÔ∏è Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥ 5Ï¥àÍ∞Ñ ÌëúÏãú ÌõÑ ÏûêÎèô Ïà®ÍπÄ
    const $subtitle = document.getElementById("subtitle");
    const $infoPill = document.getElementById("infoPill");
    let infoTimer = null;

    function hideHelp(){
      if(!$subtitle) return;
      $subtitle.classList.add("subHidden");
    }
    function showHelp(){
      if(!$subtitle) return;
      $subtitle.classList.remove("subHidden");
      if(infoTimer) clearTimeout(infoTimer);
      infoTimer = setTimeout(()=>{ hideHelp(); }, 5000);
    }

    // ÌÑ∞Ïπò(Î™®Î∞îÏùº)
    const touch = ("ontouchstart" in window) || (navigator.maxTouchPoints>0);
    const $touch = document.getElementById("touch");
    if(touch){
      $touch.style.display="block";
      // Î™®Î∞îÏùº: ÎèÑÏõÄÎßêÏùÄ ‚ÑπÔ∏èÎ°úÎßå ÎÖ∏Ï∂ú
      if($infoPill) $infoPill.style.display = "inline-flex";
      hideHelp();
      if($infoPill){
        $infoPill.addEventListener("click", (ev)=>{ ev.preventDefault(); ev.stopPropagation(); showHelp(); });
      }

      const bind = (id, key)=>{
        const el = document.getElementById(id);
        const down = (ev)=>{ ev.preventDefault();
        if(sound.enabled) unlockAudio(); input[key]=true; if(key==="jump") input.jumpPressed=true; if(key==="dash") input.dashPressed=true; };
        const up   = (ev)=>{ ev.preventDefault(); input[key]=false; if(key==="jump") input.jumpReleased=true; };
        el.addEventListener("pointerdown", down);
        addEventListener("pointerup", up);
        el.addEventListener("pointercancel", up);
        el.addEventListener("pointerleave", up);
      };
      bind("tLeft","left");
      bind("tRight","right");
      bind("tUp","up");
      bind("tDown","down");
      bind("tJump","jump");
      bind("tDash","dash");
    }else{
      // Îç∞Ïä§ÌÅ¨ÌÜ±ÏóêÏÑúÎäî Í∏∞Î≥∏ ÏÑ§Î™ÖÏùÑ Ìï≠ÏÉÅ Î≥¥Ïó¨Ï£ºÍ≥†, ‚ÑπÔ∏èÎäî Ïà®ÍπÄ
      if($infoPill) $infoPill.style.display = "none";
    }

    // ----------------------------
    // Three Í∏∞Î≥∏ ÏÑ∏ÌåÖ
    // ----------------------------

    const wrap = document.getElementById("wrap");

    // ----------------------------
    // Î°úÎî© UI (Î¶¨ÏÜåÏä§ Î°úÎî© ÏôÑÎ£å ÌõÑ ÏãúÏûë)
    // ----------------------------
    const $loader = document.getElementById("loader");
    const $barFill = document.getElementById("barFill");
    const $loadText = document.getElementById("loadText");
    const $btnStart = document.getElementById("btnStart");

    let __canStart = false;
    let __started = false;

    function showReadyToStart(){
      __canStart = true;
      if($btnStart) $btnStart.disabled = false;
      if($loadText) $loadText.textContent = "All Ready! Dash & Run Push button and Start Game.";
    }

    function startFromTitle(){
      if(__started || !__canStart) return;
      __started = true;

      // Î≤ÑÌäºÏùÑ ÎàåÎ†ÄÏùÑ ÎïåÎßå Ïò§ÎîîÏò§ Ïñ∏ÎùΩ(Î∏åÎùºÏö∞Ï†Ä Ï†ïÏ±Ö)
      try{ if(typeof unlockAudio === 'function') unlockAudio(); }catch(_){ }

      hideLoader();
      syncPolicyUI(); // Ï†ïÏ±Ö(HP/ÏΩîÏù∏ Ïú†ÏßÄ Îì±) Î∞òÏòÅ
      startLevel(1, true);
      animate();
    }

    if($btnStart){
      $btnStart.addEventListener("click", (ev)=>{
        ev.preventDefault();
        startFromTitle();
      });
    }
    function setLoading(done, total, label){
      const pct = total > 0 ? Math.round((done/total)*100) : 0;
      if($barFill) $barFill.style.width = pct + "%";
      if($loadText) $loadText.textContent = `${label || "Loading..."}  (${done}/${total})`;
    }
    function hideLoader(){
      if($loader) $loader.style.display = "none";
    }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfe4ff);

    const camera = new THREE.OrthographicCamera(-10, 10, 6, -6, 0.01, 100);
    camera.position.set(0, 0, 10);
    camera.zoom = 1.0;
    camera.updateProjectionMatrix();
    scene.add(camera);
	
	// ----------------------------
	// ÎîîÎ≤ÑÍ∑∏ Ïò§Î≤ÑÎ†àÏù¥(AABB/Î≤°ÌÑ∞) - ` ÌÇ§Î°ú ÌÜ†Í∏Ä
	// ----------------------------
	const debug = {
	  enabled: false,
	  group: new THREE.Group(),
	  pool: [],
	  velLine: null,
	};
	debug.group.position.z = 9;
	scene.add(debug.group);

	function makeLine(color, opacity=0.95){
	  return new THREE.LineBasicMaterial({ color, transparent:true, opacity, depthTest:false });
	}

	const MAT_PLAYER  = makeLine(0x00e5ff, 0.95);
	const MAT_SOLID   = makeLine(0x00ff7f, 0.55);
	const MAT_LADDER  = makeLine(0xffcc3d, 0.85);
	const MAT_COIN    = makeLine(0xff66cc, 0.80);
	const MAT_ENEMY   = makeLine(0xff3b3b, 0.85);
	const MAT_GOAL    = makeLine(0xb46bff, 0.90);
	const MAT_VEL     = makeLine(0xffffff, 0.85);

	function allocRect(material){
	  // LineLoop(5Ï†ê: ÏÇ¨Í∞ÅÌòï Îã´Ìûò)
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(5 * 3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));
	  const line = new THREE.Line(geo, material);
	  line.frustumCulled = false;
	  line.visible = false;
	  debug.group.add(line);
	  return { line, arr, inUse:false };
	}

	function getRect(material){
	  let r = debug.pool.find(o => !o.inUse && o.line.material === material);
	  if(!r){
		r = allocRect(material);
		debug.pool.push(r);
	  }
	  r.inUse = true;
	  r.line.visible = debug.enabled;
	  return r;
	}

	function setRect(r, x, y, w, h, z=9){
	  // x,y = bottom-left
	  const a = r.arr;
	  const x0=x, y0=y, x1=x+w, y1=y+h;
	  a[0]=x0; a[1]=y0; a[2]=z;
	  a[3]=x1; a[4]=y0; a[5]=z;
	  a[6]=x1; a[7]=y1; a[8]=z;
	  a[9]=x0; a[10]=y1; a[11]=z;
	  a[12]=x0; a[13]=y0; a[14]=z;
	  r.line.geometry.attributes.position.needsUpdate = true;
	}

	function resetDebugPool(){
	  for(const r of debug.pool){
		r.inUse = false;
		r.line.visible = false;
	  }
	}

	function ensureVelLine(){
	  if(debug.velLine) return;
	  const geo = new THREE.BufferGeometry();
	  const arr = new Float32Array(2*3);
	  geo.setAttribute("position", new THREE.BufferAttribute(arr,3));
	  debug.velLine = new THREE.Line(geo, MAT_VEL);
	  debug.velLine.frustumCulled = false;
	  debug.velLine.visible = false;
	  debug.group.add(debug.velLine);
	}

	function setVelLine(x0,y0,x1,y1,z=9){
	  ensureVelLine();
	  const pos = debug.velLine.geometry.attributes.position.array;
	  pos[0]=x0; pos[1]=y0; pos[2]=z;
	  pos[3]=x1; pos[4]=y1; pos[5]=z;
	  debug.velLine.geometry.attributes.position.needsUpdate = true;
	  debug.velLine.visible = debug.enabled;
	}

    function resize(){
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w,h, false);

      const viewH = 12;
      const aspect = w/h;
      const viewW = viewH * aspect;
      camera.left   = -viewW/2;
      camera.right  =  viewW/2;
      camera.top    =  viewH/2;
      camera.bottom = -viewH/2;
      camera.updateProjectionMatrix();
    }
    addEventListener("resize", resize);
    resize();

    // ----------------------------
    // ÌÖçÏä§Ï≤ò Î°úÎî©
    // ----------------------------
    const loader = new THREE.TextureLoader();

    const required = [
      "background_color_mushrooms.png",
      "character_green_idle.png",
      "character_green_walk_a.png",
      "character_green_walk_b.png",
      "character_green_walk_a_back.png",
      "character_green_walk_b_back.png",
      "character_green_jump.png",
      "character_green_jump_back.png",
      "character_green_hit.png",
      // ÏÇ¨Îßù/Ï∂îÎùΩ Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏(3ÌîÑÎ†àÏûÑ)
      "character_green_down.png",
      "character_green_duck.png",
      "character_green_front.png",
      "character_green_climb_a.png",
      "character_green_climb_b.png",
      "hud_coin.png",
      "slime_normal_flat.png",
      "slime_normal_rest.png",
      "slime_normal_walk_a.png",
	  "slime_normal_walk_b.png",
      "boss_whale_image.png",
      "boss_dragon_image.png",
      "boss_octopus_image.png",
      "boss_golem_image.png",
      "boss_peng_image.png",
      "water.png",
      "water_top.png",
      "water_top_low.png"
    ];

    // ‚úÖ BGM: Ï≤®Î∂Ä MP3 ÏÇ¨Ïö©(ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω Ïãú Ïó¨Í∏∞Îßå ÏàòÏ†ï)
    const BGM_URL = encodeURI("fun challenge.mp3");

    let _loadDone = 0;
    const _loadTotal = required.length + 1; // + BGM
    setLoading(_loadDone, _loadTotal, "Resource Loading...");

    function markLoaded(label){
      _loadDone++;
      setLoading(_loadDone, _loadTotal, label);
    }

    const loadTex = (url)=>new Promise((resolve,reject)=>{
      loader.load(url, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        markLoaded(url);
        resolve(t);
      }, undefined, (e)=>reject(e));
    });

    function loadBGM(url){
      return new Promise((resolve, reject)=>{
        const a = new Audio();
        a.preload = "auto";
        a.loop = true;
        a.src = url;

        const done = ()=>{
          cleanup();
          markLoaded("BGM");
          resolve(a);
        };
        const fail = ()=>{
          cleanup();
          reject(new Error("BGM Loading Failed: MP3 File(fun challenge.mp3) check File Path."));
        };
        const cleanup = ()=>{
          a.removeEventListener("canplaythrough", done);
          a.removeEventListener("loadeddata", done);
          a.removeEventListener("error", fail);
        };

        // ÏùºÎ∂Ä ÌôòÍ≤ΩÏóêÏÑú canplaythroughÍ∞Ä Ïïà Îú®Îäî Í≤ΩÏö∞Í∞Ä ÏûàÏñ¥ loadeddataÎèÑ Í∞ôÏù¥ Î∞õÏäµÎãàÎã§.
        a.addEventListener("canplaythrough", done, { once:true });
        a.addEventListener("loadeddata", done, { once:true });
        a.addEventListener("error", fail, { once:true });

        try{ a.load(); }catch(_){}
      });
    }

    let TEX = {};
    let BOSS_TEX = {};
    let BOSS_TEX_WHALE = null;
    let BOSS_TEX_DRAGON = null;
    let BOSS_TEX_OCTOPUS = null;
    let BOSS_TEX_GOLEM = null;
    let BOSS_TEX_PENG = null;
    let PLAYER_DOWN = { frames:[], fw:0, fh:0 };
    const WATER_H = 16;
    let waterTexs = [];
    let waterMeshes = [];
    try{
      const texPs = required.map(loadTex);
      const bgmEl = await loadBGM(BGM_URL);
      const [bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale, bossDragon, bossOctopus, bossGolem, bossPeng, waterBase, waterTop, waterTopLow] = await Promise.all(texPs);

      TEX = { bg, idle, walkA, walkB, walkABack, walkBBack, jump, jumpBack, hit, downSheet, duck, front, climbA, climbB, hudCoin, slimeFlat, slimeRest, slimeWalkA, slimeWalkB, bossWhale, bossDragon, bossOctopus, bossGolem, bossPeng };

      waterTexs = [waterBase, waterTop, waterTopLow];
      for(const t of waterTexs){
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
      }
      waterTexs[0].repeat.set(3, 1.2);
      waterTexs[1].repeat.set(3.5, 1.2);
      waterTexs[2].repeat.set(4, 1.2);

      const waterGeo = new THREE.PlaneGeometry(280, WATER_H);
      const waterMats = [
        new THREE.MeshBasicMaterial({ map: waterTexs[0], transparent:true, opacity:0.92 }),
        new THREE.MeshBasicMaterial({ map: waterTexs[1], transparent:true, opacity:0.80 }),
        new THREE.MeshBasicMaterial({ map: waterTexs[2], transparent:true, opacity:0.72 }),
      ];
      const waterYs = [-6.7, -6.3, -6.5];
      const waterZs = [-2.8, -2.7, -2.75];
      waterMeshes = waterMats.map((mat, i)=>{
        const m = new THREE.Mesh(waterGeo, mat);
        m.position.set(0, waterYs[i], waterZs[i]);
        m.userData.baseY = waterYs[i];
        m.frustumCulled = false;
        scene.add(m);
        return m;
      });

      // ----------------------------
      // Î≥¥Ïä§(Í≥†Îûò) Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏ Î∂ÑÌï†(4x4, ÌÉÄÏùº 256px)
      //  - ÌååÏùº: boss_whale_image.png (index.htmlÍ≥º Í∞ôÏùÄ Ìè¥ÎçîÏóê ÎëêÏÑ∏Ïöî)
      // ----------------------------
      function sliceSheet(sheet, col, row, tile=256){
        const c = document.createElement("canvas");
        c.width = tile; c.height = tile;
        const g = c.getContext("2d");
        // row=0Ïù¥ Ïù¥ÎØ∏ÏßÄ ÏµúÏÉÅÎã®
        g.clearRect(0,0,tile,tile);
        g.drawImage(sheet.image, col*tile, row*tile, tile, tile, 0,0, tile, tile);
        const t = new THREE.CanvasTexture(c);
        t.colorSpace = THREE.SRGBColorSpace;
        t.needsUpdate = true;
        return t;
      }

      BOSS_TEX = {
        idleA:  sliceSheet(bossWhale, 0, 0),
        attackA:sliceSheet(bossWhale, 1, 0),
        attackB:sliceSheet(bossWhale, 2, 0),
        idleB:  sliceSheet(bossWhale, 3, 0),

        tailA:  sliceSheet(bossWhale, 0, 1),
        tailB:  sliceSheet(bossWhale, 1, 1),
        charge: sliceSheet(bossWhale, 2, 1),
        tailC:  sliceSheet(bossWhale, 3, 1),

        eyeA:   sliceSheet(bossWhale, 0, 2),
        smile:  sliceSheet(bossWhale, 1, 2),
        hurt:   sliceSheet(bossWhale, 2, 2),
        eyeB:   sliceSheet(bossWhale, 3, 2),
      };


// Í≥†Îûò ÌÖçÏä§Ï≤òÎ•º Î≥¥Í¥Ä(ÎìúÎûòÍ≥§/Í≥†Îûò Ï†ÑÌôòÏö©)
BOSS_TEX_WHALE = BOSS_TEX;

// ----------------------------
// Î≥¥Ïä§(ÎìúÎûòÍ≥§) Ïä§ÌîÑÎùºÏù¥Ìä∏ Î∂ÑÌï†(ÏûêÎèô 5ÌîÑÎ†àÏûÑ Í∞êÏßÄ)
//  - ÌååÏùº: boss_dragon_image.png
//  - ÌòÑÏû¨ Ï≤®Î∂Ä Ïù¥ÎØ∏ÏßÄÎäî Í∞ÄÎ°ú 2048pxÎ°ú 5Îì±Î∂ÑÏù¥ Îî± Îñ®Ïñ¥ÏßÄÏßÄ ÏïäÏïÑ(2048/5=409.6),
//    Ìà¨Î™Ö ÏïåÌååÎ•º Í∏∞Î∞òÏúºÎ°ú ÌîÑÎ†àÏûÑ Íµ¨Í∞ÑÏùÑ ÏûêÎèô Í∞êÏßÄÌï©ÎãàÎã§.
// ----------------------------
function sliceStripAuto(sheet, expected=5){
  const img = sheet.image;
  const cw = img.width, ch = img.height;

  const c0 = document.createElement("canvas");
  c0.width = cw; c0.height = ch;
  const g0 = c0.getContext("2d");
  g0.clearRect(0,0,cw,ch);
  g0.drawImage(img, 0,0);

  let boxes = [];
  try{
    const data = g0.getImageData(0,0,cw,ch).data;
    const colHas = new Uint8Array(cw);

    // alpha Ìà¨ÏòÅ(Ïó¥ Îã®ÏúÑ)
    for(let x=0; x<cw; x++){
      let hit = 0;
      for(let y=0; y<ch; y++){
        const a = data[(y*cw + x)*4 + 3];
        if(a > 10){ hit = 1; break; }
      }
      colHas[x] = hit;
    }

    // Ïó∞ÏÜç Íµ¨Í∞Ñ(ÌîÑÎ†àÏûÑ ÌõÑÎ≥¥) Ï∞æÍ∏∞
    let inSeg=false, s=0;
    for(let x=0; x<cw; x++){
      if(!inSeg && colHas[x]){
        inSeg=true; s=x;
      }else if(inSeg && !colHas[x]){
        const e = x-1;
        if(e-s > 10) boxes.push([s, e]);
        inSeg=false;
      }
    }
    if(inSeg){
      const e = cw-1;
      if(e-s > 10) boxes.push([s, e]);
    }

    // ÏÑ∏Î°ú Î∞îÏö¥Îî©(Í∞Å Íµ¨Í∞ÑÎ≥Ñ)
    const refined = [];
    for(const [sx, ex] of boxes){
      let top = ch-1, bot = 0;
      for(let y=0; y<ch; y++){
        for(let x=sx; x<=ex; x++){
          const a = data[(y*cw + x)*4 + 3];
          if(a > 10){
            if(y < top) top = y;
            if(y > bot) bot = y;
            break;
          }
        }
      }
      // Ïó¨Î∞± Ï°∞Í∏à
      const pad = 2;
      const x0 = Math.max(0, sx - pad);
      const x1 = Math.min(cw-1, ex + pad);
      const y0 = Math.max(0, top - pad);
      const y1 = Math.min(ch-1, bot + pad);
      if(x1-x0 > 12 && y1-y0 > 12) refined.push({x:x0, y:y0, w:(x1-x0+1), h:(y1-y0+1)});
    }

    // Ï¢å‚ÜíÏö∞ Ï†ïÎ†¨
    refined.sort((a,b)=>a.x-b.x);

    // Í∏∞ÎåÄ ÌîÑÎ†àÏûÑ ÏàòÎ≥¥Îã§ ÎßéÏúºÎ©¥, Î©¥Ï†Å ÌÅ∞ Í≤É ÏúÑÏ£ºÎ°ú Í≥†Î•¥Í≥† Îã§Ïãú Ï¢å‚ÜíÏö∞ Ï†ïÎ†¨
    if(refined.length > expected){
      refined.sort((a,b)=>(b.w*b.h)-(a.w*a.h));
      refined.length = expected;
      refined.sort((a,b)=>a.x-b.x);
    }

    if(refined.length === expected){
      boxes = refined;
    }else{
      boxes = [];
    }
  }catch(_){
    boxes = [];
  }

  // Í∞êÏßÄ Ïã§Ìå® Ïãú Í∑†Îì± Î∂ÑÌï† Ìè¥Î∞±(ÎßàÏßÄÎßâ ÏïàÏ†ÑÏû•Ïπò)
  if(!boxes || boxes.length !== expected){
    const fw = Math.floor(cw / expected);
    const fh = ch;
    const out = [];
    for(let i=0;i<expected;i++){
      const c = document.createElement("canvas");
      c.width = fw; c.height = fh;
      const g = c.getContext("2d");
      g.clearRect(0,0,fw,fh);
      g.drawImage(img, i*fw, 0, fw, fh, 0, 0, fw, fh);
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.needsUpdate = true;
      out.push(t);
    }
    return out;
  }

  // Í∞êÏßÄ ÏÑ±Í≥µ: Í∞Å bboxÎ°ú Ï∫îÎ≤ÑÏä§ ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
  const out = [];
  for(const b of boxes){
    const c = document.createElement("canvas");
    c.width = b.w; c.height = b.h;
    const g = c.getContext("2d");
    g.clearRect(0,0,b.w,b.h);
    g.drawImage(img, b.x, b.y, b.w, b.h, 0,0, b.w, b.h);
    const t = new THREE.CanvasTexture(c);
    t.colorSpace = THREE.SRGBColorSpace;
    t.needsUpdate = true;
    out.push(t);
  }
  return out;
}

   const dragonFrames = sliceStripAuto(bossDragon, 5);

	// ÎìúÎûòÍ≥§ 5Ìè¨Ï¶àÎ•º idle/attackÏóê Îß§Ìïë
	// (Ï∂îÏ∏°) Ï¢å‚ÜíÏö∞ ÏàúÏÑú: roarA, roarB, glide, cute, calm
	BOSS_TEX_DRAGON = {
	  attackA: dragonFrames[0] || dragonFrames[1] || dragonFrames[2],
	  attackB: dragonFrames[1] || dragonFrames[0] || dragonFrames[2],
	  idleA:   dragonFrames[3] || dragonFrames[2] || dragonFrames[4],
	  idleB:   dragonFrames[4] || dragonFrames[3] || dragonFrames[2],
	  charge:  dragonFrames[2] || dragonFrames[0],
	  hurt:    dragonFrames[2] || dragonFrames[1],
	};

  // ----------------------------
  // Î≥¥Ïä§(Î¨∏Ïñ¥) Ïä§ÌîÑÎùºÏù¥Ìä∏ Î∂ÑÌï†(5ÌîÑÎ†àÏûÑ)
  //  - ÌååÏùº: boss_octopus_image.png
  //  - Ï≤®Î∂Ä Ïù¥ÎØ∏ÏßÄÎäî 5Í∞úÏùò Ìè¨Ï¶àÍ∞Ä Í∞ÄÎ°úÎ°ú Ïù¥Ïñ¥ÏßÑ Ïä§Ìä∏Î¶ΩÏûÖÎãàÎã§.
  //    (ÏïàÏ†ÑÌïòÍ≤å ÏïåÌåå Í∏∞Î∞ò ÏûêÎèô Í∞êÏßÄ Î°úÏßÅ Ïû¨ÏÇ¨Ïö©)
  // ----------------------------
  const octoFrames = sliceStripAuto(bossOctopus, 5);

  // Î¨∏Ïñ¥ 5Ìè¨Ï¶àÎ•º idle/attackÏóê Îß§Ìïë
  // (Ï∂îÏ∏°) Ï¢å‚ÜíÏö∞: Ï°∏Î¶∞/ÎØ∏ÏÜå/Í∏∞ÏÅ®/ÎÜÄÎûå/Î∂ÑÎÖ∏
  BOSS_TEX_OCTOPUS = {
    idleA:   octoFrames[0] || octoFrames[1] || octoFrames[2],
    idleB:   octoFrames[1] || octoFrames[0] || octoFrames[2],
    attackA: octoFrames[2] || octoFrames[3] || octoFrames[4],
    attackB: octoFrames[3] || octoFrames[2] || octoFrames[4],
    charge:  octoFrames[3] || octoFrames[2],
    hurt:    octoFrames[4] || octoFrames[3],
  };

  // ----------------------------
  // Î≥¥Ïä§(Í≥®Î†ò) Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏ Î∂ÑÌï†(4ÌîÑÎ†àÏûÑ)
  //  - ÌååÏùº: boss_golem_image.png
  // ----------------------------
  const golemFrames = sliceStripAuto(bossGolem, 4);
  BOSS_TEX_GOLEM = {
    idleA:   golemFrames[0] || golemFrames[1] || golemFrames[2],
    idleB:   golemFrames[1] || golemFrames[0] || golemFrames[2],
    attackA: golemFrames[2] || golemFrames[3] || golemFrames[1],
    attackB: golemFrames[3] || golemFrames[2] || golemFrames[1],
    charge:  golemFrames[2] || golemFrames[3] || golemFrames[1],
    hurt:    golemFrames[1] || golemFrames[0],
  };

  // ----------------------------
  // Î≥¥Ïä§(Ìé≠Í∑Ñ) Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏ Î∂ÑÌï†(4ÌîÑÎ†àÏûÑ)
  //  - ÌååÏùº: boss_peng_image.png
  // ----------------------------
  const pengFrames = sliceStripAuto(bossPeng, 4);
  BOSS_TEX_PENG = {
    idleA:   pengFrames[0] || pengFrames[1] || pengFrames[2],
    idleB:   pengFrames[1] || pengFrames[0] || pengFrames[2],
    attackA: pengFrames[2] || pengFrames[3] || pengFrames[1],
    attackB: pengFrames[3] || pengFrames[2] || pengFrames[1],
    charge:  pengFrames[2] || pengFrames[3] || pengFrames[1],
    hurt:    pengFrames[1] || pengFrames[0],
  };

	// Í∏∞Î≥∏ Î≥¥Ïä§Îäî Í≥†Îûò
	BOSS_TEX = BOSS_TEX_WHALE;
      // ----------------------------
      // ÌîåÎ†àÏù¥Ïñ¥ ÏÇ¨Îßù/Ï∂îÎùΩ Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏(Í∞ÄÎ°ú 3ÌîÑÎ†àÏûÑ)
      //  - ÌååÏùº: character_green_down.png
      // ----------------------------
      function sliceStrip(sheet, frames=3){
        const img = sheet.image;
        const fw = Math.floor(img.width / frames);
        const fh = img.height;
        const out = [];
        for(let i=0;i<frames;i++){
          const c = document.createElement("canvas");
          c.width = fw; c.height = fh;
          const g = c.getContext("2d");
          g.clearRect(0,0,fw,fh);
          g.drawImage(img, i*fw, 0, fw, fh, 0, 0, fw, fh);
          const t = new THREE.CanvasTexture(c);
          t.colorSpace = THREE.SRGBColorSpace;
          t.needsUpdate = true;
          out.push(t);
        }
        return { frames: out, fw, fh };
      }
      PLAYER_DOWN = sliceStrip(downSheet, 3);


      // ÏÇ¨Ïö¥ÎìúÏóê BGM MP3 Ï£ºÏûÖ
      sound.bgmEl = bgmEl;
      try{ applySoundGains(); }catch(_){}

      showReadyToStart();
    }catch(err){
      console.error(err);
      if($loadText) $loadText.textContent = "Loading Failed: File Path Error";
      showToast((err && err.message) ? err.message : "Resource Loading Failed", 4000);
      throw err;
    }

    function alignWaterToGround(bottomY){
      if(!waterMeshes.length) return;
      const baseY = bottomY - (WATER_H * 0.5);
      const offsets = [0.0, 0.35, 0.18];
      for(let i=0;i<waterMeshes.length;i++){
        const m = waterMeshes[i];
        m.userData.baseY = baseY + (offsets[i] || 0);
        m.position.y = m.userData.baseY;
      }
    }


    // ----------------------------
    // CanvasTexture ÏÉùÏÑ±Í∏∞
    // ----------------------------
    function makeCanvasTexture(drawFn, w=256, h=256){
      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const g = canvas.getContext("2d");
      drawFn(g, w, h);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ----------------------------
    // Î∞∞Í≤Ω
    // ----------------------------
    const bgTex = TEX.bg;
    bgTex.wrapS = bgTex.wrapT = THREE.RepeatWrapping;
    bgTex.repeat.set(8, 4);

    const bgPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(260, 92),
      new THREE.MeshBasicMaterial({ map: bgTex })
    );
    bgPlane.position.set(0, 6, -5);
    scene.add(bgPlane);


    // ----------------------------
    // ÏõîÎìú Îç∞Ïù¥ÌÑ∞
    // ----------------------------
    const world = {
      platforms: [],
      coins: [],
      enemies: [],
      springs: [],
      ladders: [],
      particles: [],
      afterimages: [],
      bossAfterimages: [],
      bossBullets: [],
      boss: null,
      goal: null,

      totalCoinsLevel: 0,
      collectedCoinsLevel: 0,

      // ÏΩîÏù∏ Ïú†ÏßÄ Ï†ïÏ±ÖÏö©
      totalCoinsRun: 0,
      totalCoinsRunAtLevelStart: 0,

      // Ïπ¥Î©îÎùº/Ï∂îÎùΩ ÌåêÏ†ïÏö©(Î†àÎ≤® ÏÉùÏÑ± Ïãú Í∞±Ïã†)
      groundTop: -0.6,
      killY: -12,
    };

    // ----------------------------
    // ÏõîÎìú ÌÖçÏä§Ï≤ò
    // ----------------------------
    const texPlatform = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const grd = g.createLinearGradient(0,0,0,h);
      grd.addColorStop(0, "#f3a66c");
      grd.addColorStop(1, "#cf6b3e");
      g.fillStyle = grd;
      g.fillRect(0,0,w,h);

      g.fillStyle = "#41c85f";
      g.fillRect(0,0,w, 64);
      g.fillStyle = "#2aa44a";
      for(let x=0;x<w;x+=22){
        g.beginPath();
        g.arc(x+10, 62, 8, 0, Math.PI*2);
        g.fill();
      }

      g.globalAlpha = .18;
      g.fillStyle = "#000";
      for(let y=90;y<h;y+=56) g.fillRect(0, y, w, 8);
      g.globalAlpha = 1;
    });

    const texCoin = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2, r=90;

      g.fillStyle="#f7d34c";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();

      const grd = g.createRadialGradient(cx-30, cy-30, 10, cx, cy, r);
      grd.addColorStop(0, "#fff2a8");
      grd.addColorStop(1, "#e0a600");
      g.fillStyle=grd;
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.fill();

      g.globalAlpha=.35;
      g.fillStyle="#b56b00";
      g.beginPath(); g.arc(cx,cy, r*0.35,0,Math.PI*2); g.fill();
      g.globalAlpha=1;

      g.lineWidth = 18;
      g.strokeStyle = "rgba(0,0,0,.30)";
      g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.stroke();

      g.lineWidth = 10;
      g.strokeStyle = "rgba(255,255,255,.22)";
      g.beginPath(); g.arc(cx,cy,r*0.82,0,Math.PI*2); g.stroke();
    });

    const texSlimeFlat = TEX.slimeFlat;
    const texSlimeRest = TEX.slimeRest;
    const texSlimeWalkA = TEX.slimeWalkA;
	const texSlimeWalkB = TEX.slimeWalkB;
    // Í∏∞Î≥∏ Ïä¨ÎùºÏûÑ ÌÖçÏä§Ï≥ê
    const texSlime = texSlimeRest;

    const texSpring = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle = "#f2b23d";
      g.fillRect(60, 180, 136, 46);

      g.strokeStyle = "#be3e2c";
      g.lineWidth = 16;
      g.lineCap="round";
      let y = 170;
      g.beginPath();
      for(let x=40; x<=216; x+=22){
        g.lineTo(x, y + Math.sin(x*0.12)*26);
      }
      g.stroke();
    });

    const texFlagOff = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);
      g.fillStyle="#ffd4aa";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(200, 70, 220, 110);
      g.quadraticCurveTo(190, 140, 136, 150);
      g.closePath(); g.fill();
    });

    const texFlagOn = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e6e6e6";
      g.fillRect(110, 30, 26, 210);

      g.fillStyle="#ffcc3d";
      g.beginPath();
      g.moveTo(136, 50);
      g.quadraticCurveTo(210, 60, 228, 110);
      g.quadraticCurveTo(190, 145, 136, 155);
      g.closePath(); g.fill();

      g.fillStyle="rgba(0,0,0,.55)";
      g.fillRect(164, 78, 14, 44);
      g.beginPath(); g.arc(171, 132, 10, 0, Math.PI*2); g.fill();
    });

    const texLadder = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.fillStyle="#e18a55";
      g.fillRect(w*0.18, 0, w*0.16, h);
      g.fillRect(w*0.66, 0, w*0.16, h);

      g.fillStyle="#d47b49";
      const step=52;
      for(let yy=22; yy<h; yy+=step){
        g.fillRect(w*0.20, yy, w*0.60, 18);
      }
    }, 256, 512);
    texLadder.wrapS = texLadder.wrapT = THREE.RepeatWrapping;

    // ÍΩÉÏûé
    const texPetal = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      g.translate(w/2, h/2);
      g.rotate(-0.35);
      g.scale(1.1, 1.1);

      const grd = g.createRadialGradient(-20,-30, 10, 0,0, 110);
      grd.addColorStop(0, "rgba(255,255,255,.95)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;

      for(let i=0;i<4;i++){
        g.rotate(Math.PI/2);
        g.beginPath();
        g.moveTo(0, -10);
        g.bezierCurveTo(45,-55, 85,-10, 55, 50);
        g.bezierCurveTo(25, 95, -10, 75, -10, 35);
        g.closePath();
        g.fill();
      }
    }, 256, 256);

    // Ìè≠Ï£Ω Ïä§ÌååÌÅ¨(ÏõêÌòï)
    const texSpark = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      const grd = g.createRadialGradient(cx,cy, 0, cx,cy, w*0.45);
      grd.addColorStop(0, "rgba(255,255,255,1)");
      grd.addColorStop(0.2, "rgba(255,255,255,.7)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath(); g.arc(cx,cy, w*0.45, 0, Math.PI*2); g.fill();
    }, 128, 128);

    // "ÎøÖ" ÎßÅ(Îì±Ïû•/Î¶¨Ìè∞)
    const texSpawnRing = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2;
      // Ïô∏Í≥Ω ÎßÅ
      g.strokeStyle = "rgba(255,255,255,0.85)";
      g.lineWidth = w*0.08;
      g.beginPath();
      g.arc(cx, cy, w*0.34, 0, Math.PI*2);
      g.stroke();
      // ÏûîÍ¥ë
      const grd = g.createRadialGradient(cx,cy, w*0.08, cx,cy, w*0.48);
      grd.addColorStop(0, "rgba(255,255,255,0.35)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(cx, cy, w*0.48, 0, Math.PI*2);
      g.fill();
    }, 192, 192);

    // ----------------------------
    // ÏóîÌã∞Ìã∞ ÏÉùÏÑ±
    // ----------------------------
    function addPlatform(x,y,w,h){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({ map: texPlatform })
      );
      mesh.position.set(x+w/2, y+h/2, 1);
      scene.add(mesh);
      const p = { x,y,w,h, mesh, isSolid:true };
      world.platforms.push(p);
      return p;
    }

    // Î≤Ω/Ï∞®Îã®Ïö©(Í∞ôÏùÄ ÌîåÎû´Ìèº ÌÖçÏä§Ï≤ò ÏÇ¨Ïö©, Í∏∏Í≤å ÏÑ∏ÏõÄ)
    function addBlockWall(x,y,w,h){
      return addPlatform(x,y,w,h);
    }

    function addCoin(x,y){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(0.7,0.7),
        new THREE.MeshBasicMaterial({ map: (TEX.hudCoin || texCoin), transparent:true })
      );
      mesh.position.set(x, y, 2.2);
      scene.add(mesh);
      const c = { x, y, r:0.35, mesh, t: rand(0,10), dead:false };
      world.coins.push(c);
      world.totalCoinsLevel++;
      return c;
    }
	
	function coinOverlapsSolid(x,y,r=0.35){
	  const cx = x - r;
	  const cy = y - r;
	  const s  = r*2;
	  for(const p of world.platforms){
		// eps=0ÏúºÎ°ú ‚ÄúÏÇ¥ÏßùÏù¥ÎùºÎèÑ Í≤πÏπòÎ©¥‚Äù Í≤πÏπ®ÏúºÎ°ú Ï∑®Í∏â
		if(aabbIntersect(cx,cy,s,s, p.x,p.y,p.w,p.h, 0)) return true;
	  }
	  return false;
	}

	function safeAddCoin(x,y){
	  // 1) Í∏∞Î≥∏ ÏúÑÏπòÏóêÏÑú ÏúÑÎ°ú Ï°∞Í∏àÏî© Ïò¨Î†§Í∞ÄÎ©∞ ÏÜîÎ¶¨Îìú Í≤πÏπ® ÌöåÌîº
	  let yy = y;
	  for(let i=0;i<14;i++){
		if(!coinOverlapsSolid(x, yy)) return addCoin(x, yy);
		yy += 0.18;
	  }

	  // 2) Í∑∏ÎûòÎèÑ Ïïà ÎêòÎ©¥: x ÏïÑÎûòÏóê ÏûàÎäî ‚ÄúÍ∞ÄÏû• ÎÜíÏùÄ ÌîåÎû´Ìèº‚Äù ÏúÑÎ°ú Ïò¨Î†§ÏÑú ÏÉùÏÑ±
	  let bestTop = -Infinity;
	  for(const p of world.platforms){
		if(x > p.x + 0.4 && x < p.x + p.w - 0.4){
		  const top = p.y + p.h;
		  if(top > bestTop && top < yy + 10) bestTop = top;
		}
	  }
	  if(bestTop > -Infinity) return addCoin(x, bestTop + 0.8);

	  // 3) ÏµúÌõÑ fallback
	  return addCoin(x, y + 1.0);
	}

    function addEnemyOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.95),
        new THREE.MeshBasicMaterial({ map: texSlimeRest, transparent:true })
      );
      const yCenter = top + 0.33;
      mesh.position.set(xCenter, yCenter, 2.1);
      scene.add(mesh);

      const e = {
        x: xCenter,
        y: yCenter,
        w: 1.0,
        h: 0.65,
        vx: rand(-1,1) < 0 ? -rand(1.1, 1.7) : rand(1.1, 1.7),
        mesh,
        dead:false,
        roamMin: p.x+0.7,
        roamMax: p.x+p.w-0.7,
        animT: 0,
        texState: "rest",
        deathTimer: 0
      };
      world.enemies.push(e);
      return e;
    }

    function addSpringOnPlatform(p, xCenter){
      const top = p.y + p.h;
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.6),
        new THREE.MeshBasicMaterial({ map: texSpring, transparent:true })
      );
      const yCenter = top + 0.22;
      mesh.position.set(xCenter, yCenter, 2.05);
      scene.add(mesh);
      const s = { x: xCenter, y: yCenter, w:1.0, h:0.35, mesh };
      world.springs.push(s);
      return s;
    }


    // ----------------------------
    // ÏÇ¨Îã§Î¶¨(ÌÅ¥ÎùºÏûÑÏö©)
    //  - x,y,w,h: AABB(Î∞îÎã• Í∏∞Ï§Ä)
    //  - topLow/topHigh: ÌîåÎ†àÏù¥Ïñ¥ y(Ï§ëÏã¨) ÌÅ¥Îû®ÌîÑ Í∏∞Ï§ÄÏù¥ ÎêòÎäî "Î∞üÎäî ÎÜíÏù¥"(ÎåÄÍ∞ú ÏïÑÎûò/ÏúÑ Î∞úÌåêÏùò top)
    // ----------------------------
    function addLadder(x, y, w, h, topLow=null, topHigh=null){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(w, h),
        new THREE.MeshBasicMaterial({ map: texLadder, transparent:true, opacity: 0.95 })
      );
      mesh.position.set(x + w/2, y + h/2, 2.02);
      mesh.frustumCulled = false;

      // ÌÖçÏä§Ï≤ò Î∞òÎ≥µ(ÏÑ∏Î°ú Î∞©Ìñ•)
      try{
        mesh.material.map.repeat.set(Math.max(1, w/1.2), Math.max(1, h/1.6));
        mesh.material.map.needsUpdate = true;
      }catch(_e){}

      scene.add(mesh);

      const l = {
        x, y, w, h,
        topLow: (topLow==null ? y : topLow),
        topHigh: (topHigh==null ? (y+h) : topHigh),
        mesh
      };
      world.ladders.push(l);
      return l;
    }


    // ÏÇ¨Îã§Î¶¨: ÏïÑÎûò Î∏îÎ°ù top ~ ÏúÑ Î∏îÎ°ù top
    function addGoalWithBase(pBase){
      const baseTop = pBase.y + pBase.h;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 1.6),
        new THREE.MeshBasicMaterial({ map: texFlagOff, transparent:true })
      );
      const x = pBase.x + pBase.w - 1.2;
      const y = baseTop + 0.85;
      mesh.position.set(x, y, 2.0);
      scene.add(mesh);

      world.goal = { x, y, w:0.8, h:1.2, mesh, active:false, base: pBase };
      return world.goal;
    }

    // ----------------------------
    // ÌååÌã∞ÌÅ¥
    // ----------------------------
    const geoTiny = new THREE.PlaneGeometry(0.10,0.10);
    const geoDust = new THREE.PlaneGeometry(0.16,0.16);
    const geoPetal = new THREE.PlaneGeometry(0.28,0.28);
    const geoSpark = new THREE.PlaneGeometry(0.18,0.18);

    const MAX_PARTICLES = 800;
    const MAX_BOSS_AFTERIMAGES = 40;

    const matSpark = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.85 });
    const matDust = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:.45 });
    const matDirt = [
      new THREE.MeshBasicMaterial({ color: 0x8a6a3c, transparent:true, opacity:.55 }),
      new THREE.MeshBasicMaterial({ color: 0x7a4f2a, transparent:true, opacity:.55 }),
      new THREE.MeshBasicMaterial({ color: 0x9b7a4a, transparent:true, opacity:.55 }),
    ];
    const matIce = [
      new THREE.MeshBasicMaterial({ color: 0xbfe9ff, transparent:true, opacity:.7 }),
      new THREE.MeshBasicMaterial({ color: 0x8fd2ff, transparent:true, opacity:.7 }),
      new THREE.MeshBasicMaterial({ color: 0x6fb6ff, transparent:true, opacity:.7 }),
    ];

    function spawnParticles(x,y,n=10, power=1){
      const room = Math.max(0, MAX_PARTICLES - world.particles.length);
      if(room <= 0) return;
      const count = Math.min(n, room);
      for(let i=0;i<count;i++){
        const mesh = new THREE.Mesh(
          geoTiny,
          matSpark
        );
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.6);
        scene.add(mesh);
        world.particles.push({
          kind:"spark",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-2.2,2.2)*power,
          vy: rand(0.8,3.4)*power,
          life: rand(0.25,0.55),
          mesh, spin: rand(-6,6)
        });
      }
    }

    function spawnDust(x,y, n=6){
      const room = Math.max(0, MAX_PARTICLES - world.particles.length);
      if(room <= 0) return;
      const count = Math.min(n, room);
      for(let i=0;i<count;i++){
        const mesh = new THREE.Mesh(
          geoDust,
          matDust
        );
        mesh.position.set(x + rand(-0.25,0.25), y + rand(-0.05,0.15), 2.55);
        scene.add(mesh);
        world.particles.push({
          kind:"dust",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-1.8,1.8),
          vy: rand(0.6,2.2),
          life: rand(0.16,0.34),
          mesh, spin: rand(-4,4)
        });
      }
    }

    function spawnDirt(x,y, n=8){
      const room = Math.max(0, MAX_PARTICLES - world.particles.length);
      if(room <= 0) return;
      const count = Math.min(n, room);
      for(let i=0;i<count;i++){
        const mesh = new THREE.Mesh(
          geoDust,
          choice(matDirt)
        );
        mesh.position.set(x + rand(-0.28,0.28), y + rand(-0.08,0.18), 2.56);
        scene.add(mesh);
        world.particles.push({
          kind:"dirt",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-2.2,2.2),
          vy: rand(0.8,2.6),
          life: rand(0.18,0.36),
          mesh, spin: rand(-5,5)
        });
      }
    }

    function spawnIceShards(x,y, n=10){
      const room = Math.max(0, MAX_PARTICLES - world.particles.length);
      if(room <= 0) return;
      const count = Math.min(n, room);
      for(let i=0;i<count;i++){
        const mesh = new THREE.Mesh(
          geoDust,
          choice(matIce)
        );
        mesh.position.set(x + rand(-0.3,0.3), y + rand(-0.10,0.22), 2.57);
        scene.add(mesh);
        world.particles.push({
          kind:"ice",
          x: mesh.position.x, y: mesh.position.y,
          vx: rand(-2.6,2.6),
          vy: rand(1.0,3.0),
          life: rand(0.16,0.32),
          mesh, spin: rand(-6,6)
        });
      }
    }


    function spawnFlowerBurst(x,y, n=90){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.95,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        mesh.position.set(x + rand(-0.2,0.2), y + rand(-0.1,0.1), 2.85);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        const spd = rand(4.0, 12.0);
        const ang = rand(-Math.PI*0.15, Math.PI*1.15);
        world.particles.push({
          kind:"petal",
          x: mesh.position.x, y: mesh.position.y,
          vx: Math.cos(ang)*spd + rand(-1.5,1.5),
          vy: Math.sin(ang)*spd + rand(2.0,8.0),
          life: rand(1.4, 2.6),
          mesh,
          spin: rand(-10, 10),
          sway: rand(6, 12)
        });
      }
    }

    // ‚úÖ ÍΩÉÎπÑ(ÏßÄÏÜç): ÌôîÎ©¥ ÏÉÅÎã®ÏóêÏÑú Îñ®Ïñ¥Ïßê
    function spawnFlowerRain(camX, camY, viewW, viewH, n=10){
      const colors = [0xff7eb6,0xffa7d6,0xffd1f0,0xfff1b8,0xb8ffdf,0xa0e7ff,0xffffff];
      for(let i=0;i<n;i++){
        const mat = new THREE.MeshBasicMaterial({
          map: texPetal,
          color: choice(colors),
          transparent:true,
          opacity: 0.85,
          depthWrite:false
        });
        const mesh = new THREE.Mesh(geoPetal, mat);
        const x = camX + rand(-viewW*0.55, viewW*0.55);
        const y = camY + viewH*0.65 + rand(0.4, 2.4);
        mesh.position.set(x, y, 2.86);
        mesh.rotation.z = rand(-Math.PI, Math.PI);
        scene.add(mesh);

        world.particles.push({
          kind:"petalRain",
          x, y,
          vx: rand(-1.2,1.2),
          vy: rand(-2.0,-7.5), // ÏïÑÎûòÎ°ú ÏãúÏûë
          life: rand(1.2, 2.2),
          mesh,
          spin: rand(-6, 6),
          sway: rand(4, 10)
        });
      }
    }

    // ‚úÖ Ìè≠Ï£Ω: Additive + Îã§ÏÉâ Ïä§ÌååÌÅ¨
    function spawnFirework(cx, cy){
      SFX.firework();

      const palette = [0xff3b3b,0xffcc3d,0x8bff6a,0x3ddcff,0xb46bff,0xffffff,0xff7eb6];
      const count = 70;
      for(let i=0;i<count;i++){
        const col = choice(palette);
        const mat = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: col,
          transparent:true,
          opacity: 0.95,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const mesh = new THREE.Mesh(geoSpark, mat);
        mesh.position.set(cx, cy, 2.9);
        scene.add(mesh);

        const a = rand(0, Math.PI*2);
        const sp = rand(5.5, 15.5);
        world.particles.push({
          kind:"firework",
          x: cx, y: cy,
          vx: Math.cos(a)*sp + rand(-1.0,1.0),
          vy: Math.sin(a)*sp + rand(1.0,4.0),
          life: rand(0.9, 1.6),
          mesh,
          spin: rand(-12, 12),
          drag: rand(0.90, 0.95)
        });
      }
      // Ï§ëÏïô ÌîåÎûòÏãú
      spawnParticles(cx, cy, 18, 1.3);
      screenShake(0.10, 0.14);
    }

    // Afterimage
    function spawnAfterimage(x,y, tex, sx, sy, opts = {}){
      const life = (opts.life ?? 0.22);
      const opacity = (opts.opacity ?? 0.35);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity });
      const sp = new THREE.Sprite(mat);
      sp.position.set(x, y, 2.9);
      sp.scale.set(sx, sy, 1);
      scene.add(sp);
      world.afterimages.push({ sp, life, lifeMax: life, opacity });
    }

    function spawnBossAfterimage(b, tex){
      if(!b || !b.mesh) return;
      if(world.bossAfterimages.length >= MAX_BOSS_AFTERIMAGES) return;
      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent:true,
        opacity: 0.26,
        color: 0xaad9ff,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });
      const mesh = new THREE.Mesh(b.mesh.geometry, mat);
      mesh.position.set(b.x, b.y, 1.05);
      mesh.scale.set(b.mesh.scale.x || 1, b.mesh.scale.y || 1, 1);
      mesh.frustumCulled = false;
      scene.add(mesh);
      world.bossAfterimages.push({ mesh, life: 0.26, lifeMax: 0.26, opacity: 0.26 });
    }

    // ÌôîÎ©¥ ÌùîÎì§Î¶º
    let shakeT=0, shakeP=0;
    function screenShake(t=0.12, p=0.12){ shakeT = Math.max(shakeT, t); shakeP = Math.max(shakeP, p); }

    
    // ‚úÖ Ï∂îÎùΩ/Ï£ΩÏùå Ìå°! Ïó∞Ï∂ú (Í∞ÑÎã® + ÌîÑÎ°ú ÎäêÎÇå)
    function spawnPop(x, y){
      // ÌîåÎûòÏãú
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // ÌååÌé∏/Î®ºÏßÄ
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // Ï∂îÍ∞Ä Ïä§ÌååÌÅ¨
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ÏãúÏûë/Î¶¨Ïä§Ìè∞ "ÎøÖ" Ïó∞Ï∂ú(ÎßÅ + ÏûëÏùÄ Î∞òÏßù)
    function spawnAppear_origin(x, y){
      // ÎßÅ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false, //falsse
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.15);
      mesh.scale.set(0.85, 0.85, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRing",
        x, y,
        vx:0, vy:0,
        life: 0.8, //0.34,
        mesh,
        spin: rand(-6, 6)
      });

      // ÏûëÏùÄ Ïä§ÌååÌÅ¥
      for(let i=0;i<10;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(2.8, 5.2);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.75,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        m2.scale.set(0.55, 0.55, 1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd + rand(0.8, 2.2),
          life: rand(0.20, 0.30),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }
	    // Î≥ÄÍ≤ΩÌïú ÏãúÏûë/Î¶¨Ïä§Ìè∞ "ÎøÖ" Ïó∞Ï∂ú(ÎßÅ + ÏûëÏùÄ Î∞òÏßù)
    function spawnAppear(x, y){
      // ÌîåÎûòÏãú
      const mat = new THREE.MeshBasicMaterial({
        map: texSpark,
        color: 0xffffff,
        transparent:true,
        opacity: 0.95,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.2);
      mesh.scale.set(2.1, 2.1, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"popFlash",
        x, y,
        vx:0, vy:0,
        life: 0.22,
        mesh,
        spin: rand(-10, 10)
      });

      // ÌååÌé∏/Î®ºÏßÄ
      spawnParticles(x, y, 28, 1.35);
      spawnDust(x, y, 16);

      // Ï∂îÍ∞Ä Ïä§ÌååÌÅ¨
      for(let i=0;i<18;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(5.5, 10.5);
        const mat2 = new THREE.MeshBasicMaterial({
          map: texSpark,
          color: 0xffffff,
          transparent:true,
          opacity: 0.85,
          depthWrite:false,
          blending: THREE.AdditiveBlending
        });
        const m2 = new THREE.Mesh(geoSpark, mat2);
        m2.position.set(x, y, 3.1);
        scene.add(m2);
        world.particles.push({
          kind:"popSpark",
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: rand(0.28, 0.45),
          mesh: m2,
          spin: rand(-10, 10)
        });
      }
    }

    // ÏÇ¨Îßù "ÏïÑÏâ¨Ïö¥" Ïó∞Ï∂ú(Í≥ºÌïú Ìè≠Î∞ú ÎåÄÏã† ÏûëÏùÄ ÏûîÍ¥ë)
    function spawnDeathPoof(x, y){
      // ÏûëÏùÄ ÎßÅ
      const mat = new THREE.MeshBasicMaterial({
        map: texSpawnRing,
        color: 0xffffff,
        transparent:true,
        opacity: 0.70,
        depthWrite:false,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geoSpark, mat);
      mesh.position.set(x, y, 3.12);
      mesh.scale.set(0.55, 0.55, 1);
      scene.add(mesh);
      world.particles.push({
        kind:"spawnRingSmall",
        x, y,
        vx:0, vy:0,
        life: 0.26,
        mesh,
        spin: rand(-6, 6)
      });

      // ÏµúÏÜåÌïúÏùò ÌååÌé∏
      spawnParticles(x, y, 12, 0.85);
      spawnDust(x, y, 8);
    }

// ----------------------------
    // Celeste ÎäêÎÇå ÌîåÎ†àÏù¥Ïñ¥(ÌïµÏã¨: 8Î∞©Ìñ• 1Ìöå ÏóêÏñ¥ÎåÄÏãú)
    // ----------------------------
    const GRAVITY_UP     = -30.0;
    const GRAVITY_DOWN   = -40.0;
    const FAST_FALL_MULT =  1.55;
    const APEX_VY        =  1.25;
    const APEX_GRAV_MULT =  0.65;

    const MOVE_MAX       =  11.0;
    const GROUND_ACCEL   =  26.0;
    const GROUND_BRAKE   =  30.0;
    const AIR_ACCEL      =  14.0;
    const AIR_BRAKE      =  10.0;
    const TURN_BOOST     =  1.40;
    const RUN_HOLD_TIME  =  1.0;
    const RUN_SPEED_MAX  =  MOVE_MAX * 2.45; //1.45
    const RUN_ACCEL_MULT =  2.35;
    const RUN_TRAIL_INTERVAL = 0.025;
    const RUN_TRAIL_LIFE =  0.18;
    const RUN_TRAIL_OPACITY = 0.28;
    const RUN_SFX_INTERVAL = 0.28;

    const JUMP_V         =  14.6;
    const JUMP_CUT       =  0.55;
    const JUMP_HOLD_TIME =  0.12;
    const JUMP_HOLD_GRAV =  0.45;

    const COYOTE         =  0.11;
    const JUMP_BUF       =  0.12;

    // ‚úÖ 8Î∞©Ìñ• ÎåÄÏãú(1Ìöå) - Í≥µÏ§ë 1Ìöå, ÎïÖ/ÏÇ¨Îã§Î¶¨ Ï†ëÏ¥â Ïãú Î¶¨ÌïÑ
    const DASH_SPEED     =  18.8;
    const DASH_TIME      =  0.15;
    const DASH_COOLDOWN  =  0.10;
    const DASH_CHARGES_MAX = 1;

    const STAND_H        =  1.55;
    const DUCK_H         =  1.00;        // ÏàôÏù¥Í∏∞ ÌÜµÍ≥º ÌôïÏã§ÌïòÍ≤å
    const DUCK_SPEED_MUL =  0.60;

    const CLIMB_SPEED    =  7.0;
    const LADDER_SNAP    =  22.0;
    const LADDER_TOP_PAD =  0.10;
    const LADDER_LOCK_T  =  0.18;

    const MAX_FALL_SPEED = -28.5;

    const SLIDE_SPEED    =  12.6;
    const SLIDE_TIME     =  0.22;
    const SLIDE_CD       =  0.42;

    const WALL_SLIDE_MAXFALL = -6.0;
    const WALL_JUMP_V        =  14.2;
    const WALL_JUMP_H        =  10.5;
    const WALL_GRACE         =  0.12;

    const playerMat = new THREE.SpriteMaterial({ map: TEX.idle, transparent:true });
    const playerSprite = new THREE.Sprite(playerMat);
    scene.add(playerSprite);

    // ÏÇ¨Îßù/Ï∂îÎùΩ Ïä§ÌîÑÎùºÏù¥Ìä∏(PLAYER_DOWN: 3ÌîÑÎ†àÏûÑ)
    const deathMat = new THREE.SpriteMaterial({
      map: (PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]) ? PLAYER_DOWN.frames[0] : TEX.hit,
      transparent:true,
      opacity: 1.0
    });
    const deathSprite = new THREE.Sprite(deathMat);
    deathSprite.visible = false;
    deathSprite.frustumCulled = false;
    scene.add(deathSprite);

    const deathAnim = {
      active: false,
      t: 0,
      x: 0,
      y: 0,
      facing: 1,
      dur: RESPAWN_DELAY,
    };
	
	
	
	

    function beginDeathAnim(x, y, facing){
      deathAnim.active = true;
      deathAnim.t = 0;
      deathAnim.x = x;
      deathAnim.y = y;
      deathAnim.facing = (facing||1);
      deathAnim.dur = RESPAWN_DELAY;

      // Ï≤´ ÌîÑÎ†àÏûÑÏóêÏÑú ÏãúÏûë
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[0]){
        deathSprite.material.map = PLAYER_DOWN.frames[0];
      }
      deathSprite.material.opacity = 1.0;
      deathSprite.visible = true;
      deathSprite.position.set(x, y, 3.25);
      // ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÏºÄÏùºÍ≥º Ïú†ÏÇ¨ÌïòÍ≤å(Í∞ÄÎ°ú/ÏÑ∏Î°ú ÎπÑÏú® Î≥¥Ï†ï)
      const asp = (PLAYER_DOWN.fw && PLAYER_DOWN.fh) ? (PLAYER_DOWN.fw / PLAYER_DOWN.fh) : 1;
      const baseY = 1.75;
      deathSprite.scale.set(baseY*asp * (deathAnim.facing>=0 ? 1 : -1), baseY, 1);
      deathSprite.rotation.z = 0;
    }

    function endDeathAnim(){
      deathAnim.active = false;
      deathSprite.visible = false;
    }

    function updateDeathAnim(dt){
      if(!deathAnim.active) return;
      deathAnim.t += dt;

      const t = deathAnim.t;
      // ÌîÑÎ†àÏûÑ: 0 -> 1 -> 2 ÌõÑ Ïú†ÏßÄ
      let fi = 0;
      if(t >= 0.12) fi = 1;
      if(t >= 0.24) fi = 2;
      if(PLAYER_DOWN.frames && PLAYER_DOWN.frames[fi]){
        deathSprite.material.map = PLAYER_DOWN.frames[fi];
      }

      // ÏÇ¥Ïßù ÏúÑÎ°ú "Ìà≠" + ÏïÑÎûòÎ°ú Í∞ÄÎùºÏïâÍ∏∞
      const hop = Math.exp(-t*10) * 0.55;
      const fall = t * 0.95;
      const yy = deathAnim.y + hop - fall;
      deathSprite.position.set(deathAnim.x, yy, 3.25);

      // ÏÇ¥Ïßù Í∏∞Ïö∏Í∏∞
      deathSprite.rotation.z = Math.sin(t*7.0) * 0.06;

      // ÌéòÏù¥Îìú ÏïÑÏõÉ
      const fadeStart = Math.min(0.55, RESPAWN_DELAY*0.55);
      if(t > fadeStart){
        const k = clamp((t - fadeStart) / Math.max(0.0001, (RESPAWN_DELAY - fadeStart)), 0, 1);
        deathSprite.material.opacity = 1 - easeOutCubic(k);
      }

      if(t >= RESPAWN_DELAY){
        endDeathAnim();
      }
    }

    const player = {
      x: 0, y: 2.5,
      vx: 0, vy: 0,
      w: 1.05, h: STAND_H,
      facing: 1,
      onGround: false,

      coyote: 0,
      jumpBuf: 0,
      jumpHold: 0,

      dashT: 0,
      dashCd: 0,
      dashTrailT: 0,
      dashCharges: DASH_CHARGES_MAX,
      runHold: 0,
      runBoost: false,
      runTrailT: 0,
      runSfxT: 0,

      invuln: 0,
      hurtT: 0,
      hp: 3,

      // ÏãúÏûë/Î¶¨Ïä§Ìè∞ "ÎøÖ" Î™®ÏÖò ÌÉÄÏù¥Î®∏(ÏãúÍ∞Å Ìö®Í≥º)
      spawnT: 0,

      isDucking: false,
      onLadder: false,
      isClimbing: false,
      ladderLock: 0,

      slideT: 0,
      slideCd: 0,

      wallDir: 0,
      wallGrace: 0,

      landSquashT: 0,

      idleStill: 0,
      state: "idle",
      animT: 0,
      duckStepT: 0,
    };

    function setPlayerTex(tex){
      if(playerSprite.material.map === tex) return;
      playerSprite.material.map = tex;
      playerSprite.material.needsUpdate = true;
    }

    function canStandHere(){
      const bottom = player.y - player.h*0.5;
      const ax = player.x - player.w*0.5;
      const ay = bottom;
      const aw = player.w;
      const ah = STAND_H;
      for(const p of world.platforms){
        if(aabbIntersect(ax, ay, aw, ah, p.x, p.y, p.w, p.h)) return false;
      }
      return true;
    }

const SKIN = 0.001;
const GROUND_PROBE = 0.06; // ‚úÖ Î∞îÎã• ÎØ∏ÏÑ∏ Í≤πÏπ®(ÎçúÎçú Îñ®Î¶º/ÏôºÏ™Ω ÎÅù ÏõåÌîÑ) Î∞©ÏßÄÏö©

function resolveCollisions(nextX, nextY){
  let x = nextX, y = nextY;
  let onGround = false;
  let wallDir = 0;

  const hw = player.w * 0.5;
  const hh = player.h * 0.5;

  // ---------------------------------
  // 1) Y(ÏÉÅÌïò) Ìï¥Í≤∞
  //   - vy<0(ÎÇôÌïò): ÏùºÎ∞ò Î∞îÎã• Ï∂©Îèå
  //   - vy>0(ÏÉÅÏäπ): Ï≤úÏû• Ï∂©Îèå
  //   - vy==0 Ïù¥Î©¥ÏÑú onGroundÏòÄÎçò Í≤ΩÏö∞: Î∞îÎã• Ïä§ÎÉÖÏúºÎ°ú ÎØ∏ÏÑ∏ Í≤πÏπ® Ï†úÍ±∞
  // ---------------------------------
  {
    const ax = x - hw;
    const aw = player.w;
    /*
    if(player.vy < 0){
      let best = -Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y + p.h + hh + SKIN; // Î∞îÎã• ÏúÑÎ°ú Ïä§ÎÉÖ
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        y = best;
        player.vy = 0;
        onGround = true;
      }*/
	   if(player.vy < 0){
      // ‚úÖ ÏÇ¨Îã§Î¶¨ ÌÅ¥ÎùºÏûÑ Ï§ë(ÌäπÌûà ÎÇ¥Î†§Í∞à Îïå)ÏùÄ ÌîåÎû´Ìèº Î∞îÎã• Ïä§ÎÉÖÏù¥ Í±∏Î¶¨Î©¥ Î™ª ÎÇ¥Î†§Í∞ê
      if(!(player.isClimbing && player.onLadder)){
        let best = -Infinity;
        for(const p of world.platforms){
          const ay = y - hh;
          if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
            const candidate = p.y + p.h + hh + SKIN; // Î∞îÎã• ÏúÑÎ°ú Ïä§ÎÉÖ
            if(candidate > best) best = candidate;
          }
        }
        if(best > -Infinity){
          y = best;
          player.vy = 0;
          onGround = true;
        }
      }
    
   /* }else if(player.vy > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ay = y - hh;
        if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
          const candidate = p.y - hh - SKIN; // Ï≤úÏû• ÏïÑÎûòÎ°ú Ïä§ÎÉÖ
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        y = best;
        player.vy = 0;
      }*/
	 }else if(player.vy > 0){
  // ‚úÖ ÏÇ¨Îã§Î¶¨(CLIMB)Î°ú ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî Ï§ëÏóêÎäî ÌîåÎû´Ìèº Ï≤úÏû• Ï∂©ÎèåÏùÑ Î¨¥ÏãúÌï¥Ïïº
  //    "ÏÇ¨Îã§Î¶¨ + ÌîåÎû´Ìèº ÏÉÅÎã®Ïù¥ ÎßûÎãøÎäî" Íµ¨Ï°∞ÏóêÏÑúÎèÑ ÏúÑÎ°ú Îπ†Ï†∏ÎÇòÏò¨ Ïàò ÏûàÏùå
		  if(!(player.isClimbing && player.onLadder)){
			let best = Infinity;
			for(const p of world.platforms){
			  const ay = y - hh;
			  if(aabbIntersect(ax, ay, aw, player.h, p.x, p.y, p.w, p.h)){
				const candidate = p.y - hh - SKIN; // Ï≤úÏû• ÏïÑÎûòÎ°ú Ïä§ÎÉÖ
				if(candidate < best) best = candidate;
			  }
			}
			if(best < Infinity){
			  y = best;
			  player.vy = 0;
			}
		  }
		
		 
	  
    }else if((player.onGround || player.coyote > 0) && !player.isClimbing){
      // ‚úÖ "Í∞ÄÎßåÌûà ÏûàÏùÑ Îïå Îñ®Î¶º" + "Î≤Ω/Ï†êÌîÑÎ≤Ω ÎãøÏùÑ Îïå Ï¢åÏ∏° ÎÅùÏúºÎ°ú ÏõåÌîÑ"Ïùò ÏõêÏù∏Ïù∏
      //    Î∞îÎã•Ïùò 'ÏïÑÏ£º ÎØ∏ÏÑ∏Ìïú Í≤πÏπ®'ÏùÑ Îß§ ÌîÑÎ†àÏûÑ Ï†úÍ±∞
      const bottom = y - hh;
      let bestTop = -Infinity;

      // Î∞úÎÅù ÏïÑÎûòÏ™ΩÏúºÎ°ú ÏïÑÏ£º ÏñïÍ≤å ÌîÑÎ°úÎ∏å
      const probeAy = bottom - GROUND_PROBE;
      const probeAh = player.h + GROUND_PROBE;

      for(const p of world.platforms){
        if(!aabbIntersect(ax, probeAy, aw, probeAh, p.x, p.y, p.w, p.h, 0)) continue;
        const top = p.y + p.h;

        // Î∞îÎã•(ÌîåÎû´Ìèº top)Ïù¥ Î∞úÎÅù Í∑ºÏ≤òÏóê ÏûàÏùÑ ÎïåÎßå ÌõÑÎ≥¥Î°ú Ïù∏Ï†ï
        if(top <= bottom + GROUND_PROBE + 1e-4){
          if(top > bestTop) bestTop = top;
        }
      }

      if(bestTop > -Infinity){
        y = bestTop + hh + SKIN;
        onGround = true;
      }
    }
  }

  // ---------------------------------
  // 2) X(Ï¢åÏö∞) Ìï¥Í≤∞
  //   - Î∞îÎã•Ïù¥ 'Î≤Ω'ÏúºÎ°ú Ïò§Ïù∏ÎêòÎäî Í≤ÉÏùÑ ÎßâÍ∏∞ ÏúÑÌï¥
  //     XÏ∂©Îèå ÌåêÏ†ïÏö© AABBÎäî ÏÑ∏Î°úÎ°ú ÏïÑÏ£º ÏÇ¥Ïßù Ï§ÑÏó¨ÏÑú ÏÇ¨Ïö©
  // ---------------------------------
  if(player.vx !== 0){
    const shrink = Math.min(0.03, player.h * 0.08);
    const ay = (y - hh) + shrink;
    const ah = player.h - shrink * 2;

    if(player.vx > 0){
      let best = Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x - hw - SKIN;
          if(candidate < best) best = candidate;
        }
      }
      if(best < Infinity){
        x = best;
        player.vx = 0;
        wallDir = +1;
      }
    }else{
      let best = -Infinity;
      for(const p of world.platforms){
        const ax = x - hw;
        if(aabbIntersect(ax, ay, player.w, ah, p.x, p.y, p.w, p.h)){
          const candidate = p.x + p.w + hw + SKIN;
          if(candidate > best) best = candidate;
        }
      }
      if(best > -Infinity){
        x = best;
        player.vx = 0;
        wallDir = -1;
      }
    }
  }

  return { x, y, onGround, wallDir };
}


    

    // ----------------------------
    // ÏõîÎìú Ï†ïÎ¶¨
    // ----------------------------
    function clearWorld(){
      for(const key of ["platforms","coins","enemies","springs","ladders","particles","afterimages","bossAfterimages","bossBullets"]){
        for(const o of world[key]){
          if(o.mesh) scene.remove(o.mesh);
          if(o.sp) scene.remove(o.sp);
        }
        world[key] = [];
      }
      if(world.goal?.mesh) scene.remove(world.goal.mesh);
      world.goal = null;
      if(world.boss?.mesh) scene.remove(world.boss.mesh);
      world.boss = null;

      world.totalCoinsLevel = 0;
      world.collectedCoinsLevel = 0;
      // totalCoinsRunÏùÄ Ï†ïÏ±ÖÏóê Îî∞Îùº Ïú†ÏßÄ/Î¶¨ÏÖãÏóêÏÑú Ï≤òÎ¶¨
    }

    // ----------------------------
    // ÌçºÏ¶ê Î™®Îìà: ÏÇ¨Îã§Î¶¨ ÌïÑÏàò
    // - Ï†êÌîÑÎ°úÎäî Î™ª Ïò¨ÎùºÍ∞ÄÍ≤å ÎÜíÏù¥ Ï∞®Ïù¥Î•º ÌÅ¨Í≤å
    // - Î≤ΩÏ†êÌîÑÎ°úÎèÑ Î™ª Ïö∞ÌöåÌïòÍ≤å Ï¢åÏö∞ Ï∞®Îã®Î≤Ω/Ï≤úÏû• Ï∂îÍ∞Ä
    // ----------------------------
    function buildLadderPuzzle(xStart, groundTop, diff){
      const low = addPlatform(xStart, groundTop-1.0, 6.0, 1.0);
      const lowTop = low.y + low.h;

      // Ï†êÌîÑÎ°ú Î™ª ÎãøÎèÑÎ°ù top Ï∞®Ïù¥Î•º ÌÅ¨Í≤å(> ÏïΩ 3.8)
      const highTop = lowTop + rand(4.4, 5.2) + (diff-1)*0.3;
      const high = addPlatform(xStart + rand(2.0, 2.8), highTop-1.0, 6.0, 1.0);

      // ÏÇ¨Îã§Î¶¨ Ï§ëÏïô
      const ladderX = (Math.max(low.x+1.2, high.x+1.2) + Math.min(low.x+low.w-1.2, high.x+high.w-1.2)) / 2;
      //addLadderBetween(low, high, ladderX);

      // Ï†êÌîÑ/Î≤ΩÏ†êÌîÑ Ïö∞Ìöå Ï∞®Îã®: ÏñëÏ™Ω Î≤Ω + ÎÇÆÏùÄ Ï≤úÏû•
      addBlockWall(low.x - 0.6, lowTop, 0.6, (highTop - lowTop) + 3.0);
      addBlockWall(low.x + low.w, lowTop, 0.6, (highTop - lowTop) + 3.0);

      // Ï≤úÏû•: low ÏúÑÏóê ÏñïÍ≤å ÎßåÎì§Ïñ¥ Ï†êÌîÑÍ≥µÍ∞Ñ Ï†úÌïú(ÏÇ¨Îã§Î¶¨Î°úÎßå ‚ÄúÏúÑÏ™Ω ÌÜµÎ°ú‚Äù)
      //addPlatform(low.x, lowTop + 1.35, low.w, 0.55);
	  // ‚úÖ ÏÇ¨Îã§Î¶¨ Íµ¨Î©ç ÎÇ®Í∏∞Îäî Ï≤úÏû•(ÏΩîÏù∏/Îì±Î∞ò ÌÜµÎ°ú ÌôïÎ≥¥)
	/*	{
		  const gapW = 1.8;            // ÏÇ¨Îã§Î¶¨/ÏΩîÏù∏ ÌÜµÎ°ú Ìè≠
		  const ceilY = lowTop + 2.0;  // ÏΩîÏù∏ ÎùºÏù∏Î≥¥Îã§ ÏúÑÎ°ú Ïò¨Î†§ÏÑú Ï†àÎåÄ ÎßâÏßÄ ÏïäÍ≤å
		  const ceilH = 0.55;

		  const leftEnd = (ladderX - gapW/2);
		  const rightStart = (ladderX + gapW/2);

		  const leftW = leftEnd - low.x;
		  if(leftW > 0.6) addPlatform(low.x, ceilY, leftW, ceilH);

		  const rightW = (low.x + low.w) - rightStart;
		  if(rightW > 0.6) addPlatform(rightStart, ceilY, rightW, ceilH);
		}
		{
		  const span = (highTop - lowTop);
		  const n = clamp(Math.floor(span / 0.85), 5, 10);
		  for(let i=0;i<n;i++){
			const t = (i+1) / (n+1);
			const yy = lerp(lowTop + 0.75, highTop - 0.75, t);
			safeAddCoin(ladderX, yy);
		  }
		}
*/
      // ÏΩîÏù∏ ÌûåÌä∏(ÏÇ¨Îã§Î¶¨Î°ú Ïú†ÎèÑ)
      for(let i=0;i<5;i++){
        //addCoin(ladderX, lowTop + 0.8 + i*0.75);
		safeAddCoin(ladderX, lowTop + 0.8 + i*0.75);
      }
      addCoin(high.x + high.w*0.5, highTop + 0.8);

      // Îã§ÏùåÏúºÎ°ú Ïù¥Ïñ¥ÏßÄÎäî Ï∂úÍµ¨ ÌîåÎû´Ìèº
      const out = addPlatform(high.x + high.w + rand(2.2, 3.0), highTop-1.0, rand(4.2, 5.6), 1.0);
      if(rng() < clamp(0.18 + (diff-1)*0.08, 0.18, 0.45)){
        addEnemyOnPlatform(out, out.x + out.w*0.5);
      }
      return { endX: out.x + out.w, endTop: out.y + out.h, entry: low, exit: out };
    }

    // ----------------------------
    // ÌçºÏ¶ê Î™®Îìà: ÏàôÏù¥Í∏∞ ÌïÑÏàò ÌÑ∞ÎÑê
    // - ÏÑúÏûàÎäî Ï∂©Îèå ÎÜíÏù¥(STAND_H)Í∞Ä Î™ª Îì§Ïñ¥Í∞ÄÍ≤å
    // - ÏàôÏù¥Í∏∞(DUCK_H)Îßå ÌÜµÍ≥º Í∞ÄÎä•
    // - Ïö∞Ìöå ÌÜµÎ°úÍ∞Ä ÏóÜÎèÑÎ°ù Î≤Ω/ÏßÄÌòïÏúºÎ°ú Í∞ïÏ†ú
    // ----------------------------
    function buildDuckTunnelPuzzle(xStart, baseTop, diff){
      // ÏûÖÍµ¨ ÌîåÎû´Ìèº
      const entry = addPlatform(xStart, baseTop-1.0, 6.0, 1.0);
      const entryTop = entry.y + entry.h;

      // ÌÑ∞ÎÑê Î∞îÎã•
      const floor = addPlatform(entry.x + entry.w + 1.4, baseTop-1.0, 9.0, 1.0);
      const floorTop = floor.y + floor.h;

      // clearance: STAND(1.55) Î™ª Îì§Ïñ¥Í∞ÄÍ≥† DUCK(1.00)Îßå Îì§Ïñ¥Í∞ÄÍ≤å
      // ÌîåÎ†àÏù¥Ïñ¥Îäî Î∞îÎã• Í∏∞Ï§ÄÏúºÎ°ú hÍ∞Ä Ï†ÅÏö©ÎêòÎØÄÎ°ú, Ïã§Ïßà ÌÜµÍ≥º ÎÜíÏù¥Î•º 1.10~1.18Î°ú
      const clearance = 1.14;
      const ceilingY = floorTop + clearance;
      const ceiling = addPlatform(floor.x, ceilingY, floor.w, 0.6);

      // ÏûÖÍµ¨/Ï∂úÍµ¨Î•º Í∞ïÏ†úÌïòÎäî Î≤Ω(Ïö∞Ìöå Î∞©ÏßÄ)
      // ÏûÖÍµ¨ Î≤Ω: Ï≤úÏû• ÎÜíÏù¥ÍπåÏßÄ ÎßâÍ≥†, ÏïÑÎûòÎßå ÌÜµÍ≥º Í∞ÄÎä•ÌïòÍ≤å ÎßåÎì§Í∏∞
      ////addBlockWall(floor.x - 0.55, floorTop, 0.55, clearance + 0.6);
      ////addBlockWall(floor.x + floor.w, floorTop, 0.55, clearance + 0.6);

      // Ï∂úÍµ¨ ÌîåÎû´Ìèº(ÌÑ∞ÎÑê ÎÅù)
      const exit = addPlatform(floor.x + floor.w + 1.6, baseTop-1.0, 6.0, 1.0);

      // Ïö∞Ìöå Ï†êÌîÑ Ï∞®Îã®(ÏúÑÏ™Ω ÌÅ∞ Ï≤úÏû•)
      //addPlatform(floor.x - 0.6, ceilingY + 1.0, floor.w + 1.2, 0.8);

      // ÏΩîÏù∏ ÎùºÏù∏(ÌÑ∞ÎÑê ÎÇ¥Î∂Ä)
      for(let i=0;i<8;i++){
        addCoin(floor.x + 1.0 + i*1.0, floorTop + 0.65);
      }

      // ÎÇúÏù¥ÎèÑÏóê Îî∞Îùº Ï†Å/Ïä§ÌîÑÎßÅ Î∞∞Ïπò
      if(rng() < clamp(0.10 + (diff-1)*0.05, 0.10, 0.25)){
        addSpringOnPlatform(exit, exit.x + exit.w*0.5);
      }else if(rng() < clamp(0.12 + (diff-1)*0.06, 0.12, 0.32)){
        addEnemyOnPlatform(exit, exit.x + exit.w*0.5);
      }

      return { endX: exit.x + exit.w, endTop: exit.y + exit.h, entry, exit };
    }


    // ----------------------------
    // ÎßµÌå©(Map Pack) Í∏∞Î∞ò Î†àÎ≤® Íµ¨ÏÑ±
    // - LocalStorage(pm_map_pack_v1) Ïö∞ÏÑ†
    // - ÏóÜÏúºÎ©¥ EMBEDDED_MAP_PACK.maps ÏÇ¨Ïö©
    // ----------------------------
    const MAP_PACK_LS_KEY = "pm_map_pack_v1";

    function deepClone(v){
      try{ return JSON.parse(JSON.stringify(v)); }catch(_e){ return v; }
    }
    function _num(v, d){ v = Number(v); return Number.isFinite(v) ? v : d; }
    function _str(v, d){ return (typeof v === "string" && v.trim()) ? v : d; }
    function _arr(v){ return Array.isArray(v) ? v : []; }

    function normalizeMap(m){
      const nowId = () => `map-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
      m = (m && typeof m === "object") ? m : {};
      const ground = m.ground || {};
      const out = {
        schema: 1,
        id: _str(m.id, nowId()),
        name: _str(m.name, "ÏÉà Îßµ"),
        ground: {
          x: _num(ground.x, -80),
          y: _num(ground.y, -2.8),
          w: _num(ground.w, 160),
          h: _num(ground.h, 2.2),
        },
        spawn: {
          x: _num(m.spawn?.x, -15.5),
          y: _num(m.spawn?.y,  2.6),
        },
        platforms: _arr(m.platforms).map(p => ({
          x:_num(p.x, 0), y:_num(p.y, 0), w:Math.max(0.2,_num(p.w, 4)), h:Math.max(0.2,_num(p.h, 1))
        })),
        coins: _arr(m.coins).map(c => ({ x:_num(c.x, 0), y:_num(c.y, 1) })),
        enemies: _arr(m.enemies).map(e => ({ x:_num(e.x, 0), y:_num(e.y, 1) })),
        springs: _arr(m.springs).map(s => ({ x:_num(s.x, 0), y:_num(s.y, 1) })),
        ladders: _arr(m.ladders).map(l => ({
          x:_num(l.x, 0), y:_num(l.y, 0),
          w:Math.max(0.2,_num(l.w, 1.2)), h:Math.max(0.2,_num(l.h, 4.0)),
          topLow: _num(l.topLow, _num(l.y,0)),
          topHigh: _num(l.topHigh, _num(l.y,0) + Math.max(0.2,_num(l.h,4.0))),
        })),
        goal: {
          x: _num(m.goal?.x, 50),
          y: _num(m.goal?.y,  1.0),
        }
      };
      // ÏµúÏÜå 1Í∞ú Î∞úÌåê(Ï§ëÏïô) Î≥¥Ïû•(ÏóêÎîîÌÑ∞ UX)
      if(out.platforms.length === 0){
        out.platforms.push({ x:-18, y:(out.ground.y+out.ground.h) - 1.0 + 0.6, w:6.0, h:1.0 });
      }
      return out;
    }

    function normalizePack(p){
      p = (p && typeof p === "object") ? p : {};
      const maps = _arr(p.maps).map(normalizeMap);
      return { version: 1, maps };
    }

    function loadPackFromLocalStorage(){
      try{
        const s = localStorage.getItem(MAP_PACK_LS_KEY);
        if(!s) return null;
        const obj = JSON.parse(s);
        const pack = normalizePack(obj);
        if(!pack.maps.length) return null;
        return pack;
      }catch(_e){
        return null;
      }
    }

    function savePackToLocalStorage(pack){
      try{
        const norm = normalizePack(pack);
        localStorage.setItem(MAP_PACK_LS_KEY, JSON.stringify(norm));
        return true;
      }catch(_e){
        return false;
      }
    }

    // üëá Ïó¨Í∏∞ EMBEDDED_MAP_PACK.maps Î∞∞Ïó¥Ïóê Îßµ JSONÏùÑ Ï∂îÍ∞ÄÌïòÎ©¥, Í≤åÏûÑÏóê "ÎÇ¥Ïû• Îßµ"ÏúºÎ°ú Ìè¨Ìï®Îê©ÎãàÎã§.
    const EMBEDDED_MAP_PACK = normalizePack({
      version: 1,
      maps: [
        {
          id: "demo-001",
          name: "Glassland Start",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-15.5, y: 2.6 },
          platforms: [
            { x:-18, y:-1.0, w:6.0, h:1.0 },
            { x:-8,  y: 0.2, w:5.0, h:1.0 },
            { x: 2,  y: 1.3, w:5.6, h:1.0 },
            { x: 12, y: 2.4, w:6.0, h:1.0 },
            { x: 28, y: 1.2, w:6.5, h:1.0 },
            { x: 40, y:-1.0, w:7.0, h:1.0 }
          ],
          coins: [
            { x:-15.5, y: 0.9 },
            { x:-5.5,  y: 2.0 },
            { x: 4.6,  y: 3.1 },
            { x: 14.8, y: 4.1 },
            { x: 31.0, y: 3.0 },
            { x: 43.0, y: 1.0 }
          ],
          enemies: [{ x: 14.5, y: 3.0 }],
          springs: [{ x: -5.5, y: 1.1 }],
          ladders: [],
          goal: { x: 45.6, y: 0.8 }
        },
        {
          id: "demo-002",
          name: "Ladder Jump",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-10.0, y: 2.4 },
          platforms: [
            { x:-12, y:-1.0, w:7.0, h:1.0 },
            { x:  2, y: 4.0,  w:7.0, h:1.0 },
            { x: 16, y: 2.2,  w:6.0, h:1.0 },
            { x: 30, y:-1.0,  w:8.0, h:1.0 }
          ],
          ladders: [
            { x: -8.1, y: 0.0, w: 1.2, h: 5.0, topLow: 0.0, topHigh: 5.0 }
          ],
          coins: [
            { x:-8.1, y: 2.2 },
            { x: 5.6, y: 6.2 },
            { x:18.8, y: 4.2 },
            { x:33.0, y: 1.0 }
          ],
          enemies: [{ x: 18.6, y: 3.0 }],
          springs: [{ x: 33.5, y: 0.2 }],
          goal: { x: 36.5, y: 0.8 }
        },
        {
          id: "demo-003",
          name: "Rush Run",
          ground: { x:-80, y:-2.8, w:160, h:2.2 },
          spawn: { x:-20.0, y: 2.6 },
          platforms: [
            { x:-22, y:-1.0, w:7.0, h:1.0 },
            { x:-10, y: 0.6, w:5.0, h:1.0 },
            { x:  0, y: 2.2, w:5.0, h:1.0 },
            { x: 10, y: 3.2, w:5.0, h:1.0 },
            { x: 20, y: 2.0, w:5.0, h:1.0 },
            { x: 32, y: 0.6, w:8.0, h:1.0 },
            { x: 48, y:-1.0, w:8.0, h:1.0 }
          ],
          coins: [
            { x:-18.3, y: 1.0 }, { x:-7.2, y: 2.4 },
            { x:  2.3, y: 3.9 }, { x: 12.4, y: 4.9 },
            { x: 22.3, y: 3.8 }, { x: 35.0, y: 2.0 },
            { x: 52.0, y: 1.0 }
          ],
          enemies: [{ x: 12.3, y: 4.0 }, { x: 22.3, y: 3.0 }],
          springs: [],
          ladders: [],
          goal: { x: 55.0, y: 0.8 }
        }
      ]
    });

    let activePack = loadPackFromLocalStorage() || EMBEDDED_MAP_PACK;

    function getMapForLevel(level){
      if(!activePack || !Array.isArray(activePack.maps) || activePack.maps.length === 0) return null;
      const idx = ((level|0) - 1) % activePack.maps.length;
      const map = activePack.maps[idx];
      if(!map) return null;
      return { map, index: idx, total: activePack.maps.length };
    }

    function addGoalAt(x, y){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 1.6),
        new THREE.MeshBasicMaterial({ map: texFlagOff, transparent:true })
      );
      mesh.position.set(x, y, 2.0);
      scene.add(mesh);
      world.goal = { x, y, w:0.8, h:1.2, mesh, active:false, base:null };
      return world.goal;
    }

    function findSupportPlatformAt(x, yHint){
      let best = null;
      let bestTop = -Infinity;
      const yMax = (Number.isFinite(yHint) ? yHint : (world.groundTop + 4));
      for(const p of world.platforms){
        const top = p.y + p.h;
        const inside = (x >= p.x + 0.35) && (x <= p.x + p.w - 0.35);
        if(!inside) continue;
        // yHint Í∑ºÏ≤ò ÏïÑÎûòÏ™ΩÏóêÏÑú Í∞ÄÏû• ÎÜíÏùÄ top ÏÑ†ÌÉù
        if(top <= yMax + 0.8 && top > bestTop){
          bestTop = top;
          best = p;
        }
      }
      // Í∑∏ÎûòÎèÑ ÏóÜÏúºÎ©¥ (ÏßÄÎ©¥ Ìè¨Ìï®) Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÌîåÎû´Ìèº
      if(!best && world.platforms.length){
        for(const p of world.platforms){
          const top = p.y + p.h;
          const inside = (x >= p.x) && (x <= p.x + p.w);
          if(!inside) continue;
          if(top > bestTop){
            bestTop = top;
            best = p;
          }
        }
      }
      return best;
    }

    function buildLevelFromJson(map, level=1, mapIndex=0, mapTotal=1){
      const m = normalizeMap(map);
      clearWorld();

      world.currentMap = m;

      // ground
      const g = m.ground;
      const groundTop = g.y + g.h;
      addPlatform(g.x, g.y, g.w, g.h);
      world.groundTop = groundTop;
      world.killY = g.y - 10.5;
      alignWaterToGround(g.y);

      // platforms
      for(const p of m.platforms){
        // groundÏôÄ ÏôÑÏ†ÑÌûà Í≤πÏπòÎäî Í≤ΩÏö∞Îäî Ï§ëÎ≥µ Î∞©ÏßÄ(Í∞ÑÎã®)
        if(Math.abs(p.x-g.x)<1e-6 && Math.abs(p.y-g.y)<1e-6 && Math.abs(p.w-g.w)<1e-6 && Math.abs(p.h-g.h)<1e-6) continue;
        addPlatform(p.x, p.y, p.w, p.h);
      }

      // ladders
      for(const l of m.ladders){
        addLadder(l.x, l.y, l.w, l.h, l.topLow, l.topHigh);
      }

      // coins
      for(const c of m.coins){
        addCoin(c.x, c.y);
      }

      // enemies / springs: support platform Ï∞æÏïÑÏÑú Ïò¨Î†§ÎÜìÍ∏∞
      for(const e of m.enemies){
        const p = findSupportPlatformAt(e.x, e.y);
        if(p) addEnemyOnPlatform(p, e.x);
      }
      for(const s of m.springs){
        const p = findSupportPlatformAt(s.x, s.y);
        if(p) addSpringOnPlatform(p, s.x);
      }

      // goal
      if(m.goal) addGoalAt(m.goal.x, m.goal.y);

      // UI Ï¥àÍ∏∞Ìôî
      world.collectedCoinsLevel = 0;
      const title = m.name ? ` ¬∑ ${m.name}` : "";
      $stageText.textContent = `Level ${level} ¬∑ Map ${mapIndex+1}/${mapTotal}${title}`;
      updateCoinHUD();
    }


    // ----------------------------
    // ÎûúÎç§ Î†àÎ≤® ÏÉùÏÑ±(ÌçºÏ¶ê Î™®Îìà Ìè¨Ìï®)
    // ----------------------------
    function buildRandomLevel(level){
      // ‚úÖ ÎßµÌå© Ïö∞ÏÑ†: LocalStorage(pm_map_pack_v1) -> EMBEDDED_MAP_PACK
      const info = getMapForLevel(level);
      if(info){
        const diff = 1.0 + (level-1)*0.16;
        game.difficulty = diff;
        buildLevelFromJson(info.map, level, info.index, info.total);
        return;
      }

      clearWorld();
      world.currentMap = null;

      const diff = 1.0 + (level-1)*0.16;
      game.difficulty = diff;

      const groundY = -2.8;
      const groundH = 2.2;
      const groundTop = groundY + groundH;


      world.groundTop = groundTop;
      world.killY = groundY - 10.5;
      alignWaterToGround(groundY);

      // ÏãúÏûë ÏßÄÎ©¥
      addPlatform(-80, groundY, 160, groundH);

      // ÏãúÏûë Î∞úÌåê
      let x = -18;
      let top = groundTop + 0.6;
      let p = addPlatform(x, top-1.0, 6.0, 1.0);

      // ÏùºÎ∞ò Íµ¨Í∞Ñ Î™á Í∞ú
      const normalSteps = 3 + Math.min(2, level|0);
      for(let i=0;i<normalSteps;i++){
        const w = rand(3.6, 5.8);
        const gap = rand(1.4, 2.4) + (diff-1)*0.25;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 0.9) * (1.0 + (diff-1)*0.45);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 4.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.85) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.10 + (diff-1)*0.04, 0.10, 0.22)) addEnemyOnPlatform(p, p.x + p.w*0.5);
      }

      // ‚úÖ ÏÇ¨Îã§Î¶¨ ÌïÑÏàò ÌçºÏ¶ê(Ìï≠ÏÉÅ 1Ìöå)
      const ladderSeg = buildLadderPuzzle(p.x + p.w + rand(2.2, 3.0), groundTop + 0.6, diff);
      x = ladderSeg.endX;
      top = ladderSeg.endTop;
      p = ladderSeg.exit;

      // Ï§ëÍ∞Ñ ÏùºÎ∞ò Íµ¨Í∞Ñ
      const midSteps = 2 + Math.min(2, (level-1)|0);
      for(let i=0;i<midSteps;i++){
        const w = rand(3.2, 5.6);
        const gap = rand(1.5, 2.8) + (diff-1)*0.30;
        x = p.x + p.w + gap;

        const dy = rand(-0.8, 0.9) * (1.0 + (diff-1)*0.55);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.2);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.88) addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
        if(rng() < clamp(0.12 + (diff-1)*0.05, 0.12, 0.28)) addSpringOnPlatform(p, p.x + p.w*0.5);
      }

      // ‚úÖ ÏàôÏù¥Í∏∞ ÌïÑÏàò ÌçºÏ¶ê(Ìï≠ÏÉÅ 1Ìöå)
      const duckSeg = buildDuckTunnelPuzzle(p.x + p.w + rand(2.4, 3.2), groundTop + 0.6, diff);
      x = duckSeg.endX;
      top = duckSeg.endTop;
      p = duckSeg.exit;

      // Í≥® Ïïû ÎßàÏßÄÎßâ Íµ¨Í∞Ñ
      const tailSteps = 2 + Math.min(3, level|0);
      for(let i=0;i<tailSteps;i++){
        const w = rand(3.4, 6.2);
        const gap = rand(1.5, 2.8) + (diff-1)*0.35;
        x = p.x + p.w + gap;

        const dy = rand(-0.6, 1.0) * (1.0 + (diff-1)*0.60);
        top = clamp((p.y+p.h) + dy, groundTop + 0.25, groundTop + 5.8);
        p = addPlatform(x, top-1.0, w, 1.0);

        if(rng() < 0.9){
          addCoin(p.x + rand(0.8, p.w-0.8), top + 0.8);
          if(rng() < 0.25) addCoin(p.x + rand(0.8, p.w-0.8), top + 1.3);
        }
        if(rng() < clamp(0.16 + (diff-1)*0.06, 0.16, 0.40)) addEnemyOnPlatform(p, p.x + p.w*0.55);
      }

      // ‚úÖ Í≥® Î≤†Ïù¥Ïä§ ÌîåÎû´Ìèº + ÍπÉÎ∞ú
      const goalBase = addPlatform(p.x + p.w + 3.0, groundTop-1.0, 7.0, 1.0);
      addGoalWithBase(goalBase);

      // Í≥® Ï£ºÎ≥Ä ÏΩîÏù∏(ÎßàÏßÄÎßâ Ïú†ÎèÑ)
      addCoin(goalBase.x + 2.0, goalBase.y + goalBase.h + 0.9);
      addCoin(goalBase.x + 4.5, goalBase.y + goalBase.h + 1.4);

      // UI Ï¥àÍ∏∞Ìôî
      world.collectedCoinsLevel = 0;
      $stageText.textContent = `Level ${level}`;
      updateCoinHUD();
    }

    // ----------------------------
    // ÏΩîÏù∏ HUD(Î†àÎ≤®/Îü∞)
    // ----------------------------
    function updateCoinHUD(){
      const levelPart = `${world.collectedCoinsLevel} / ${world.totalCoinsLevel}`;
      if(policy.keepCoins){
        $coinText.textContent = `${levelPart} | Total ${world.totalCoinsRun}`;
      }else{
        $coinText.textContent = levelPart;
      }
    }

    // ----------------------------
    // ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    // ----------------------------
    function updatePlayer(dt){
      const canControl = (game.state === "play" || game.state === "boss" || game.state === "bossIntro");

      player.ladderLock = Math.max(0, player.ladderLock - dt);
      player.slideCd = Math.max(0, player.slideCd - dt);
      player.landSquashT = Math.max(0, player.landSquashT - dt);
      player.hurtT = Math.max(0, player.hurtT - dt);
      player.invuln = Math.max(0, player.invuln - dt);
      player.wallGrace = Math.max(0, player.wallGrace - dt);

      player.dashCd = Math.max(0, player.dashCd - dt);
      if(player.dashT > 0) player.dashT = Math.max(0, player.dashT - dt);

      // ÏÇ¨Îã§Î¶¨ Ïò§Î≤ÑÎû©
      /*
	  let ladder = null;
      player.onLadder = false;
      if(player.ladderLock <= 0){
        const margin = 0.18;
        const px = (player.x - player.w*0.5) - margin;
        const py = (player.y - player.h*0.5);
        const pw = player.w + margin*2;
        const ph = player.h;
        for(const l of world.ladders){
          if(aabbIntersect(px, py, pw, ph, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }*/
	  let ladder = null;
      player.onLadder = false;
      if(player.ladderLock <= 0){
        const margin = 0.18;
        const px = (player.x - player.w*0.5) - margin;
        const py = (player.y - player.h*0.5);
        const pw = player.w + margin*2;
        const ph = player.h;
        for(const l of world.ladders){
          if(aabbIntersect(px, py, pw, ph, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }

      // ‚úÖ [Ï∂îÍ∞Ä] ÌîåÎû´Ìèº ÏúÑÏóêÏÑú ‚Üì ÎàÑÎ•¥Î©¥, Î∞úÎ∞ëÏóê ÏûàÎäî ÏÇ¨Îã§Î¶¨Î•º "ÌîÑÎ°úÎ∏å"Î°ú Ïû°Í∏∞
      if(!ladder && player.ladderLock <= 0 && canControl && player.onGround && input.down && player.dashT<=0){
        const GRAB_DEPTH = 0.65;     // Î∞úÎ∞ëÏúºÎ°ú ÏñºÎßàÎÇò ÎÇ¥Î†§Îã§Î≥ºÏßÄ(ÌïÑÏöîÏãú 0.45~0.9 ÌäúÎãù)
        const X_MARGIN   = 0.12;     // Ï¢åÏö∞ ÌåêÏ†ï Ïó¨Ïú†
        const hw = player.w*0.5;
        const hh = player.h*0.5;

        const bottom = player.y - hh;

        // Î∞úÎ∞ë ÏñïÏùÄ ÏßÅÏÇ¨Í∞ÅÌòï ÌîÑÎ°úÎ∏å(Î™∏ÌÜµÏù¥ ÏïÑÎãàÎùº "Î∞ú ÏïÑÎûò"Îßå Í≤ÄÏÇ¨)
        const px2 = (player.x - hw) - X_MARGIN;
        const py2 = bottom - GRAB_DEPTH;
        const pw2 = player.w + X_MARGIN*2;
        const ph2 = GRAB_DEPTH + 0.02;

        for(const l of world.ladders){
          // (ÏÑ†ÌÉù) ÏÇ¨Îã§Î¶¨ ÏµúÏÉÅÎã®Ïù¥ Î∞úÎ∞ë Í∑ºÏ≤òÏùº ÎïåÎßå Ïû°ÌûàÍ≤å ÌïÑÌÑ∞
          const dTop = bottom - l.topHigh;
          if(dTop < -0.10 || dTop > GRAB_DEPTH + 0.10) continue;

          if(aabbIntersect(px2, py2, pw2, ph2, l.x, l.y, l.w, l.h)){
            ladder = l;
            player.onLadder = true;
            break;
          }
        }
      }

      // ÎåÄÏãú Î¶¨ÌïÑ: ÎïÖ/ÏÇ¨Îã§Î¶¨ Ï†ëÏ¥â Ïãú
      if(player.onGround || player.onLadder){
        player.dashCharges = DASH_CHARGES_MAX;
      }
      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;

      // ÌÅ¥ÎùºÏûÑ ÏãúÏûë/Ï¢ÖÎ£å
      if(player.isClimbing){
        if(!player.onLadder || !canControl) player.isClimbing = false;
      }else{
        if(player.onLadder && canControl && (input.up || input.down) && player.dashT<=0){
          player.isClimbing = true;
          player.vx = 0; player.vy = 0;
        }
      }

      // ÏàôÏù¥Í∏∞(Ï∂©Îèå Î∞ïÏä§ Í∞êÏÜå)
      if(canControl && !player.isClimbing && player.onGround && player.dashT<=0){
        if(input.down || player.slideT>0){
          if(!player.isDucking){
            const bottom = player.y - player.h*0.5;
            player.isDucking = true;
            player.h = DUCK_H;
            player.y = bottom + player.h*0.5;
          }
        }else{
          if(player.isDucking && canStandHere()){
            const bottom = player.y - player.h*0.5;
            player.isDucking = false;
            player.h = STAND_H;
            player.y = bottom + player.h*0.5;
          }
        }
      }else{
        if(!player.onGround && player.isDucking && player.slideT<=0){
          const bottom = player.y - player.h*0.5;
          player.isDucking = false;
          player.h = STAND_H;
          player.y = bottom + player.h*0.5;
        }
      }

      // Ï†êÌîÑ Î≤ÑÌçº/ÏΩîÏöîÌÖå
      if(player.onGround && !player.isClimbing) player.coyote = COYOTE;
      else player.coyote = Math.max(0, player.coyote - dt);

      if(canControl && input.jumpPressed) player.jumpBuf = JUMP_BUF;
      else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

      // Ïä¨ÎùºÏù¥Îìú(‚Üì+ÎåÄÏãú ÌÇ§: Í∏∞Î≥∏ X)
      if(canControl && player.onGround && !player.isClimbing && player.dashT<=0){
        if(input.dashPressed && input.down && player.slideCd<=0 && player.slideT<=0){
          player.slideT = SLIDE_TIME;
          player.slideCd = SLIDE_CD;
          player.isDucking = true;
          player.h = DUCK_H;
          player.vx = SLIDE_SPEED * player.facing;
          spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
          screenShake(0.08, 0.10);
          showToast("Ïä¨ÎùºÏù¥Îìú!", 450);
        }
      }
      if(player.slideT > 0){
        player.slideT = Math.max(0, player.slideT - dt);
        player.vx = moveTowards(player.vx, 0, 26 * dt);
        if(player.slideT===0) spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 6);
      }

      // Î∞©Ìñ•/Ïù¥Îèô
      const dir = canControl ? ((input.left ? -1 : 0) + (input.right ? 1 : 0)) : 0;
      if(dir !== 0 && !input.faceLock) player.facing = dir;
      else if(player.facing === 0) player.facing = 1;

      const runEligible = canControl && player.onGround && !player.isClimbing && player.dashT<=0 && player.slideT<=0 && !player.isDucking && dir !== 0;
      if(runEligible){
        player.runHold = Math.min(RUN_HOLD_TIME, player.runHold + dt);
      }else{
        player.runHold = 0;
      }
      player.runBoost = player.runHold >= RUN_HOLD_TIME;

      const speedMul = (player.isDucking ? DUCK_SPEED_MUL : 1.0);
      const maxVx = (player.runBoost ? RUN_SPEED_MAX : MOVE_MAX) * speedMul;
      const targetVx = dir * maxVx;

      if(!player.isClimbing && player.dashT <= 0 && player.slideT<=0){
        const reversing = (dir !== 0) && (player.vx !== 0) && (Math.sign(player.vx) !== Math.sign(targetVx));
        if(player.onGround){
          const baseAccel = (dir!==0 ? GROUND_ACCEL : GROUND_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          const accel = player.runBoost ? baseAccel * RUN_ACCEL_MULT : baseAccel;
          const before = player.vx;
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
          if(reversing && Math.abs(before) > 5.5) spawnDust(player.x - sign(before)*0.15, player.y - player.h/2 + 0.02, 4);
        }else{
          const accel = (dir!==0 ? AIR_ACCEL : AIR_BRAKE) * (reversing ? TURN_BOOST : 1.0);
          player.vx = moveTowards(player.vx, targetVx, accel * dt);
        }
      }

      // ÌÅ¥ÎùºÏûÑ
      if(player.isClimbing && ladder && canControl){
        const lx = ladder.x + ladder.w*0.5;
        player.x = lerp(player.x, lx, 1 - Math.exp(-LADDER_SNAP*dt));

        const v = (input.up?1:0) + (input.down?-1:0);
        player.vy = v * CLIMB_SPEED;

        // ‚úÖ Î∞îÎã• ÌîåÎû´Ìèº ÎÇ¥Î∂ÄÎ°ú Îì§Ïñ¥Í∞ÄÏßÄ ÏïäÍ≤å + Î∞©Ìñ• ÏïàÏ†ïÌôî
		const minY = ladder.topLow  + (player.h*0.5) + 0.02;
		const maxY = ladder.topHigh + (player.h*0.5) + 0.02;
		player.y = clamp(player.y, minY, maxY);

		// ‚úÖ ÏúÑ/ÏïÑÎûò ÏûÖÎ†• ÏóÜÏù¥ Ï¢å/Ïö∞Î°ú ÏõÄÏßÅÏù¥Î©¥ ÏÇ¨Îã§Î¶¨ÏóêÏÑú ‚ÄúÏòÜÏúºÎ°ú Îπ†Ï†∏ÎÇòÏò§Í∏∞‚Äù
		if((input.left || input.right) && !(input.up || input.down)){
		  player.isClimbing = false;
		  player.ladderLock = 0.12;
		}

        const nearTop = (player.y - player.h*0.5) >= (ladder.topHigh - LADDER_TOP_PAD);
        if(nearTop && input.up){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.vy = 0;
          player.y = ladder.topHigh + player.h*0.5 + 0.02;
        }

        if(input.jumpPressed){
          player.isClimbing = false;
          player.ladderLock = LADDER_LOCK_T;
          player.jumpBuf = 0; player.coyote = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          player.vy = JUMP_V;
          player.vx = MOVE_MAX * 0.70 * player.facing;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          screenShake(0.09, 0.10);
        }
      }else{
        // Î≤Ω Ï†êÌîÑ
        if(canControl && input.jumpPressed && player.wallGrace > 0 && !player.onGround && player.dashT<=0){
          const wd = player.wallDir || (dir!==0 ? -dir : -player.facing);
          player.vy = WALL_JUMP_V;
          player.vx = -wd * WALL_JUMP_H;
          player.facing = -wd;
          player.wallGrace = 0;
          player.jumpHold = JUMP_HOLD_TIME * 0.75;
          spawnDust(player.x + wd*0.25, player.y - player.h/2 + 0.12, 10);
          screenShake(0.10, 0.12);
          showToast("Î≤Ω Ï†êÌîÑ!", 520);
        }

        // Ï†êÌîÑ
        if(canControl && player.jumpBuf > 0 && (player.onGround || player.coyote > 0) && player.dashT<=0){
          player.vy = JUMP_V;
          player.onGround = false;
          player.coyote = 0;
          player.jumpBuf = 0;
          player.jumpHold = JUMP_HOLD_TIME;
          spawnParticles(player.x, player.y - player.h/2 + 0.05, 10, 1.0);
          spawnDust(player.x, player.y - player.h/2 + 0.02, 6);
          screenShake(0.09, 0.10);
          SFX.jump();
          showToast("Ï†êÌîÑ!", 450);
        }

        // Ï†êÌîÑ Ïª∑
        if(input.jumpReleased && player.vy > 0){
          player.vy *= JUMP_CUT;
          player.jumpHold = 0;
        }

        // ‚úÖ 8Î∞©Ìñ• ÎåÄÏãú(Í≥µÏ§ë 1Ìöå)
        if(canControl && input.dashPressed && player.dashCd<=0 && player.dashT<=0 && player.dashCharges>0){
          // Î∞©Ìñ• ÏûÖÎ†• (ÏóÜÏúºÎ©¥ facing)
          let dx = (input.left?-1:0) + (input.right?1:0);
          let dy = (input.down?-1:0) + (input.up?1:0);
          if(dx===0 && dy===0) dx = player.facing;

          // Ï†ïÍ∑úÌôî
          const len = Math.hypot(dx,dy) || 1;
          dx /= len; dy /= len;

          player.dashT = DASH_TIME;
          player.dashCd = DASH_COOLDOWN;
          player.dashCharges--;

          player.isDucking = false;
          player.h = STAND_H;

          player.vx = dx * DASH_SPEED;
          player.vy = dy * DASH_SPEED;

          player.dashTrailT = 0.02;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);

          spawnParticles(player.x, player.y, 12, 1.2);
          screenShake(0.10, 0.12);
          SFX.dash();
          showToast("ÎåÄÏãú!", 420);
        }

        // ÎåÄÏãú Ï§ë(ÏßßÍ≤å Ï§ëÎ†• ÏïΩÌôî)
        if(player.dashT > 0){
          player.vx = moveTowards(player.vx, player.vx, 0); // Ïú†ÏßÄ
          player.vy = moveTowards(player.vy, player.vy, 0);
          // ÏÇ¥Ïßù Í∞êÏá†Î°ú ÏÖÄÎ†àÏä§Ìä∏ ÎäêÎÇå
          player.vx *= 0.995;
          player.vy *= 0.995;
        }else{
          // Ï§ëÎ†•
          let g = (player.vy > 0) ? GRAVITY_UP : GRAVITY_DOWN;

          if(!player.onGround && Math.abs(player.vy) <= APEX_VY){
            g *= APEX_GRAV_MULT;
          }

          if(player.vy > 0 && input.jump && player.jumpHold > 0){
            player.jumpHold = Math.max(0, player.jumpHold - dt);
            g *= JUMP_HOLD_GRAV;
          }else{
            player.jumpHold = 0;
          }

          if(!player.onGround && player.vy < 0 && input.down){
            g *= FAST_FALL_MULT;
          }

          player.vy += g * dt;
          player.vy = Math.max(player.vy, MAX_FALL_SPEED);
        }
      }

      // ÎåÄÏãú ÏûîÏÉÅ
      if(player.dashT > 0){
        player.dashTrailT -= dt;
        if(player.dashTrailT <= 0){
          player.dashTrailT = 0.03;
          const sx = 1.65 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.65);
        }
      }

      // Í≥†ÏÜç ÏßàÏ£º ÏûîÏÉÅ + Ìö®Í≥ºÏùå
      if(player.runBoost){
        player.runTrailT -= dt;
        if(player.runTrailT <= 0){
          player.runTrailT = RUN_TRAIL_INTERVAL;
          const sx = 1.55 * (player.facing>=0 ? 1 : -1);
          spawnAfterimage(player.x, player.y+0.08, playerSprite.material.map, sx, 1.55, {
            life: RUN_TRAIL_LIFE,
            opacity: RUN_TRAIL_OPACITY
          });
        }

        player.runSfxT -= dt;
        if(player.runSfxT <= 0){
          player.runSfxT = RUN_SFX_INTERVAL;
          SFX.fastRun();
        }
      }else{
        player.runTrailT = 0;
        player.runSfxT = 0;
      }

      // Ï†ÅÎ∂Ñ + Ï∂©Îèå
      const nextX = player.x + player.vx*dt;
      const nextY = player.y + player.vy*dt;
      const beforeGround = player.onGround;

      const res = resolveCollisions(nextX, nextY);
      player.x = res.x;
      player.y = res.y;

      if(!player.onGround && res.wallDir !== 0){
        player.wallDir = res.wallDir;
        player.wallGrace = WALL_GRACE;
      }else if(player.wallGrace <= 0){
        player.wallDir = 0;
      }

      player.onGround = res.onGround && !player.isClimbing;

      if(!beforeGround && player.onGround){
        player.landSquashT = 0.12;
        spawnParticles(player.x, player.y - player.h/2 + 0.05, 14, 1.0);
        spawnDust(player.x, player.y - player.h/2 + 0.02, 10);
        screenShake(0.09, 0.10);
      }

      // Î≤Ω Ïä¨ÎùºÏù¥Îìú 
      /*const wantsWall = (dir !== 0) ? dir : player.facing;
      if(!player.onGround && player.wallGrace > 0 && player.vy < 0 && !player.isClimbing){
        if(wantsWall === player.wallDir){
          player.vy = Math.max(player.vy, WALL_SLIDE_MAXFALL);
          if(rng() < 0.08) spawnDust(player.x + player.wallDir*0.22, player.y - player.h/2 + 0.35, 2);
        }
      }*/
	  // Î≤Ω Ïä¨ÎùºÏù¥Îìú
		const wantsWall = (dir !== 0) ? dir : player.facing;
		if(!player.onGround && player.wallGrace > 0 && player.vy < 0 && !player.isClimbing){
		  if(wantsWall === player.wallDir){
			const maxFall = -Math.abs(WALL_SLIDE_MAXFALL); // ‚òÖ ÌïµÏã¨
			player.vy = Math.max(player.vy, maxFall);

			if(rng() < 0.08) spawnDust(player.x + player.wallDir*0.22, player.y - player.h/2 + 0.35, 2);
		  }
		}
		
		

      // Ïï†Îãà ÏÉÅÌÉú
      const isMoving = Math.abs(player.vx) > 0.65;
      const groundIdle = player.onGround && !player.isClimbing && !player.isDucking && !isMoving;
      const frontHold = groundIdle && input.up && canControl;

      if(player.isClimbing) player.state = "climb";
      else if(player.slideT>0) player.state = "slide";
      else if(player.isDucking && isMoving && player.onGround) player.state = "duckWalk";
      else if(player.isDucking) player.state = "duck";
      else if(frontHold) player.state = "frontHold";
      else if(!player.onGround) player.state = "jump";
      else if(isMoving) player.state = "walk";
      else player.state = "idle";

      player.idleStill = groundIdle ? (player.idleStill + dt) : 0;
      player.animT += dt;

      const showHit = player.hurtT > 0;

      if(showHit) setPlayerTex(TEX.hit);
      else if(player.state === "frontHold") setPlayerTex(TEX.front);
      else if(player.state === "idle") setPlayerTex(player.idleStill > 0.6 ? TEX.front : TEX.idle);
      else if(player.state === "jump") setPlayerTex(player.facing < 0 ? TEX.jumpBack : TEX.jump);
      else if(player.state === "walk"){
        const phase = Math.floor(player.animT*10) % 2;
        if(player.facing < 0){
          setPlayerTex(phase ? TEX.walkABack : TEX.walkBBack);
        }else{
          setPlayerTex(phase ? TEX.walkA : TEX.walkB);
        }
      }else if(player.state === "duck" || player.state === "duckWalk" || player.state === "slide"){
        setPlayerTex(TEX.duck);
      }else if(player.state === "climb"){
        const moving = Math.abs(player.vy) > 0.2;
        const phase = Math.floor(player.animT*10) % 2;
        setPlayerTex(moving ? (phase ? TEX.climbA : TEX.climbB) : TEX.climbA);
      }

      // ÏãúÍ∞Å Ïä§ÏºÄÏùº
      let baseScaleX = 1.65;
      let baseScaleY = 1.65;
      let yBob = 0;

      if(player.landSquashT > 0){
        const t = 1 - (player.landSquashT / 0.12);
        const squash = Math.sin(t * Math.PI);
        baseScaleY *= (1.0 - 0.10*squash);
        baseScaleX *= (1.0 + 0.06*squash);
      }

      if(player.state === "duckWalk"){
        const t = player.animT * 12.0;
        yBob = Math.sin(t) * 0.035;
        baseScaleY *= 0.90;
        baseScaleX *= 1.02;
        player.duckStepT -= dt;
        if(player.duckStepT <= 0){
          player.duckStepT = 0.09;
          spawnDust(player.x - player.facing*0.15, player.y - player.h/2 + 0.02, 4);
        }
      }else if(player.state === "slide"){
        baseScaleY *= 0.88;
        baseScaleX *= 1.06;
        if(rng() < 0.25) spawnDust(player.x - player.facing*0.25, player.y - player.h/2 + 0.02, 2);
        player.duckStepT = 0;
      }else{
        player.duckStepT = 0;
      }

      // ÏãúÏûë/Î¶¨Ïä§Ìè∞ "ÎøÖ" Î™®ÏÖò(Ïä§ÏºÄÏùº 0‚Üí1 + ÏïΩÍ∞ÑÏùò Ïò§Î≤ÑÏäàÌä∏)
      if(player.spawnT > 0){
        player.spawnT = Math.max(0, player.spawnT - dt);
        const k = 1 - clamp(player.spawnT / SPAWN_DUR, 0, 1);
        const s = clamp(easeOutBack(k), 0, 1.25);
        baseScaleX *= s;
        baseScaleY *= s;
        // ÏïΩÍ∞Ñ ÏúÑÎ°ú Îú®Îäî ÎäêÎÇå
        yBob += (1 - easeOutCubic(clamp(k,0,1))) * 0.18;
      }

      playerSprite.position.set(player.x, player.y + 0.08 + yBob, 3);
      playerSprite.scale.set(baseScaleX, baseScaleY, 1);
      {
        const map = playerSprite.material.map;
        const isBackTex = (map === TEX.jumpBack || map === TEX.walkABack || map === TEX.walkBBack);
        playerSprite.scale.x = Math.abs(playerSprite.scale.x) * (isBackTex ? 1 : (player.facing>=0 ? 1 : -1));
      }

      // Î¨¥Ï†Å ÍπúÎπ°ÏûÑ
      if(player.invuln > 0){
        const blink = (Math.floor(player.animT*16) % 2) ? 0.35 : 1.0;
        playerSprite.material.opacity = blink;
      }else{
        playerSprite.material.opacity = 1.0;
      }
    }

    // ----------------------------
    // ÏΩîÏù∏/Ï†Å/Ïä§ÌîÑÎßÅ/Í≥®
    // ----------------------------
    function updateCoins(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const c of world.coins){
        if(c.dead) continue;
        c.t += dt;
        const bob = Math.sin(c.t*4.2)*0.10;
        c.mesh.position.y = c.y + bob;
        c.mesh.rotation.z = Math.sin(c.t*2.2)*0.08;

        const cx = c.x - c.r;
        const cy = (c.y+bob) - c.r;
        if(aabbIntersect(px,py,player.w,player.h, cx,cy,c.r*2,c.r*2)){
          c.dead = true;
          scene.remove(c.mesh);

          world.collectedCoinsLevel++;
          if(policy.keepCoins) world.totalCoinsRun++;
          updateCoinHUD();

          spawnParticles(c.x, c.y, 12, 1.1);
          screenShake(0.06, 0.08);
          SFX.coin();
        }
      }
    }
    
	function updateDebugOverlay(){
		  if(!debug.enabled) return;

		  resetDebugPool();

		  // ÌòÑÏû¨ Î∑∞ Î≤îÏúÑ(Í∞ÄÍπåÏö¥ Í≤ÉÎßå Í∑∏Î†§ÏÑú Í∞ÄÎ≥çÍ≤å)
		  const viewW = (camera.right - camera.left) / camera.zoom;
		  const viewH = (camera.top - camera.bottom) / camera.zoom;
		  const minX = camX - viewW*0.5 - 2.5;
		  const maxX = camX + viewW*0.5 + 2.5;
		  const minY = camY - viewH*0.5 - 2.5;
		  const maxY = camY + viewH*0.5 + 2.5;

		  // ÌîåÎ†àÏù¥Ïñ¥ AABB
		  {
			const px = player.x - player.w*0.5;
			const py = player.y - player.h*0.5;
			const r = getRect(MAT_PLAYER);
			setRect(r, px, py, player.w, player.h);
		  }

		  // ÏÜçÎèÑ Î≤°ÌÑ∞(ÌòÑÏû¨ ÏÜçÎèÑ Î∞©Ìñ• ÌôïÏù∏Ïö©)
		  {
			const sx = player.x;
			const sy = player.y;
			const scale = 0.12; // ÌôîÎ©¥ÏóêÏÑú Î≥¥Í∏∞ Ï¢ãÏùÄ Ïä§ÏºÄÏùº
			setVelLine(sx, sy, sx + player.vx*scale, sy + player.vy*scale);
		  }

		  // ÌîåÎû´Ìèº(ÏÜîÎ¶¨Îìú)
		  for(const p of world.platforms){
			if(p.x > maxX || p.x+p.w < minX || p.y > maxY || p.y+p.h < minY) continue;
			const r = getRect(MAT_SOLID);
			setRect(r, p.x, p.y, p.w, p.h);
		  }

		  // ÏÇ¨Îã§Î¶¨
		  for(const l of world.ladders){
			if(l.x > maxX || l.x+l.w < minX || l.y > maxY || l.y+l.h < minY) continue;
			const r = getRect(MAT_LADDER);
			setRect(r, l.x, l.y, l.w, l.h);
		  }

		  // ÏΩîÏù∏(ÏõêÌòï ÎåÄÏã† Î∞ïÏä§)
		  for(const c of world.coins){
			if(c.dead) continue;
			const size = c.r*2;
			const x = c.x - c.r;
			const y = c.y - c.r;
			if(x > maxX || x+size < minX || y > maxY || y+size < minY) continue;
			const r = getRect(MAT_COIN);
			setRect(r, x, y, size, size);
		  }

		  // Ï†Å
		  for(const e of world.enemies){
			if(e.dead) continue;
			const x = e.x - e.w/2;
			const y = e.y - e.h/2;
			if(x > maxX || x+e.w < minX || y > maxY || y+e.h < minY) continue;
			const r = getRect(MAT_ENEMY);
			setRect(r, x, y, e.w, e.h);
		  }

		  // Í≥®
		  if(world.goal){
			const g = world.goal;
			const gx = g.x - g.w/2;
			const gy = g.y - g.h/2;
			if(!(gx > maxX || gx+g.w < minX || gy > maxY || gy+g.h < minY)){
			  const r = getRect(MAT_GOAL);
			  setRect(r, gx, gy, g.w, g.h);
			}
		  }
		}
	
    function hurtPlayer(fromX){
      if(player.invuln > 0 || (game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro")) return;
      player.hp = Math.max(0, player.hp - 1);
      $hearts.textContent = "‚ù§".repeat(Math.max(0, player.hp)) + "‚ô°".repeat(Math.max(0, 5-player.hp));

      // HPÍ∞Ä 0Ïù¥ ÎêòÎ©¥ Ï¶âÏãú ÏÇ¨Îßù Ïó∞Ï∂ú(Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏ + ÏÇ¨Ïö¥Îìú) ÌõÑ Î¶¨Ïä§Ìè∞
      if(player.hp <= 0){
        startRespawn("I'm exhausted...");
        return;
      }

      player.invuln = 1.0;
      player.hurtT = 0.22;

      const dir = sign(player.x - fromX) || 1;
      player.vx = dir * 10.5;
      player.vy = 9.5;
      screenShake(0.12, 0.15);
      spawnParticles(player.x, player.y, 18, 1.25);
      spawnDust(player.x, player.y - player.h/2 + 0.05, 10);
      SFX.hurt();
      showToast("Damaged!", 700);
    }

    function updateEnemies(dt){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const e of world.enemies){
        // Ï£ΩÏùå Ïó∞Ï∂ú(ÎÇ©Ïûë) ÌÉÄÏù¥Î®∏
        if(e.dead){
          e.deathTimer -= dt;
          if(e.deathTimer <= 0){
            scene.remove(e.mesh);
            e.deathTimer = 0;
          }
          continue;
        }

        e.x += e.vx * dt;
        if(e.x < e.roamMin || e.x > e.roamMax) e.vx *= -1;

        e.mesh.position.x = e.x;

        // ‚úÖ Ïä¨ÎùºÏûÑ ÌÖçÏä§Ï≥ê Ïï†ÎãàÎ©îÏù¥ÏÖò(Í±∑Í∏∞/Ìú¥Ïãù)
        e.animT += dt;
        const moving = Math.abs(e.vx) > 0.05;

        // movingÏù¥Î©¥ walkA/walkB Î≤àÍ∞àÏïÑ, ÏïÑÎãàÎ©¥ rest
        const phase = (Math.floor(e.animT*8) % 2);
        const nextTex = moving ? (phase ? texSlimeWalkA : texSlimeWalkB) : texSlimeRest;

        if(e.mesh.material.map !== nextTex){
          e.mesh.material.map = nextTex;
          e.mesh.material.needsUpdate = true;
        }

const ex = e.x - e.w/2;
        const ey = e.y - e.h/2;
        if(aabbIntersect(px,py,player.w,player.h, ex,ey,e.w,e.h)){
          const playerBottom = player.y - player.h*0.5;
          const enemyTop = e.y + e.h*0.5;

          if(player.vy < 0 && playerBottom > enemyTop - 0.25){
            e.dead = true;
            // ‚úÖ ÎÇ©Ïûë(Flat) Ïä§ÌîÑÎùºÏù¥Ìä∏Î°ú Ïû†Íπê Ïó∞Ï∂ú ÌõÑ Ï†úÍ±∞
            e.mesh.material.map = texSlimeFlat;
            e.mesh.material.needsUpdate = true;
            e.mesh.scale.y = 0.55;
            e.deathTimer = 0.14;
            player.vy = 12.0;
            spawnParticles(e.x, e.y, 22, 1.35);
            spawnDust(e.x, e.y - 0.25, 10);
            screenShake(0.10, 0.12);
            SFX.stomp();
            showToast("Stepping!", 500);
          }else{
            hurtPlayer(e.x);
          }
        }
      }
    }

    function updateSprings(){
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(const s of world.springs){
        const sx = s.x - s.w/2;
        const sy = s.y - s.h/2;
        if(aabbIntersect(px,py,player.w,player.h, sx,sy,s.w,s.h)){
          if(player.vy < 0){
            player.vy = 18.5;
            player.jumpHold = 0;
            spawnParticles(s.x, s.y+0.2, 18, 1.2);
            spawnDust(s.x, s.y, 10);
            screenShake(0.10, 0.14);
            showToast("Spring!", 600);
          }
        }
      }
    }

    function updateGoal(){
      if(!world.goal) return;

      const g = world.goal;

      // Î†àÎ≤® ÏΩîÏù∏ Îã§ Î™®ÏúºÎ©¥ ÌôúÏÑ±Ìôî(ÌçºÏ¶ê/ÌÉêÏÉâ ÎäêÎÇå)
      if(!g.active && world.collectedCoinsLevel >= world.totalCoinsLevel){
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("Goal Activation!", 900);
      }

      if(!g.active || game.state !== "play") return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

      if(aabbIntersect(px,py,player.w,player.h, gx,gy,g.w,g.h)){
        // ‚úÖ ÏΩîÏù∏ Ï†ÑÎ∂Ä ÏàòÏßë ÌõÑ Í≥® ÎèÑÏ∞© ‚Üí Î≥¥Ïä§Ï†ÑÏúºÎ°ú Ï†ÑÌôò(Î†àÎ≤®ÏùÑ Î∞îÎ°ú ÎÑòÍ∏∞ÏßÄ ÏïäÏùå)
        startBossFight();
      }
    }
    
	function jumpGoal(){
	    const g = world.goal;

      // Î†àÎ≤® ÏΩîÏù∏ Îã§ Î™®ÏúºÎ©¥ ÌôúÏÑ±Ìôî(ÌçºÏ¶ê/ÌÉêÏÉâ ÎäêÎÇå)
      
        g.active = true;
        g.mesh.material.map = texFlagOn;
        g.mesh.material.needsUpdate = true;
        showToast("Í≥® ÌôúÏÑ±Ìôî!", 900);
      

      

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const gx = g.x - g.w/2;
      const gy = g.y - g.h/2;

     
        startBossFight();
      
	}
	
    // ----------------------------
    // Î≥¥Ïä§Ï†Ñ(Í±∞ÎåÄÌïú Í≥†Îûò)
    //  - ÏΩîÏù∏ Ï†ÑÎ∂Ä ÏàòÏßë ÌõÑ ÍπÉÎ∞ú ÎèÑÏ∞© ‚Üí Î≥¥Ïä§Ï†Ñ ÏßÑÏûÖ
    //  - ÌôîÎ©¥ Ïö∞Ï∏°ÏóêÏÑú ÏÉÅÌïò Ïù¥Îèô
    //  - Í±∞Ìíà ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨(ÎÇúÏù¥ÎèÑ‚Üë: Î∞úÏÇ¨ ÎπàÎèÑ/ÏÜçÎèÑ/Ìå®ÌÑ¥ Í≥†ÎèÑÌôî)
    //  - ÌîåÎ†àÏù¥Ïñ¥Îäî ÎåÄÏãúÎ°ú Î™∏ÌÜµÏóê Î∞ïÏπòÍ∏∞ÌïòÎ©¥ ÌîºÌï¥
    // ----------------------------
    const texBubble = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);

      // Ïô∏Í≥Ω
      g.beginPath();
      g.arc(w/2,h/2,w*0.34,0,Math.PI*2);
      g.closePath();
      g.strokeStyle = "rgba(9,9,9,0.50)";
      g.lineWidth = w*0.03;
      g.stroke();

      // ÎÇ¥Î∂Ä Í∑∏ÎùºÎç∞Ïù¥ÏÖò
      const grd = g.createRadialGradient(w*0.38,h*0.38,w*0.05, w*0.5,h*0.5,w*0.38);
      grd.addColorStop(0, "rgba(220,245,255,0.55)");
      grd.addColorStop(0.55, "rgba(140,210,255,0.20)");
      grd.addColorStop(1, "rgba(40,120,190,0.10)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(w/2,h/2,w*0.33,0,Math.PI*2);
      g.fill();

      // ÌïòÏù¥ÎùºÏù¥Ìä∏
      g.fillStyle = "rgba(255,255,255,0.55)";
      g.beginPath();
      g.ellipse(w*0.38, h*0.35, w*0.10, h*0.07, -0.6, 0, Math.PI*2);
      g.fill();

      g.fillStyle = "rgba(255,255,255,0.28)";
      g.beginPath();
      g.ellipse(w*0.62, h*0.62, w*0.06, h*0.04, 0.7, 0, Math.PI*2);
      g.fill();
    });

    // Î¨∏Ïñ¥Ïö© "Ï¥àÎ°ù Î¨ºÎ∞©Ïö∏" ÌÖçÏä§Ï≤ò(Ï∫îÎ≤ÑÏä§)
    const texDropletGreen = makeCanvasTexture((g,w,h)=>{
      g.clearRect(0,0,w,h);
      const cx = w/2, cy = h/2;

      // Î¨ºÎ∞©Ïö∏ Î≥∏Ï≤¥(ÎààÏóê ÎùÑÎäî Ï¥àÎ°ù Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
      const grd = g.createRadialGradient(cx - w*0.16, cy - h*0.18, w*0.06, cx, cy, w*0.52);
      grd.addColorStop(0.00, "rgba(230,255,230,0.95)");
      grd.addColorStop(0.35, "rgba(90,235,140,0.85)");
      grd.addColorStop(1.00, "rgba(20,120,60,0.35)");
      g.fillStyle = grd;
      g.beginPath();
      // teardrop path
      g.moveTo(cx, h*0.08);
      g.bezierCurveTo(w*0.18, h*0.34, w*0.18, h*0.78, cx, h*0.92);
      g.bezierCurveTo(w*0.82, h*0.78, w*0.82, h*0.34, cx, h*0.08);
      g.closePath();
      g.fill();

      // Ïô∏Í≥Ω
      g.strokeStyle = "rgba(10,10,10,0.45)";
      g.lineWidth = w*0.03;
      g.stroke();

      // ÌïòÏù¥ÎùºÏù¥Ìä∏
      g.fillStyle = "rgba(255,255,255,0.52)";
      g.beginPath();
      g.ellipse(cx - w*0.14, cy - h*0.12, w*0.10, h*0.08, -0.85, 0, Math.PI*2);
      g.fill();
    });


		
// ÎìúÎûòÍ≥§Ïö© ÌååÏù¥Ïñ¥Î≥º ÌÖçÏä§Ï≤ò(Ï∫îÎ≤ÑÏä§) - Í≤ÄÏ†ï Î∞îÌÉï + Îπ®Í∞ï Ìè¨Ïù∏Ìä∏ (Ìù∞ Î∞∞Í≤Ω ÎåÄÎπÑ ÏµúÍ∞ï)
const texFireball = makeCanvasTexture((g,w,h)=>{
  g.clearRect(0,0,w,h);
  g.globalCompositeOperation = "source-over";

  const cx = w/2, cy = h/2;

  // 0) ÏôÑÏ†Ñ Î∂àÌà¨Î™Ö Í≤ÄÏ†ï Ïõê(ÌòïÌÉú Í≥†Ï†ï, Ìù∞ Î∞∞Í≤ΩÏóêÏÑúÎèÑ Î¨¥Ï°∞Í±¥ Î≥¥ÏûÑ)
  g.fillStyle = "rgba(0,0,0,1.0)";
  g.beginPath();
  g.arc(cx, cy, w*0.44, 0, Math.PI*2);
  g.fill();

  // 1) Îπ®Í∞ï ÏΩîÏñ¥(Ï§ëÏã¨Î∂Ä)
  const core = g.createRadialGradient(cx, cy, w*0.02, cx, cy, w*0.22);
  core.addColorStop(0.00, "rgba(255, 60, 60, 1.0)");
  core.addColorStop(0.35, "rgba(180, 0, 0, 1.0)");
  core.addColorStop(1.00, "rgba(80, 0, 0, 1.0)");
  g.fillStyle = core;
  g.beginPath();
  g.arc(cx, cy, w*0.22, 0, Math.PI*2);
  g.fill();

  // 2) Îπ®Í∞ï ÎßÅ(Í≤ÄÏ†ï ÏúÑÏóê ÏÑ†Î™ÖÌïòÍ≤å)
  g.strokeStyle = "rgba(255, 30, 30, 1.0)";
  g.lineWidth = w*0.06;
  g.beginPath();
  g.arc(cx, cy, w*0.32, 0, Math.PI*2);
  g.stroke();

  // 3) Ïô∏Í≥Ω ÌÖåÎëêÎ¶¨(ÏïÑÏ£º ÏñáÏùÄ ÏßÑÌöåÏÉâ) - Í≤ΩÍ≥ÑÍ∞Ä Îçî ÎòêÎ†∑Ìï¥Ïßê
  g.strokeStyle = "rgba(40,40,40,1.0)";
  g.lineWidth = w*0.035;
  g.beginPath();
  g.arc(cx, cy, w*0.46, 0, Math.PI*2);
  g.stroke();

  // 4) Îπ®Í∞ï Ïä§ÌååÌÅ¨(ÏöîÎûÄÌïòÍ≤å, ÎåÄÎπÑ ÌôïÏã§)
  for(let i=0;i<12;i++){
    const a = (i/12)*Math.PI*2;
    const r1 = w*0.10 + (i%3)*w*0.02;
    const r2 = w*0.46;

    const x1 = cx + Math.cos(a)*r1;
    const y1 = cy + Math.sin(a)*r1;
    const x2 = cx + Math.cos(a)*r2;
    const y2 = cy + Math.sin(a)*r2;

    // Í≤ÄÏ†ï Ïä§ÌååÌÅ¨(ÍµµÍ≤å)
    g.strokeStyle = "rgba(0,0,0,0.8)";
    g.lineWidth = w*0.02;
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();

    // Îπ®Í∞ï ÌïòÏù¥ÎùºÏù¥Ìä∏(ÏñáÍ≤å)
    g.strokeStyle = "rgba(255, 40, 40, 1.0)";
    g.lineWidth = w*0.012;
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
  }

  // 5) Ï§ëÏã¨ ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†ê(Îπ®Í∞ï/Ìù∞Îπõ ÏïΩÍ∞Ñ)
  g.fillStyle = "rgba(255,120,120,1.0)";
  g.beginPath();
  g.arc(cx - w*0.05, cy - h*0.05, w*0.06, 0, Math.PI*2);
  g.fill();
});


// Í≥®Î†òÏö© ÎèåÎç©Ïñ¥Î¶¨ ÌÖçÏä§Ï≤ò
const texRock = makeCanvasTexture((g,w,h)=>{
  g.clearRect(0,0,w,h);
  const cx = w/2, cy = h/2;

  const base = g.createRadialGradient(cx - w*0.12, cy - h*0.12, w*0.08, cx, cy, w*0.5);
  base.addColorStop(0.0, "rgba(210,210,210,0.95)");
  base.addColorStop(0.5, "rgba(150,150,150,0.95)");
  base.addColorStop(1.0, "rgba(80,80,80,0.95)");
  g.fillStyle = base;
  const rx = w*0.42;
  const ry = h*0.36;
  const r = Math.min(rx, ry) * 0.35;
  const x0 = cx - rx;
  const y0 = cy - ry;
  const x1 = cx + rx;
  const y1 = cy + ry;
  g.beginPath();
  g.moveTo(x0 + r, y0);
  g.lineTo(x1 - r, y0);
  g.quadraticCurveTo(x1, y0, x1, y0 + r);
  g.lineTo(x1, y1 - r);
  g.quadraticCurveTo(x1, y1, x1 - r, y1);
  g.lineTo(x0 + r, y1);
  g.quadraticCurveTo(x0, y1, x0, y1 - r);
  g.lineTo(x0, y0 + r);
  g.quadraticCurveTo(x0, y0, x0 + r, y0);
  g.closePath();
  g.fill();

  g.strokeStyle = "rgba(30,30,30,0.8)";
  g.lineWidth = w*0.06;
  g.beginPath();
  g.moveTo(x0 + r, y0);
  g.lineTo(x1 - r, y0);
  g.quadraticCurveTo(x1, y0, x1, y0 + r);
  g.lineTo(x1, y1 - r);
  g.quadraticCurveTo(x1, y1, x1 - r, y1);
  g.lineTo(x0 + r, y1);
  g.quadraticCurveTo(x0, y1, x0, y1 - r);
  g.lineTo(x0, y0 + r);
  g.quadraticCurveTo(x0, y0, x0 + r, y0);
  g.closePath();
  g.stroke();

  g.fillStyle = "rgba(255,255,255,0.25)";
  g.beginPath();
  g.ellipse(cx - w*0.12, cy - h*0.10, w*0.12, h*0.08, -0.3, 0, Math.PI*2);
  g.fill();
});

// Ìé≠Í∑ÑÏö© ÏñºÏùå Îèå ÌÖçÏä§Ï≤ò
const texIceRock = makeCanvasTexture((g,w,h)=>{
  g.clearRect(0,0,w,h);
  const cx = w/2, cy = h/2;

  const base = g.createRadialGradient(cx - w*0.12, cy - h*0.12, w*0.08, cx, cy, w*0.5);
  base.addColorStop(0.0, "rgba(220,245,255,0.95)");
  base.addColorStop(0.5, "rgba(140,210,255,0.92)");
  base.addColorStop(1.0, "rgba(70,140,200,0.90)");
  g.fillStyle = base;
  const rx = w*0.42;
  const ry = h*0.36;
  const r = Math.min(rx, ry) * 0.35;
  const x0 = cx - rx;
  const y0 = cy - ry;
  const x1 = cx + rx;
  const y1 = cy + ry;
  g.beginPath();
  g.moveTo(x0 + r, y0);
  g.lineTo(x1 - r, y0);
  g.quadraticCurveTo(x1, y0, x1, y0 + r);
  g.lineTo(x1, y1 - r);
  g.quadraticCurveTo(x1, y1, x1 - r, y1);
  g.lineTo(x0 + r, y1);
  g.quadraticCurveTo(x0, y1, x0, y1 - r);
  g.lineTo(x0, y0 + r);
  g.quadraticCurveTo(x0, y0, x0 + r, y0);
  g.closePath();
  g.fill();

  g.strokeStyle = "rgba(40,90,140,0.85)";
  g.lineWidth = w*0.05;
  g.beginPath();
  g.moveTo(x0 + r, y0);
  g.lineTo(x1 - r, y0);
  g.quadraticCurveTo(x1, y0, x1, y0 + r);
  g.lineTo(x1, y1 - r);
  g.quadraticCurveTo(x1, y1, x1 - r, y1);
  g.lineTo(x0 + r, y1);
  g.quadraticCurveTo(x0, y1, x0, y1 - r);
  g.lineTo(x0, y0 + r);
  g.quadraticCurveTo(x0, y0, x0 + r, y0);
  g.closePath();
  g.stroke();

  g.fillStyle = "rgba(255,255,255,0.45)";
  g.beginPath();
  g.ellipse(cx - w*0.12, cy - h*0.12, w*0.14, h*0.10, -0.3, 0, Math.PI*2);
  g.fill();
});
    

function setBossHUD(on, boss){
      if(!$bossHpWrap) return;
      $bossHpWrap.style.display = on ? "" : "none";
      if(on && boss){
        $bossHpText.textContent = "‚ñ†".repeat(Math.max(0, boss.hp)) + "‚ñ°".repeat(Math.max(0, boss.maxHp - boss.hp));
        $bossLvText.textContent = `Lv${boss.diff}`;
      }
    }

    function buildBossArena(diff, kind='whale'){
      clearWorld();

      // Î∞îÎã•/Î≤Ω: Î≤ΩÏ†êÌîÑ Í∞ÄÎä•ÌïòÍ≤å Í∞ÑÎã®Ìïú Í∏∞Îë• Ï†úÍ≥µ
      const ground = addPlatform(-20, 0, 80, 1.0);
      world.groundTop = ground.y + ground.h;
      world.killY = -12;
      alignWaterToGround(ground.y);

      // Ï¢åÏ∏° ÏãúÏûë Íµ¨Ïó≠ Í∏∞Îë•(Î≤ΩÏ†êÌîÑÏö©)
      // (ÏöîÏ≤≠) Î≥¥Ïä§Ï†Ñ ÏãúÏûë Íµ¨Ïó≠ Í∏∞Îë• Ï†úÍ±∞
      // ÏûëÏùÄ Î∞úÌåê
      addPlatform(-8, 3.0, 5.0, 0.8);
      addPlatform( 2, 4.6, 4.2, 0.8);
	 
	  addPlatform(14, 1.8, 1.8, 0.5);
	  addPlatform(14, 2.8, 2.8, 0.5);
      addPlatform(14, 3.8, 1.8, 0.5);
	  addPlatform(14, 4.8, 2.8, 0.5);
	  addPlatform(14, 5.8, 1.8, 0.5);
	  addPlatform(14, 6.8, 2.8, 0.5);
	  addPlatform(14, 7.8, 1.8, 0.5);
	  addPlatform(14, 8.8, 1.8, 0.5);
	  addPlatform(14, 9.8, 1.8, 0.5);
	  addPlatform(14, 10.8, 1.8, 0.5);
      //addPlatform(14, 5.8, 4.8, 0.8);
      // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò
      player.x = -15.5;
      player.y = 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // (ÏÇ¨Îßù Î¶¨Ïä§Ìè∞) HP Ï†ïÏ±Ö: Î¨¥Ï°∞Í±¥ 5Î°ú ÌöåÎ≥µ
      if(game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "‚ù§‚ù§‚ù§‚ù§‚ù§";
        game.forceFullHP = false;
      }else{
        $hearts.textContent = "‚ù§".repeat(Math.max(0, player.hp)) + "‚ô°".repeat(Math.max(0, 5-player.hp));
      }

      // "ÎøÖ" Îì±Ïû• Ïù¥ÌéôÌä∏ + Î™®ÏÖò
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

	// Î≥¥Ïä§ Ï¢ÖÎ•òÏóê Îî∞Îùº ÌÖçÏä§Ï≤ò ÍµêÏ≤¥(Î°úÎî© Ïã§Ìå® Ïãú Í≥†ÎûòÎ°ú Ìè¥Î∞±)
	if(kind === 'dragon' && BOSS_TEX_DRAGON){
	  BOSS_TEX = BOSS_TEX_DRAGON;
	}else if(kind === 'octopus' && BOSS_TEX_OCTOPUS){
	  BOSS_TEX = BOSS_TEX_OCTOPUS;
	}else if(kind === 'golem' && BOSS_TEX_GOLEM){
	  BOSS_TEX = BOSS_TEX_GOLEM;
	}else if(kind === 'penguin' && BOSS_TEX_PENG){
	  BOSS_TEX = BOSS_TEX_PENG;
	}else{
	  BOSS_TEX = BOSS_TEX_WHALE || BOSS_TEX;
	  kind = 'whale';
	}

      // Î≥¥Ïä§ ÏÉùÏÑ±
      const BOSS_SCALE = 0.7; // 30% smaller (0.7x)
      const baseBossW = (kind === 'golem') ? 5 : (kind === 'penguin' ? 5.6 : 7.2);
      const baseBossH = 5.2;
      const baseHitW  = (kind === 'golem') ? 5 : (kind === 'penguin' ? 4.2 : 4.8);
      const baseHitH  = 3.4;
      const bossW = baseBossW * BOSS_SCALE;
      const bossH = baseBossH * BOSS_SCALE;
      const hitW  = baseHitW * BOSS_SCALE;
      const hitH  = baseHitH * BOSS_SCALE;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(bossW, bossH),
        new THREE.MeshBasicMaterial({ map: BOSS_TEX.idleA, transparent:true, color: 0xffffff })
      );
      mesh.position.set(18, 7.0, 1.2);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.boss = {
        diff,
        kind,
        // ÎìúÎûòÍ≥§: Îçî Îπ†Î•¥Í≥† ÏöîÎûÄÌï® / Î¨∏Ïñ¥: Í≥†Îûò Ìå®ÌÑ¥ Í∏∞Î∞òÏù¥ÏßÄÎßå 20% ÎäêÎ¶º
        speedMul: (kind === 'dragon') ? 1.2 : (kind === 'octopus' ? 0.8 : (kind === 'golem' ? 0.9 : (kind === 'penguin' ? 1.0 : 1.0))),
        rateMul:  (kind === 'dragon') ? 1.2 : (kind === 'octopus' ? 0.8 : (kind === 'golem' ? 0.85 : (kind === 'penguin' ? 0.95 : 1.0))),
        shotMul:  1.0,
        hp: 5,
        maxHp: 5,
        x: mesh.position.x,
        y: mesh.position.y,
		baseX: mesh.position.x-12,   //15 ‚úÖ Ï∂îÍ∞Ä
        baseY: mesh.position.y-4,   //5 ‚úÖ Ï∂îÍ∞Ä
        w: bossW, h: bossH,
        hitW, hitH,
        mesh,
        t: 0,
        invuln: 0,
        hurtT: 0,
        chargeT: 0,
        fireCd: 1.1,
        patternCd: 3.2,
        pattern: "aim",
        trailT: 0,
        prevX: mesh.position.x,
        prevY: mesh.position.y,
        face: 1,
      };

      setBossHUD(true, world.boss);
    }

    
function startBossFight(){
  // Îã§Ïùå Î†àÎ≤®ÏùÄ Î≥¥Ïä§ Í≤©Ìåå ÌõÑ ÏßÑÌñâ
  game.pendingNextLevel = game.level + 1;

  // ÎàÑÏ†Å ÎÇúÏù¥ÎèÑ(=Î≥¥Ïä§ Î†àÎ≤®)
  const diff = Math.max(1, (game.bossDifficulty|0));

  // ‚úÖ Í≤åÏûÑ Î†àÎ≤® Í∏∞Ï§Ä Î≥¥Ïä§ Ï¢ÖÎ•ò
  // - 3Ïùò Î∞∞Ïàò Î†àÎ≤®: Î¨∏Ïñ¥
  // - Í∑∏ Ïô∏: 1(Í≥†Îûò) ‚Üí 2(ÎìúÎûòÍ≥§) ‚Üí 3(Î¨∏Ïñ¥) Î∞òÎ≥µ
  let kind = 'whale';
  const bossCycle = game.level % 5;
  if(bossCycle === 2) kind = 'dragon';
  else if(bossCycle === 3) kind = 'octopus';
  else if(bossCycle === 4) kind = 'golem';
  else if(bossCycle === 0) kind = 'penguin';

  // Î≥¥Ïä§Ï†ÑÏúºÎ°ú Ï†ÑÌôò
  game.state = "bossIntro";
  game.t = 1.2;

  // arena Íµ¨ÏÑ±
  buildBossArena(diff, kind);
  const kindLabel = (kind === 'dragon') ? 'Dragon' : (kind === 'octopus' ? 'Octopus' : (kind === 'golem' ? 'Golem' : (kind === 'penguin' ? 'Penguin' : 'Whale')));
  $stageText.textContent = `BOSS Lv ${diff} (${kindLabel})`;

  showBigMsg(true,
    kind === 'dragon' ? `BOSS !!! Noisy Dragon (Lv ${diff})`
    : (kind === 'octopus' ? `BOSS !!! Funny octopus (Lv ${diff})` : (kind === 'golem' ? `BOSS !!! Stone Golem (Lv ${diff})` : (kind === 'penguin' ? `BOSS !!! Ice Penguin (Lv ${diff})` : `BOSS !!! Big-mouthed Whale (Lv ${diff})`)))
  );

  if(kind === 'dragon'){
    showToast("Boss Stage! Attack with a Dash! ", 15000);
  }else if(kind === 'octopus'){
    showToast("Boss Stage! Attack with a Dash! ", 15000);
  }else if(kind === 'golem'){
    showToast("Boss Stage! Beware of flying rocks!", 15000);
  }else if(kind === 'penguin'){
    showToast("Boss Stage! Beware of ice rocks!", 15000);
  }else{
    showToast("Boss Stage! Attack with a Dash!", 15000);
  }

  showToast("Dash!! ", 15000);
  screenShake(0.99, 0.99);
  screenShake(0.18, 0.20);
  SFX.clear();
}

function spawnBubble(x,y, vx,vy, r=0.42, homing=0){
      const geo = new THREE.PlaneGeometry(r*2, r*2);
      const mat = new THREE.MeshBasicMaterial({ map: texBubble, transparent:true, opacity:0.95 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, 1.1);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.bossBullets.push({
        type:'bubble',
        x,y,r,vx,vy, homing,
        life: 8.0,
        spin: rand(-5,5),
        wob: rand(0,Math.PI*2),
        mesh
      });
    }

function spawnGreenDroplet(x,y, vx,vy, r=0.42, homing=0){
      const geo = new THREE.PlaneGeometry(r*2, r*2);
      const mat = new THREE.MeshBasicMaterial({ map: texDropletGreen, transparent:true, opacity:0.97 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, 1.1);
      mesh.frustumCulled = false;
      scene.add(mesh);

      world.bossBullets.push({
        type:'droplet',
        x,y,r,vx,vy, homing,
        life: 8.0,
        spin: rand(-5,5),
        wob: rand(-Math.PI,Math.PI),
        mesh
      });
    }

    

function spawnFireball(x,y, vx,vy, r=0.38, homing=0){
  const geo = new THREE.PlaneGeometry(r*2, r*2);
  const mat = new THREE.MeshBasicMaterial({
    map: texFireball,
    transparent:true,
    //opacity:0.92,
	opacity:0.92,
    //blending: THREE.AdditiveBlending,
    depthWrite:false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, 1.12);
  mesh.frustumCulled = false;
  scene.add(mesh);

  world.bossBullets.push({
    type:'fire',
    x,y,r,vx,vy, homing,
    life: 7.0,
    spin: rand(-9,9),
    wob: rand(0,Math.PI*2),
    mesh
  });
}

function spawnRock(x,y, vx,vy, r=0.52){
  const geo = new THREE.PlaneGeometry(r*2, r*2);
  const mat = new THREE.MeshBasicMaterial({
    map: texRock,
    transparent:true,
    opacity:0.98
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, 1.12);
  mesh.frustumCulled = false;
  scene.add(mesh);
  spawnDirt(x, y - 0.15, 10);

  world.bossBullets.push({
    type:'rock',
    x,y,r,vx,vy,
    life: 6.2,
    spin: rand(-6,6),
    wob: 0,
    gravity: -18.0,
    mesh
  });
}

function spawnIceRock(x,y, vx,vy, r=0.52){
  const geo = new THREE.PlaneGeometry(r*2, r*2);
  const mat = new THREE.MeshBasicMaterial({
    map: texIceRock,
    transparent:true,
    opacity:0.98
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, 1.12);
  mesh.frustumCulled = false;
  scene.add(mesh);
  spawnIceShards(x, y - 0.12, 12);

  world.bossBullets.push({
    type:'iceRock',
    x,y,r,vx,vy,
    life: 6.2,
    spin: rand(-7,7),
    wob: 0,
    gravity: -18.0,
    mesh
  });
}


function spawnBossShot(b, x,y, vx,vy, r, homing){
  if(b && b.kind === "dragon"){
    spawnFireball(x,y, vx,vy, r*0.92, homing);
    // ÏöîÎûÄÌï®: Î∞úÏÇ¨ ÏàúÍ∞Ñ ÏûëÏùÄ ÌùîÎì§Î¶º/ÌååÌé∏
    screenShake(0.04, 0.05);
    spawnParticles(x, y, 10, 0.9);
  }else if(b && b.kind === "golem"){
    spawnRock(x,y, vx, vy + 1.2, r*1.2);
  }else if(b && b.kind === "penguin"){
    spawnIceRock(x,y, vx, vy + 1.2, r*1.2);
  }else if(b && b.kind === "octopus"){
    spawnGreenDroplet(x,y, vx,vy, r, homing);
  }else{
    spawnBubble(x,y, vx,vy, r, homing);
  }
}

    function chooseBossPattern(diff){
      // diffÍ∞Ä Ïò¨ÎùºÍ∞àÏàòÎ°ù Ìå®ÌÑ¥ ÌíÄ ÌôïÎåÄ
      const pool = ["aim"];
      if(diff >= 2) pool.push("triple");
      if(diff >= 3) pool.push("wave");
      if(diff >= 4) pool.push("homing");
      if(diff >= 6) pool.push("spray");
      return pool[(Math.random()*pool.length)|0];
    }

    function fireBoss(b){
      // Í≥µÌÜµ ÌååÎùºÎØ∏ÌÑ∞(ÎÇúÏù¥ÎèÑ Ïä§ÏºÄÏùº)
      const spd = (7.8 + b.diff*0.85) * (b.speedMul || 1.0);
      const rateBase = Math.max(0.34, 1.05 - b.diff*0.06) / (b.rateMul || 1.0);
      b.fireCd = rateBase * rand(0.85, 1.15);

      // Í≥µÍ≤© Ïó∞Ï∂ú: Ïû†Íπê charge ÌîÑÎ†àÏûÑ
      b.chargeT = 0.14;

      // ÎìúÎûòÍ≥§ÏùÄ Îçî Îπ†Î•¥Í≤å Ïû¨Ï∂©Ï†Ñ(ÏöîÎûÄÌï®)
      if(b.kind === 'dragon') b.chargeT = 0.15;
      if(b.kind === 'golem') b.chargeT = 0.22;
      if(b.kind === 'penguin') b.chargeT = 0.22;

      const dx0 = (player.x - b.x);
      const dy0 = (player.y - b.y);
      const len = Math.hypot(dx0, dy0) || 1;
      const ux = dx0/len, uy = dy0/len;

      if(b.pattern === "aim"){
        spawnBossShot(b, b.x - 2.1, b.y + 0.2, ux*spd, uy*spd, 0.44, 0);
      }else if(b.pattern === "triple"){
        const a = Math.atan2(uy, ux);
        for(const da of [-0.18, 0, 0.18]){
          const vx = Math.cos(a+da)*spd;
          const vy = Math.sin(a+da)*spd;
          spawnBossShot(b, b.x - 2.1, b.y + 0.2, vx, vy, 0.42, 0);
        }
      }else if(b.pattern === "wave"){
        // Ï¢å‚ÜíÏö∞ ÌååÎèÑÏ≤òÎüº ÌùîÎì§Î¶¨Îäî 5Î∞ú
        for(let i=0;i<5;i++){
          const vy = (i-2)*1.25 + Math.sin((b.t+i)*1.1)*0.6;
          spawnBossShot(b, b.x - 2.1, b.y + 0.2 + (i-2)*0.25, -spd*(0.95+0.05*i), vy, 0.40, 0);
        }
      }else if(b.pattern === "homing"){
        // ÎäêÎ¶¨ÏßÄÎßå Ï∂îÏ†Å
        spawnBossShot(b, b.x - 2.1, b.y + 0.2, ux*(spd*0.75), uy*(spd*0.75), 0.50, 1);
        // Î≥¥Ï°∞ÌÉÑ 1Î∞ú(ÎÇúÏù¥ÎèÑ ÎÜíÏùÑÏàòÎ°ù)
        if(b.diff >= 5){
          spawnBossShot(b, b.x - 2.1, b.y - 0.5, ux*(spd*0.70), uy*(spd*0.70), 0.46, 1);
        }
      }else if(b.pattern === "spray"){
        // ÎÑìÏùÄ Î∂ÄÏ±ÑÍº¥ Ïó∞ÏÇ¨
        const base = Math.atan2(uy, ux);
        const count = 7 + Math.min(5, b.diff-6);
        const spread = 0.75;
        for(let i=0;i<count;i++){
          const t = (count<=1)?0:(i/(count-1));
          const da = (t-0.5)*spread;
          const s = spd*(0.85 + 0.25*Math.random());
          spawnBossShot(b, b.x - 2.1, b.y + 0.2, Math.cos(base+da)*s, Math.sin(base+da)*s, 0.38, 0);
        }
      }
    }

    function bossTakeHit(b, hitX, hitY){
      if(b.invuln > 0) return;

      b.hp--;
      b.invuln = 0.28;
      b.hurtT = 0.18;

      setBossHUD(true, b);
      screenShake(0.12, 0.18);
      spawnParticles(hitX, hitY, 30, 1.6);
      spawnDust(hitX, hitY-0.25, 14);
      SFX.stomp();

      // ÎßûÏúºÎ©¥ ÌîåÎ†àÏù¥Ïñ¥ ÌäïÍπÄ(ÎåÄÏãú Í≥µÍ≤© ÎäêÎÇå)
      player.vx = -12.0;
      player.vy = 9.0;
      player.dashT = 0;
      player.dashCd = Math.max(player.dashCd, 0.12);

      if(b.hp <= 0){
        // Î≥¥Ïä§ Í≤©Ìåå
        game.state = "bossDefeat";
        game.t = 2.3;

        // Îã§ÏùåÎ∂ÄÌÑ∞ Îçî Ïñ¥Î†§ÏõÄ
        game.bossDifficulty = (game.bossDifficulty|0) + 1;

        showBigMsg(true, `Defeat successful! Next boss Lv ${game.bossDifficulty}`);
        showToast("Defeat successful! Next Level...", 1200);

        // ÌÉÑ Ï†úÍ±∞
        for(const bb of world.bossBullets){
          if(bb.mesh) scene.remove(bb.mesh);
        }
        world.bossBullets = [];

        screenShake(0.20, 0.22);
        spawnFirework(hitX, hitY+2.0);
        spawnFirework(hitX-1.2, hitY+2.4);
        SFX.clear();
      }
    }

    function updateBoss(dt){
      const b = world.boss;
      if(!b) return;

      b.t += dt;
      b.invuln = Math.max(0, b.invuln - dt);
      b.hurtT  = Math.max(0, b.hurtT  - dt);
      b.chargeT= Math.max(0, b.chargeT- dt);
		// Ïù¥Îèô(ÎìúÎûòÍ≥§ÏùÄ Îπ†Î•¥Í≥† ÏöîÎûÄÌïòÍ≤å / Î¨∏Ïñ¥Îäî Í≥†Îûò Ìå®ÌÑ¥ Í∏∞Î∞òÏù¥ÏßÄÎßå ÎäêÎ¶øÎäêÎ¶ø)
		const isDragon = (b.kind === 'dragon');
		const isOctopus = (b.kind === 'octopus');
		const isGolem = (b.kind === 'golem');
		const isPenguin = (b.kind === 'penguin');
		const baseX = b.baseX;
		const baseY = b.baseY;

		let amp  = 1.6 + b.diff*0.10;
		let spdY = 0.8 + b.diff*0.05;

		if(isDragon){
		  amp  *= 1.35;
		  spdY *= (b.speedMul || 2.0);
		  b.x = baseX + Math.sin(b.t*2.7) * (0.85 + b.diff*0.05) + Math.sin(b.t*12.0) * 0.08;
		  b.y = baseY + Math.sin(b.t * spdY) * amp;
		}else if(isGolem || isPenguin){
		  // Í≥®Î†ò/Ìé≠Í∑Ñ: ÏßÄÎ©¥ÏóêÏÑú Ï¢åÏö∞ Ïù¥ÎèôÎßå
		  const ampX = 2.6 + b.diff*0.12;
		  const spdX = (0.7 + b.diff*0.04) * (isPenguin ? 1.2 : 1.0);
		  b.x = baseX + Math.sin(b.t * spdX) * ampX;
		  b.y = (world.groundTop || baseY) + b.h*0.5 - 0.12;
		}else{
		  // Í≥†Îûò/Î¨∏Ïñ¥: Ïö∞Ï∏° Í≥†Ï†ï + ÏÉÅÌïò ÏÇ¨Ïù∏ Ïù¥Îèô
		  b.x = baseX;
		  spdY *= (b.speedMul || 1.0); // Î¨∏Ïñ¥Îäî speedMul=0.8Î°ú ÎäêÎ¶¨Í≤å
		  if(isOctopus) amp *= 0.92;
		  b.y = baseY + Math.sin(b.t * spdY) * amp;
		  if(isOctopus) b.y += Math.sin(b.t * 0.35) * 0.12; // ÎäêÎ¶øÎäêÎ¶ø 2Ï∞® ÌùîÎì§Î¶º
		}
		b.mesh.position.x = b.x;
		b.mesh.position.y = b.y;

		const face = (player.x < b.x) ? 1 : -1;
		b.face = face;
		b.mesh.scale.x = Math.abs(b.mesh.scale.x || 1) * b.face;

      // ÌîÑÎ†àÏûÑ(Ïó∞Ï∂ú)
	  
      const mat = b.mesh.material;
      
	  /*
	  if(b.hurtT > 0){
        mat.map = BOSS_TEX.hurt;
        mat.color.setHex(0xff6b6b); // Î∂âÏùÄ ÌÉÄÍ≤©
      }else if(b.chargeT > 0){
        mat.map = BOSS_TEX.charge;
        mat.color.setHex(0xffffff);
      }else{
        mat.color.setHex(0xffffff);
        const phase = (Math.floor(b.t*2.2) % 2);
        // Í≥µÍ≤© Ï§ëÏóî attack ÌîÑÎ†àÏûÑÏùÑ ÏÑûÍ∏∞
        if(b.fireCd < 0.18){
          mat.map = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
        }else{
          mat.map = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
        }
      }
	  */
	  const phase = (Math.floor(b.t*2.2) % 2);
		let baseMap;

		if (b.fireCd < 0.18) {
		  baseMap = phase ? BOSS_TEX.attackA : BOSS_TEX.attackB;
		} else {
		  baseMap = phase ? BOSS_TEX.idleA : BOSS_TEX.idleB;
		}

		// chargeÎèÑ Î™∏ÌÜµ ÌîÑÎ†àÏûÑ Ïú†ÏßÄ(ÏõêÌïòÎ©¥ attackAÎ°ú Í≥†Ï†ï)
		if (b.chargeT > 0) {
		  baseMap = BOSS_TEX.attackA;
		}

		mat.map = baseMap;

		// hurtÎäî ÌîÑÎ†àÏûÑÏùÑ Î∞îÍæ∏ÏßÄ ÎßêÍ≥† ‚ÄúÎ∂âÏùÄÏÉâ ÌÉÄÍ≤©‚ÄùÎßå
		if (b.hurtT > 0) {
		  mat.color.setHex(0xff6b6b);
		} else {
		  mat.color.setHex(0xffffff);
		}

	
      mat.needsUpdate = true;

      b.trailT -= dt;
      const moved = Math.hypot(b.x - b.prevX, b.y - b.prevY);
      if(moved > 0.01 && b.trailT <= 0){
        spawnBossAfterimage(b, mat.map);
        b.trailT = 0.06;
      }
      b.prevX = b.x;
      b.prevY = b.y;

// Ìå®ÌÑ¥ Í∞±Ïã†(ÎÇúÏù¥ÎèÑ‚ÜëÏùºÏàòÎ°ù Îçî ÏûêÏ£º/Îçî Îã§Ïñë)
const rateMul = (b.rateMul || 1.0);
b.patternCd -= dt * rateMul;
if(b.patternCd <= 0){
  b.pattern = chooseBossPattern(b.diff);
  b.patternCd = (Math.max(2.0, 3.6 - b.diff*0.12) * rand(0.85, 1.2)) / rateMul;
}

      // Î∞úÏÇ¨
      if(game.state === "boss"){
        b.fireCd -= dt;
        if(b.fireCd <= 0){
          fireBoss(b);
        }
      }

      // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå(ÎåÄÏãú Í≥µÍ≤©/ÌîºÍ≤©)
      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;
      const bx = b.x - b.hitW*0.5;
      const by = b.y - b.hitH*0.5;

      if(aabbIntersect(px,py,player.w,player.h, bx,by,b.hitW,b.hitH)){
        if(player.dashT > 0){
          bossTakeHit(b, player.x + player.facing*0.35, player.y + 0.4);
        }else{
          hurtPlayer(b.x);
        }
      }
    }

    function updateBossBullets(dt){
      if(world.bossBullets.length === 0) return;

      const px = player.x - player.w*0.5;
      const py = player.y - player.h*0.5;

      for(let i=world.bossBullets.length-1; i>=0; i--){
        const bb = world.bossBullets[i];
        bb.life -= dt;

        let wobV = 0;
        if(bb.type !== 'rock' && bb.type !== 'iceRock'){
          // ÏïΩÍ∞Ñ ÌùîÎì§Î¶¨Îäî Í±∞Ìíà ÎäêÎÇå
          bb.wob += dt * 2.2;
          wobV = Math.sin(bb.wob) * 0.55;
        }else if(bb.gravity){
          bb.vy += bb.gravity * dt;
        }

        if(bb.homing){
          const dy = (player.y - bb.y);
          bb.vy += clamp(dy*0.8, -6, 6) * dt * (0.7 + (world.boss?.diff||1)*0.08);
        }

        bb.x += bb.vx * dt;
        bb.y += (bb.vy + wobV) * dt;

        if(bb.mesh){
          bb.mesh.position.x = bb.x;
          bb.mesh.position.y = bb.y;
          bb.mesh.rotation.z += bb.spin * dt * 0.2;
          const s = (bb.type === 'rock' || bb.type === 'iceRock') ? 1.0 : (1.0 + Math.sin(bb.wob*1.7)*0.04);
          bb.mesh.scale.set(s,s,1);
        }

        // Ï∂©Îèå
        const bx = bb.x - bb.r;
        const by = bb.y - bb.r;
        if(aabbIntersect(px,py,player.w,player.h, bx,by,bb.r*2,bb.r*2)){
          hurtPlayer(bb.x);
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
          continue;
        }

        // ÏàòÎ™Ö/ÌôîÎ©¥ Î∞ñ
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;
        const minX = camX - viewW/2 - 4;
        const maxX = camX + viewW/2 + 4;
        const minY = camY - viewH/2 - 4;
        const maxY = camY + viewH/2 + 4;

        if(bb.life <= 0 || bb.x < minX || bb.x > maxX || bb.y < minY || bb.y > maxY){
          if(bb.mesh) scene.remove(bb.mesh);
          world.bossBullets.splice(i,1);
        }
      }
    }


    
    // ----------------------------
    // Ï∂îÎùΩ(ÌôîÎ©¥ ÏïÑÎûò) => Ìå°! => Î¶¨Ïä§ÌÉÄÌä∏
    // ----------------------------
    function startRespawn(reason=""){
      const wasBoss = (game.state === "boss" || game.state === "bossIntro");
      if(game.state !== "play" && !wasBoss) return;
      game.respawnBoss = wasBoss;
      game.state = "respawn";
      game.t = RESPAWN_DELAY;

      // (ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù) ÏÇ¨ÎßùÌïòÎ©¥ Î¨¥Ï°∞Í±¥ HP 5Î°ú ÌöåÎ≥µ
      game.forceFullHP = true;

      // Í≥ºÌïú Ìè≠Î∞ú ÎåÄÏã† "ÏïÑÏâ¨Ïö¥" Ïó∞Ï∂ú + Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏãúÌä∏ Î™®ÏÖò
      spawnDeathPoof(player.x, player.y);
      SFX.death();
      screenShake(0.08, 0.12);

      // ÌîåÎ†àÏù¥Ïñ¥ Ïà®Í∏∞Í≥† ÏÇ¨Îßù Ïä§ÌîÑÎùºÏù¥Ìä∏ ÌëúÏãú
      playerSprite.visible = false;
      beginDeathAnim(player.x, player.y + 0.08, player.facing);

      showToast(reason || "ÏÇ¨Îßù...", 900);
    }

    function checkFallDeath(){
      if(game.state !== "play" && game.state !== "boss" && game.state !== "bossIntro") return;

      const viewBottom = camY + (camera.bottom / camera.zoom);

      // ÌôîÎ©¥ ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÎ©¥ Î¶¨Ïä§ÌÉÄÌä∏
      if(player.y + player.h*0.5 < viewBottom - 0.8){
        startRespawn("Ï∂îÎùΩ! Ìå°!");
        return;
      }

      // ÏïàÏ†ÑÏû•Ïπò(ÏõîÎìú Î∞îÎã• ÏïÑÎûò)
      if(player.y < world.killY){
        startRespawn("Ï∂îÎùΩ! Ìå°!");
        return;
      }
    }

// ----------------------------
    // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
    // ----------------------------
    function updateParticles(dt){
      for(const p of world.particles){
        p.life -= dt;
        if(p.life <= 0){
          scene.remove(p.mesh);
          p.dead = true;
          continue;
        }

        if(p.kind==="firework"){
          // Ìè≠Ï£Ω: ÎìúÎûòÍ∑∏ + Ï§ëÎ†•
          p.vx *= p.drag;
          p.vy *= p.drag;
          p.vy += (GRAVITY_DOWN*0.20)*dt;
        }else if(p.kind==="petal" || p.kind==="petalRain"){
          p.vy += (GRAVITY_DOWN*0.18)*dt;
          const sway = Math.sin((performance.now()*0.001) * (p.sway||8) + p.x*1.3) * 0.55;
          p.vx += sway * dt;
        }else if(p.kind==="popFlash"){
          // ÌîåÎûòÏãú: ÏúÑÏπò Í≥†Ï†ï(Ï§ëÎ†• X)
        }else if(p.kind==="spawnRing"){
          // Îì±Ïû• ÎßÅ: ÏúÑÏπò Í≥†Ï†ï(Ï§ëÎ†• X)
        }else if(p.kind==="spawnRingSmall"){
          // ÏÇ¨Îßù ÏûîÍ¥ë ÎßÅ: ÏúÑÏπò Í≥†Ï†ï(Ï§ëÎ†• X)
        }else if(p.kind==="popSpark"){
          // Ìå°! Ïä§ÌååÌÅ¨: ÏßßÍ≤å ÌäïÍ∏∞Í≥† ÏÇ¨ÎùºÏßê
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += (GRAVITY_DOWN*0.15)*dt;
        }else{
          p.vy += (GRAVITY_DOWN*0.35)*dt;
        }

        p.x += p.vx*dt;
        p.y += p.vy*dt;

        p.mesh.position.set(p.x, p.y, p.mesh.position.z);
        if(p.spin) p.mesh.rotation.z += p.spin*dt;
        // ÌéòÏù¥Îìú/Ïä§ÏºÄÏùº
        if(p.kind==="popFlash"){
          const k = 1 - clamp(p.life/0.22, 0, 1);
          p.mesh.scale.setScalar(2.1 + k*6.0);
        }else if(p.kind==="spawnRing"){
          const k = 1 - clamp(p.life/0.34, 0, 1);
          p.mesh.scale.setScalar(0.85 + k*2.4);
        }else if(p.kind==="spawnRingSmall"){
          const k = 1 - clamp(p.life/0.26, 0, 1);
          p.mesh.scale.setScalar(0.55 + k*1.6);
        }

        let fadeBase = 0.55;
        if(p.kind==="petal" || p.kind==="petalRain") fadeBase = 2.2;
        else if(p.kind==="firework") fadeBase = 1.6;
        else if(p.kind==="popFlash") fadeBase = 0.22;
        else if(p.kind==="spawnRing") fadeBase = 0.34;
        else if(p.kind==="spawnRingSmall") fadeBase = 0.26;
        else if(p.kind==="popSpark") fadeBase = 0.45;
        p.mesh.material.opacity = clamp(p.life/fadeBase, 0, 1);
      }
      world.particles = world.particles.filter(p=>!p.dead);
    }

    function updateAfterimages(dt){
      for(const a of world.afterimages){
        a.life -= dt;
        if(a.life <= 0){
          scene.remove(a.sp);
          a.dead = true;
          continue;
        }
        const lifeMax = a.lifeMax || 0.22;
        const baseOpacity = (a.opacity ?? 0.35);
        a.sp.material.opacity = clamp(a.life / lifeMax, 0, 1) * baseOpacity;
      }
      world.afterimages = world.afterimages.filter(a=>!a.dead);
    }

    function updateBossAfterimages(dt){
      for(const a of world.bossAfterimages){
        a.life -= dt;
        if(a.life <= 0){
          scene.remove(a.mesh);
          a.dead = true;
          continue;
        }
        const lifeMax = a.lifeMax || 0.26;
        a.mesh.material.opacity = clamp(a.life / lifeMax, 0, 1) * (a.opacity ?? 0.26);
      }
      world.bossAfterimages = world.bossAfterimages.filter(a=>!a.dead);
    }

    // ----------------------------
    // Ïπ¥Î©îÎùº/Î∞∞Í≤Ω
    // ----------------------------
    let camX=0, camY=0;
    let perfT=0;
    let camZoom=1.0;

    function updateCamera(dt){
      const lookAhead = clamp(player.vx*0.08, -1.2, 1.2);
      const targetX = player.x + lookAhead + (player.facing*0.25);
      let targetY = player.y + 1.1;
      const minCamY = (world.groundTop ?? -0.6) + 1.1;
      if(targetY < minCamY) targetY = minCamY;

      camX = lerp(camX, targetX, 1 - Math.exp(-12.0*dt));
      camY = lerp(camY, targetY, 1 - Math.exp(-11.0*dt));

      if(shakeT > 0){
        shakeT = Math.max(0, shakeT - dt);
        const s = (shakeT>0) ? shakeP : 0;
        camX += rand(-1,1)*s;
        camY += rand(-1,1)*s;
        shakeP *= 0.92;
      }else{
        shakeP = 0;
      }

      camera.position.set(camX, camY, 10);

      const speed = Math.abs(player.vx) + Math.abs(player.vy)*0.15;
      const dashBoost = (player.dashT > 0) ? 0.12 : 0;
      const targetZoom = clamp(1.02 - speed*0.008 - dashBoost, 0.84, 1.08);
      camZoom = lerp(camZoom, targetZoom, 1 - Math.exp(-6.5*dt));
      camera.zoom = camZoom;
      camera.updateProjectionMatrix();

      bgTex.offset.x = camX * 0.02;
      bgTex.offset.y = camY * 0.01;

      if(waterTexs.length){
        waterTexs[0].offset.x = camX * 0.04;
        waterTexs[0].offset.y = Math.sin(perfT*0.7)*0.02;
        waterTexs[1].offset.x = camX * 0.06;
        waterTexs[1].offset.y = Math.sin(perfT*0.95)*0.03;
        waterTexs[2].offset.x = camX * 0.08;
        waterTexs[2].offset.y = Math.sin(perfT*1.15)*0.035;
      }
      if(waterMeshes.length){
        waterMeshes[1].position.y = waterMeshes[1].userData.baseY + Math.sin(perfT*1.1)*0.08;
        waterMeshes[2].position.y = waterMeshes[2].userData.baseY + Math.sin(perfT*0.9)*0.06;
      }
    }

    // ----------------------------
    // Î†àÎ≤® ÏãúÏûë/Î¶¨ÏÖã
    // ----------------------------
    function resetPlayer(){
      player.vx = 0; player.vy = 0;
      player.facing = 1;

      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;
      player.jumpHold = 0;

      player.dashT = 0;
      player.dashCd = 0;
      player.dashTrailT = 0;
      player.dashCharges = DASH_CHARGES_MAX;
      player.runHold = 0;
      player.runBoost = false;
      player.runTrailT = 0;
      player.runSfxT = 0;

      player.invuln = 0;
      player.hurtT = 0;

      player.isDucking = false;
      player.isClimbing = false;
      player.ladderLock = 0;

      player.slideT = 0;
      player.slideCd = 0;

      player.wallDir = 0;
      player.wallGrace = 0;

      player.landSquashT = 0;
      player.idleStill = 0;
      player.state = "idle";
      player.animT = 0;
      player.duckStepT = 0;

      player.h = STAND_H;

      playerSprite.material.opacity = 1.0;
      setPlayerTex(TEX.idle);
    }

    function startLevel(level, hardReset=false, seedOverride=null, fromDeath=false){
      showBigMsg(false);
      setBossHUD(false);
      game.level = level;
      game.state = "play";
      game.t = 0;
      game.flowerRainT = 0;
      game.fireworkT = 0;

      // Ï†ïÏ±Ö: HP
      if(hardReset || !policy.keepHP || game.forceFullHP){
        player.hp = 5;
        $hearts.textContent = "‚ù§‚ù§‚ù§‚ù§‚ù§";
        game.forceFullHP = false;
      }else{
        // Ïú†ÏßÄ Ïãú ÌòÑÏû¨ hp Í∑∏ÎåÄÎ°ú
        $hearts.textContent = "‚ù§".repeat(Math.max(0, player.hp)) + "‚ô°".repeat(Math.max(0, 5-player.hp));
      }

      // Ï†ïÏ±Ö: ÏΩîÏù∏
      if(hardReset || !policy.keepCoins){
        world.totalCoinsRun = 0;
      }


      // Î†àÎ≤® ÏãúÎìú:
      //  - Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥(Î†àÎ≤® Ï¶ùÍ∞Ä) Ïãú: ÎÇòÎÖ∏Ï¥à Í∏∞Î∞òÏúºÎ°ú ÌÅ∞ ÎûúÎç§ Î≥ÄÌôî
      //  - Ï∂îÎùΩ/Î¶¨Ïä§ÌÉÄÌä∏(fromDeath) Ïãú: ÎèôÏùº ÏãúÎìúÎ°ú ÎèôÏùº Îßµ Ïû¨ÏÉùÏÑ±
      if(seedOverride != null){
        game.levelSeed = (seedOverride >>> 0) || 1;
        seedRng(game.levelSeed);
      }else{
        game.levelSeed = seedFromNano((level * 0x9e3779b9) >>> 0);
      }

      // Ï∂îÎùΩ Î¶¨Ïä§ÌÉÄÌä∏ Ïãú ÏΩîÏù∏ ÌååÎ∞ç Î∞©ÏßÄ: Î†àÎ≤® ÏãúÏûë ÏãúÏ†êÏúºÎ°ú ÎêòÎèåÎ¶º
      if(!fromDeath){
        world.totalCoinsRunAtLevelStart = world.totalCoinsRun;
      }else{
        world.totalCoinsRun = world.totalCoinsRunAtLevelStart;
      }

      buildRandomLevel(level);

      // ÏãúÏûë ÏúÑÏπò(Îßµ Ïä§Ìè∞ Ïö∞ÏÑ†)
      const sp = world.currentMap?.spawn;
      player.x = (sp && Number.isFinite(sp.x)) ? sp.x : -15.5;
      player.y = (sp && Number.isFinite(sp.y)) ? sp.y : 2.6;
      resetPlayer();
      playerSprite.visible = true;

      // "ÎøÖ" Îì±Ïû• Ïù¥ÌéôÌä∏ + Î™®ÏÖò
      player.spawnT = SPAWN_DUR;
      spawnAppear(player.x, player.y);
      SFX.spawn();

      $dashText.textContent = `${player.dashCharges}/${DASH_CHARGES_MAX}`;
      showToast(fromDeath ? "Restart!" : `Level ${level} ÏãúÏûë!`, fromDeath ? 650 : 900);
    }

    // ----------------------------
    // Î£®ÌîÑ(Í≥†Ï†ï ÌÉÄÏûÑÏä§ÌÖù)
    // ----------------------------
    const fixed = 1/120;
    let acc = 0;
    let last = performance.now()/1000;

    function step(dt){
      if(toastT > 0){
        toastT -= dt;
        if(toastT <= 0) $toast.style.opacity = "0";
      }

      // DEV ÏóêÎîîÌÑ∞Í∞Ä ÏºúÏ†∏ÏûàÏúºÎ©¥ Í≤åÏûÑ Î°úÏßÅÏùÑ ÏùºÏãúÏ†ïÏßÄÌïòÍ≥†, ÏóêÎîîÌÑ∞ Î†åÎçî/ÏûÖÎ†•Îßå Ï≤òÎ¶¨
      if(window.__DEV_EDITOR && window.__DEV_EDITOR.enabled){
        window.__DEV_EDITOR.step(dt);
        // ÏûÖÎ†• ÌîåÎûòÍ∑∏ ÏûîÏÉÅ Î∞©ÏßÄ
        input.jumpPressed = false;
        input.jumpReleased = false;
        input.dashPressed = false;
        updateDebugOverlay();
        return;
      }

      if(game.paused){
        updateDebugOverlay();
        return;
      }

      if(game.state === "celebrate"){
        game.t -= dt;

        // Ïó∞Ï∂ú Ï§ë ÍΩÉÎπÑ + Ìè≠Ï£Ω ÏßÄÏÜç
        game.flowerRainT -= dt;
        game.fireworkT -= dt;

        // ÌòÑÏû¨ Î∑∞ ÌÅ¨Í∏∞ Ï∂îÏ†ï
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;

        if(game.flowerRainT <= 0){
          game.flowerRainT = 0.08;
          spawnFlowerRain(camX, camY, viewW, viewH, 10);
        }
        if(game.fireworkT <= 0){
          game.fireworkT = 0.35;
          spawnFirework(camX + rand(-viewW*0.35, viewW*0.35), camY + rand(0.6, viewH*0.45));
        }

        // Ïó∞Ï∂ú ÎèôÏïà Ï∫êÎ¶≠ÌÑ∞ ÏÇ¥Ïßù Í∞êÏÜç
        player.vx *= 0.93;
        player.vy *= 0.93;

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "next";
          game.t = 0.75;
        }
      }else if(game.state === "bossIntro"){
        game.t -= dt;

        // Ïù∏Ìä∏Î°ú Ï§ëÏóêÎèÑ Ïù¥Îèô/Ï†êÌîÑ/Î≤ΩÏπòÍ∏∞ Í∞ÄÎä•(Î∞úÏÇ¨Îßå Ïû†Íπê ÎåÄÍ∏∞)
        updatePlayer(dt);
        updateBoss(dt);

        if(game.t <= 0){
          showBigMsg(false);
          game.state = "boss";
          showToast("START! (Dash into the boss to attack)", 900);
        }
      }else if(game.state === "boss"){
        updatePlayer(dt);
        updateBoss(dt);
        updateBossBullets(dt);
      }else if(game.state === "bossDefeat"){
        game.t -= dt;

        // Í≤©Ìåå Ïó∞Ï∂ú(Ìè≠Ï£Ω Ï°∞Í∏à Îçî)
        game.fireworkT -= dt;
        if(game.fireworkT <= 0){
          game.fireworkT = 0.22;
          spawnFirework(camX + rand(-2.2, 2.2), camY + rand(1.0, 4.4));
        }

        // Î≥¥Ïä§ ÏÑúÏÑúÌûà ÏÇ¨ÎùºÏßê
        if(world.boss?.mesh){
          const a = clamp(game.t/2.3, 0, 1);
          world.boss.mesh.material.opacity = a;
          world.boss.mesh.material.needsUpdate = true;
        }

        // Ï∫êÎ¶≠ÌÑ∞ Í∞êÏÜç
        player.vx *= 0.95;
        player.vy *= 0.95;

        if(game.t <= 0){
          showBigMsg(false);
          setBossHUD(false);
          // Îã§Ïùå Î†àÎ≤® ÏßÑÌñâ
          startLevel(game.pendingNextLevel, false);
          return;
        }
      }else if(game.state === "next"){
        game.t -= dt;
        if(game.t <= 0){
          startLevel(game.level + 1, false);
        }
      }else if(game.state === "respawn"){
        game.t -= dt;

        // Ïó∞Ï∂ú ÎèôÏïà Ï∫êÎ¶≠ÌÑ∞ Í∞êÏÜç(ÏÖÄÎ†àÏä§Ìä∏ ÎäêÎÇå)
        player.vx *= 0.88;
        player.vy *= 0.88;

        if(game.t <= 0){
          // ÏÇ¨Îßù Ïä§ÌîÑÎùºÏù¥Ìä∏ Ï†ïÎ¶¨(ÌòπÏãú ÎÇ®ÏïÑÏûàÏúºÎ©¥)
          endDeathAnim();

          if(game.respawnBoss){

				/*const diff = Math.max(1, (game.bossDifficulty|0));
				const kind = (diff % 2 === 0) ? 'dragon' : 'whale';
				game.respawnBoss = false;
				game.state = "bossIntro";
				game.t = 0.9;

				buildBossArena(diff, kind);
				$stageText.textContent = `BOSS Lv ${diff} (${kind === 'dragon' ? 'Dragon' : 'Whale'})`;
				showBigMsg(true, kind === 'dragon' ? `BOSS Retry! Dragon (Lv ${diff})` : `BOSS Retry! Whale (Lv ${diff})`);
				showToast(kind === 'dragon' ? "reChallenge! Beware of fire!" : "re Challenge!", 900);
				return;
				*/
				const diff = Math.max(1, (game.bossDifficulty|0));

				// 1: Í≥†Îûò, 2: ÎìúÎûòÍ≥§, 3: Î¨∏Ïñ¥, 4: Í≥®Î†ò, 5: Ìé≠Í∑Ñ
				const kind =
				  (diff % 5 === 1) ? 'whale' :
				  (diff % 5 === 2) ? 'dragon' :
				  (diff % 5 === 3) ? 'octopus' :
				  (diff % 5 === 4) ? 'golem' :
									'penguin';

				game.respawnBoss = false;
				game.state = "bossIntro";
				game.t = 0.9;

				buildBossArena(diff, kind);

				const kindKo = (kind === 'dragon') ? 'Dragon' : (kind === 'octopus') ? 'Octopus' : (kind === 'golem' ? 'Golem' : (kind === 'penguin' ? 'Penguin' : 'Whale'));
				$stageText.textContent = `BOSS Lv ${diff} (${kindKo})`;

				const introMsg =
				  (kind === 'dragon')  ? `BOSS Retry! Dragon (Lv ${diff})` :
				  (kind === 'octopus') ? `BOSS Retry! Octopus (Lv ${diff})` :
				  (kind === 'golem') ? `BOSS Retry! Golem (Lv ${diff})` :
				  (kind === 'penguin') ? `BOSS Retry! Penguin (Lv ${diff})` :
										 `BOSS Retry! Whale (Lv ${diff})`;

				showBigMsg(true, introMsg);

				const toastMsg =
				  (kind === 'dragon')  ? "reChallenge!" :
				  (kind === 'octopus') ? "reChallenge!" :
										 "reChallenge!";

				showToast(toastMsg, 900);
				return;
          }

          startLevel(game.level, false, game.levelSeed, true);
          return;
        }
      }else{
        updatePlayer(dt);
        updateSprings();
        updateEnemies(dt);
        updateCoins(dt);
        updateGoal();
      }

      updateParticles(dt);
      updateAfterimages(dt);
      updateBossAfterimages(dt);
      updateDeathAnim(dt);

      input.jumpPressed = false;
      input.jumpReleased = false;
      input.dashPressed = false;

      updateCamera(dt);

      if(game.state === "play" || game.state === "boss" || game.state === "bossIntro") checkFallDeath();
      updateDebugOverlay();
    }

    function animate(){
      const now = performance.now()/1000;
      let dt = now - last;
      last = now;

      dt = clamp(dt, 0, 0.05);
      acc += dt;
      perfT += dt;

      while(acc >= fixed){
        step(fixed);
        acc -= fixed;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }


    // ----------------------------
    // DEV Îßµ ÏóêÎîîÌÑ∞ (F2 ÌÜ†Í∏Ä)
    //  - Îßµ Ï†úÏûë ‚Üí JSON Îã§Ïö¥Î°úÎìú(Îßµ/Ìå©)
    //  - Ï†ÄÏû•(LocalStorage) ‚Üí Í≤åÏûÑÏóêÏÑú Ï¶âÏãú ÏÇ¨Ïö©
    // ----------------------------
    (function initDevMapEditor(){
      const $panel = document.getElementById("devPanel");
      const $toggle = document.getElementById("devToggle");
      const $test = document.getElementById("devTest");
      const $status = document.getElementById("devStatus");
      const $tools = document.getElementById("devTools");
      const $props = document.getElementById("devProps");
      const $mapList = document.getElementById("devMapList");
      const $mapInfo = document.getElementById("devMapInfo");
      const $snap = document.getElementById("devSnap");
      const $grid = document.getElementById("devGrid");
      const $freeCam = document.getElementById("devFreeCam");
      const $mini = document.getElementById("devMiniMap");
      const $importFile = document.getElementById("devImportFile");
      const $btnSave = document.getElementById("devSave");
      const $btnNew = document.getElementById("devNew");
      const $btnDup = document.getElementById("devDup");
      const $btnDel = document.getElementById("devDel");
      const $btnExportMap = document.getElementById("devExportMap");
      const $btnExportPack = document.getElementById("devExportPack");
      const $toast2 = document.getElementById("devToast2");
      const $tabBar = document.getElementById("devTabs");
      const $tabButtons = $tabBar ? [...$tabBar.querySelectorAll(".tab")] : [];
      const $tabPages = $panel ? [...$panel.querySelectorAll(".tabPage")] : [];

      if(!$panel || !$mini) return;

      const miniCtx = $mini.getContext("2d");

      function toast2(msg, ms=900){
        if(!$toast2) return;
        $toast2.textContent = msg;
        $toast2.style.opacity = "1";
        clearTimeout(toast2._t);
        toast2._t = setTimeout(()=>{ $toast2.style.opacity = "0"; }, ms);
      }

      function downloadJson(filename, obj){
        const s = JSON.stringify(obj, null, 2);
        const blob = new Blob([s], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 500);
      }

      function ensurePack(){
        activePack = normalizePack(activePack || EMBEDDED_MAP_PACK);
        if(!activePack.maps.length){
          activePack.maps.push(normalizeMap({ name:"ÏÉà Îßµ" }));
        }
        return activePack;
      }

      const state = {
        enabled: false,
        tool: "platform",
        tab: "edit",
        snap: true,
        grid: 0.5,
        freeCam: true,
        pack: ensurePack(),
        mapIndex: 0,
        map: null,
        sel: null,
        drag: null,
        camX: 0,
        camY: 0,
        miniDrag: null,
        ghostFill: null,
        ghostLine: null,
        gridLines: null,
        prevGameState: null,
        prevPolicy: null,
      };

      function setTab(id){
        if(!id) return;
        state.tab = id;
        for(const b of $tabButtons){
          b.classList.toggle("on", b.dataset.tabTarget === id);
        }
        for(const p of $tabPages){
          p.classList.toggle("on", p.dataset.tab === id);
        }
      }
      for(const b of $tabButtons){
        b.addEventListener("click", ()=> setTab(b.dataset.tabTarget));
      }
      setTab(state.tab || "edit");

      const TOOLSET = [
        { id:"select",   label:"Select" },
        { id:"platform", label:"Platform" },
        { id:"ladder",   label:"Ladder" },
        { id:"coin",     label:"Coin" },
        { id:"enemy",    label:"Slime" },
        { id:"spring",   label:"Spring" },
        { id:"spawn",    label:"Spawnt" },
        { id:"goal",     label:"Goal" },
        { id:"delete",   label:"Del" },
      ];

      function setTool(id){
        state.tool = id;
        [...$tools.querySelectorAll(".tool")].forEach(b=>{
          b.classList.toggle("on", b.dataset.id === id);
        });
        const cur = state.tool;
        const curCursor = (cur === "platform" || cur === "ladder") ? "crosshair" :
                          (cur === "delete") ? "not-allowed" :
                          (cur === "select") ? "pointer" : "copy";
        renderer.domElement.style.cursor = state.enabled ? curCursor : "";
      }

      function syncToggles(){
        state.snap = !!$snap.checked;
        state.grid = Math.max(0.1, Number($grid.value) || 0.5);
        state.freeCam = !!$freeCam.checked;
      }

      function clamp01(v){ return Math.max(0, Math.min(1, v)); }

      function worldFromScreen(clientX, clientY){
        const rect = renderer.domElement.getBoundingClientRect();
        const ndcX = ((clientX - rect.left) / rect.width) * 2 - 1;
        const ndcY = -(((clientY - rect.top) / rect.height) * 2 - 1);
        const v = new THREE.Vector3(ndcX, ndcY, 0);
        v.unproject(camera);
        return { x: v.x, y: v.y };
      }

      function snapVal(v){
        return state.snap ? (Math.round(v / state.grid) * state.grid) : v;
      }

      function ensureGhost(){
        if(state.ghostFill) return;

        const fill = new THREE.Mesh(
          new THREE.PlaneGeometry(1,1),
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.18 })
        );
        fill.position.set(0,0,3.0);
        fill.visible = false;
        scene.add(fill);

        const geom = new THREE.BufferGeometry();
        const pos = new Float32Array(5*3); // loop
        geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        const line = new THREE.Line(
          geom,
          new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.45 })
        );
        line.position.set(0,0,3.01);
        line.visible = false;
        scene.add(line);

        state.ghostFill = fill;
        state.ghostLine = line;
      }

      function setGhostRect(x, y, w, h, on){
        ensureGhost();
        const fill = state.ghostFill;
        const line = state.ghostLine;

        fill.visible = !!on;
        line.visible = !!on;
        if(!on) return;

        fill.scale.set(w, h, 1);
        fill.position.set(x + w/2, y + h/2, 3.0);

        const arr = line.geometry.attributes.position.array;
        // local coords relative to line position (0,0)
        const pts = [
          [x, y], [x+w, y], [x+w, y+h], [x, y+h], [x, y]
        ];
        for(let i=0;i<5;i++){
          arr[i*3+0] = pts[i][0];
          arr[i*3+1] = pts[i][1];
          arr[i*3+2] = 0;
        }
        line.geometry.attributes.position.needsUpdate = true;
      }

      function ensureGridLinesForMap(m){
        if(state.gridLines){
          scene.remove(state.gridLines);
          state.gridLines.geometry.dispose();
          state.gridLines.material.dispose();
          state.gridLines = null;
        }
        // Îã®Ïàú Í∑∏Î¶¨Îìú: Îßµ Î≤îÏúÑ Í∏∞Î∞ò
        const b = computeBounds(m);
        const step = Math.max(0.5, state.grid);
        const minX = Math.floor((b.minX - 6)/step)*step;
        const maxX = Math.ceil((b.maxX + 6)/step)*step;
        const minY = Math.floor((b.minY - 6)/step)*step;
        const maxY = Math.ceil((b.maxY + 6)/step)*step;

        const lines = [];
        for(let x=minX; x<=maxX+1e-6; x+=step){
          lines.push(x, minY, 0,  x, maxY, 0);
        }
        for(let y=minY; y<=maxY+1e-6; y+=step){
          lines.push(minX, y, 0,  maxX, y, 0);
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(lines), 3));
        const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.12 });
        const grid = new THREE.LineSegments(geom, mat);
        grid.position.z = 2.95;
        grid.frustumCulled = false;
        scene.add(grid);
        state.gridLines = grid;
      }

      function computeBounds(m){
        const g = m.ground;
        let minX = g.x, maxX = g.x+g.w;
        let minY = g.y, maxY = g.y+g.h;

        const expandRect = (x,y,w,h)=>{
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x+w);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y+h);
        };
        const expandPt = (x,y)=>{
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        };

        for(const p of m.platforms) expandRect(p.x,p.y,p.w,p.h);
        for(const l of m.ladders) expandRect(l.x,l.y,l.w,l.h);
        for(const c of m.coins) expandPt(c.x,c.y);
        for(const e of m.enemies) expandPt(e.x,e.y);
        for(const s of m.springs) expandPt(s.x,s.y);
        expandPt(m.spawn.x, m.spawn.y);
        expandPt(m.goal.x, m.goal.y);

        // padding
        const groundTop = g.y + g.h;
        minY = Math.max(minY, groundTop);
        const padX = 8, padYTop = 6, padYBottom = 0;
        return {
          minX: minX - padX,
          maxX: maxX + padX,
          minY: minY - padYBottom,
          maxY: maxY + padYTop
        };
      }

      function drawMiniMap(){
        const m = state.map;
        if(!m) return;

        const W = $mini.width, H = $mini.height;
        miniCtx.clearRect(0,0,W,H);

        // background
        miniCtx.fillStyle = "rgba(255,255,255,0.85)";
        miniCtx.fillRect(0,0,W,H);

        const b = computeBounds(m);
        const spanX = Math.max(1e-6, b.maxX - b.minX);
        const spanY = Math.max(1e-6, b.maxY - b.minY);
        const sx = W / spanX;
        const sy = H / spanY;
        const s = Math.min(sx, sy);
        const ox = (W - spanX*s) * 0.5;
        const oy = (H - spanY*s) * 0.5;

        const toX = x => ox + (x - b.minX) * s;
        const toY = y => H - (oy + (y - b.minY) * s);

        // grid
        const step = Math.max(0.5, state.grid);
        miniCtx.strokeStyle = "rgba(0,0,0,0.06)";
        miniCtx.lineWidth = 1;
        miniCtx.beginPath();
        for(let x = Math.floor(b.minX/step)*step; x <= b.maxX+1e-6; x += step){
          const px = toX(x);
          miniCtx.moveTo(px, 0);
          miniCtx.lineTo(px, H);
        }
        for(let y = Math.floor(b.minY/step)*step; y <= b.maxY+1e-6; y += step){
          const py = toY(y);
          miniCtx.moveTo(0, py);
          miniCtx.lineTo(W, py);
        }
        miniCtx.stroke();

        // ground + platforms
        miniCtx.fillStyle = "rgba(0,0,0,0.20)";
        const g = m.ground;
        const groundTop = g.y + g.h;
        const stripH = Math.max(2, Math.min(4, g.h*s*0.15));
        miniCtx.fillRect(toX(g.x), toY(groundTop) - stripH, g.w*s, stripH);

        miniCtx.fillStyle = "rgba(0,0,0,0.26)";
        for(const p of m.platforms){
          miniCtx.fillRect(toX(p.x), toY(p.y+p.h), p.w*s, p.h*s);
        }

        // ladders
        miniCtx.fillStyle = "rgba(45,123,255,0.25)";
        for(const l of m.ladders){
          miniCtx.fillRect(toX(l.x), toY(l.y+l.h), l.w*s, l.h*s);
        }

        // points
        function dot(x,y,r,fill){
          miniCtx.beginPath();
          miniCtx.arc(toX(x), toY(y), r, 0, Math.PI*2);
          miniCtx.closePath();
          miniCtx.fillStyle = fill;
          miniCtx.fill();
        }
        for(const c of m.coins) dot(c.x,c.y, 3.2, "rgba(255,170,0,0.85)");
        for(const e of m.enemies) dot(e.x,e.y, 3.2, "rgba(255,70,70,0.85)");
        for(const s of m.springs) dot(s.x,s.y, 3.2, "rgba(135,70,255,0.85)");

        dot(m.spawn.x, m.spawn.y, 4.2, "rgba(0,180,90,0.88)");
        dot(m.goal.x,  m.goal.y,  4.2, "rgba(0,0,0,0.75)");

        // camera viewport
        const viewW = (camera.right - camera.left) / camera.zoom;
        const viewH = (camera.top - camera.bottom) / camera.zoom;

        const cx = state.freeCam ? state.camX : camX;
        const cy = state.freeCam ? state.camY : camY;

        const vx = cx - viewW/2;
        const vy = cy - viewH/2;

        miniCtx.strokeStyle = "rgba(0,0,0,0.70)";
        miniCtx.lineWidth = 2;
        miniCtx.strokeRect(toX(vx), toY(vy+viewH), viewW*s, viewH*s);
      }

      function pickAt(x, y){
        const m = state.map;
        if(!m) return null;

        // Ïö∞ÏÑ†: spawn/goal
        const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
        const thr2 = (state.grid*0.7)*(state.grid*0.7);

        if(dist2(x,y,m.spawn.x,m.spawn.y) < thr2) return { kind:"spawn" };
        if(dist2(x,y,m.goal.x,m.goal.y) < thr2) return { kind:"goal" };

        // points
        const findPoint = (arr, kind)=>{
          let best = -1, bestD = Infinity;
          for(let i=0;i<arr.length;i++){
            const d = dist2(x,y,arr[i].x,arr[i].y);
            if(d < bestD){ bestD = d; best = i; }
          }
          if(best >= 0 && bestD < thr2*2.5) return { kind, i: best };
          return null;
        };
        let hit = findPoint(m.coins, "coin");
        if(hit) return hit;
        hit = findPoint(m.enemies, "enemy");
        if(hit) return hit;
        hit = findPoint(m.springs, "spring");
        if(hit) return hit;

        // rects (platform, ladder)
        const inRect = (r)=> x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h;
        for(let i=m.platforms.length-1;i>=0;i--){
          const p = m.platforms[i];
          if(inRect(p)) return { kind:"platform", i };
        }
        for(let i=m.ladders.length-1;i>=0;i--){
          const l = m.ladders[i];
          if(inRect(l)) return { kind:"ladder", i };
        }
        return null;
      }

      function setSelection(sel){
        state.sel = sel;
        renderProps();
      }

      function renderProps(){
        const sel = state.sel;
        const m = state.map;

        if(!sel || !m){
          $props.innerHTML = `<div class="tag">Not Selected Object</div>`;
          return;
        }

        function row(label, value, onChange){
          const div = document.createElement("div");
          div.className = "propRow";
          const lab = document.createElement("label");
          lab.textContent = label;
          const input = document.createElement("input");
          input.type = "number";
          input.step = String(state.grid);
          input.value = String(value);
          input.addEventListener("change", ()=>{
            const v = Number(input.value);
            if(Number.isFinite(v)) onChange(v);
          });
          div.appendChild(lab);
          div.appendChild(input);
          return div;
        }

        $props.innerHTML = "";
        const box = document.createElement("div");
        box.className = "tag";
        box.textContent = `${sel.kind}` + (Number.isFinite(sel.i) ? ` #${sel.i}` : "");
        $props.appendChild(box);

        const apply = ()=>{
          // ladder topLow/topHigh ÏûêÎèô Ï†ïÌï©(Í∏∞Î≥∏)
          if(sel.kind === "ladder"){
            const l = m.ladders[sel.i];
            if(l){
              l.topLow = (Number.isFinite(l.topLow) ? l.topLow : l.y);
              l.topHigh = (Number.isFinite(l.topHigh) ? l.topHigh : (l.y+l.h));
            }
          }
          rebuild(false);
        };

        if(sel.kind === "platform"){
          const p = m.platforms[sel.i];
          $props.appendChild(row("x", p.x, v=>{ p.x=v; apply(); }));
          $props.appendChild(row("y", p.y, v=>{ p.y=v; apply(); }));
          $props.appendChild(row("w", p.w, v=>{ p.w=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("h", p.h, v=>{ p.h=Math.max(0.2,v); apply(); }));
        }else if(sel.kind === "ladder"){
          const l = m.ladders[sel.i];
          $props.appendChild(row("x", l.x, v=>{ l.x=v; apply(); }));
          $props.appendChild(row("y", l.y, v=>{ l.y=v; apply(); }));
          $props.appendChild(row("w", l.w, v=>{ l.w=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("h", l.h, v=>{ l.h=Math.max(0.2,v); apply(); }));
          $props.appendChild(row("topLow", l.topLow, v=>{ l.topLow=v; apply(); }));
          $props.appendChild(row("topHigh", l.topHigh, v=>{ l.topHigh=v; apply(); }));
        }else if(sel.kind === "coin"){
          const c = m.coins[sel.i];
          $props.appendChild(row("x", c.x, v=>{ c.x=v; apply(); }));
          $props.appendChild(row("y", c.y, v=>{ c.y=v; apply(); }));
        }else if(sel.kind === "enemy"){
          const e = m.enemies[sel.i];
          $props.appendChild(row("x", e.x, v=>{ e.x=v; apply(); }));
          $props.appendChild(row("y", e.y, v=>{ e.y=v; apply(); }));
        }else if(sel.kind === "spring"){
          const s = m.springs[sel.i];
          $props.appendChild(row("x", s.x, v=>{ s.x=v; apply(); }));
          $props.appendChild(row("y", s.y, v=>{ s.y=v; apply(); }));
        }else if(sel.kind === "spawn"){
          $props.appendChild(row("x", m.spawn.x, v=>{ m.spawn.x=v; apply(); }));
          $props.appendChild(row("y", m.spawn.y, v=>{ m.spawn.y=v; apply(); }));
        }else if(sel.kind === "goal"){
          $props.appendChild(row("x", m.goal.x, v=>{ m.goal.x=v; apply(); }));
          $props.appendChild(row("y", m.goal.y, v=>{ m.goal.y=v; apply(); }));
        }
      }

      function rebuild(alsoUpdateList=true){
        // ÌòÑÏû¨ ÎßµÏùÑ ÎπåÎìú(Í≤åÏûÑ ÏõîÎìúÎ°ú Î∞òÏòÅ)
        buildLevelFromJson(state.map, state.mapIndex+1, state.mapIndex, state.pack.maps.length);

        // DEV Î™®ÎìúÏóêÏÑúÎäî ÌîåÎ†àÏù¥Ïñ¥Î•º Î©ÄÎ¶¨ Î≥¥ÎÇ¥ÏÑú ÏΩîÏù∏/Ï∂©Îèå ÏòÅÌñ• ÏµúÏÜåÌôî
        player.x = 9999;
        player.y = 9999;
        player.vx = 0; player.vy = 0;

        // Ïπ¥Î©îÎùº
        if(state.freeCam){
          camera.position.set(state.camX, state.camY, 10);
          camX = state.camX; camY = state.camY;
        }

        setGhostRect(0,0,1,1,false);
        ensureGridLinesForMap(state.map);

        if(alsoUpdateList) renderMapList();
        drawMiniMap();
      }

      function openDev(){
        syncToggles();
        state.pack = ensurePack();
        state.mapIndex = Math.max(0, Math.min(state.mapIndex, state.pack.maps.length-1));
        state.map = deepClone(state.pack.maps[state.mapIndex]);
        state.sel = null;

        state.prevGameState = game.state;
        game.state = "dev";

        // Ï†ïÏ±Ö ÏòÅÌñ• ÏµúÏÜåÌôî(DEV Ï§ë ÏΩîÏù∏ ÎàÑÏ†Å Îì±)
        state.prevPolicy = { ...policy };
        policy.keepCoins = false;
        policy.keepHP = true;

        state.enabled = true;
        $panel.style.display = "block";
        $panel.setAttribute("aria-hidden","false");
        $status.textContent = "ON";
        $status.style.background = "rgba(45,123,255,.14)";
        $mapInfo.textContent = `maps:${state.pack.maps.length}`;

        // Ïπ¥Î©îÎùº Ï¥àÍ∏∞
        state.camX = camX;
        state.camY = camY;

        // Ìà¥Î∞î Î†åÎçî
        if(!$tools.dataset.ready){
          $tools.dataset.ready = "1";
          $tools.innerHTML = "";
          for(const t of TOOLSET){
            const b = document.createElement("button");
            b.className = "tool";
            b.textContent = t.label;
            b.dataset.id = t.id;
            b.addEventListener("click", ()=>{
              setTool(t.id);
              toast2(`ÎèÑÍµ¨: ${t.label}`, 700);
            });
            $tools.appendChild(b);
          }
        }
        setTool(state.tool);

        rebuild(true);
        toast2("DEV Îßµ ÏóêÎîîÌÑ∞ ON (F2Î°ú Ï¢ÖÎ£å)", 1100);
      }

      function closeDev(restart=true){
        if(!state.enabled) return;

        state.enabled = false;
        $panel.style.display = "none";
        $panel.setAttribute("aria-hidden","true");
        $status.textContent = "OFF";
        $status.style.background = "";

        // Ï†ïÏ±Ö Î≥µÏõê
        if(state.prevPolicy){
          Object.assign(policy, state.prevPolicy);
        }

        // DEV Î≥¥Ï°∞ Ïò§Î∏åÏ†ùÌä∏ Ï†ïÎ¶¨(ghostÎäî ÎÇ®Í≤®ÎèÑ Î¨¥Î∞©ÌïòÎÇò, ÍπîÎÅîÌûà)
        if(state.gridLines){
          scene.remove(state.gridLines);
          state.gridLines.geometry.dispose();
          state.gridLines.material.dispose();
          state.gridLines = null;
        }
        setGhostRect(0,0,1,1,false);
        renderer.domElement.style.cursor = "";

        // Í≤åÏûÑ Î≥µÏõê
        game.state = state.prevGameState || "play";
        playerSprite.visible = true;

        if(restart){
          // ÌòÑÏû¨ Î†àÎ≤® Îã§Ïãú ÎπåÎìúÌï¥ÏÑú Ï¶âÏãú ÌîåÎ†àÏù¥ ÌÖåÏä§Ìä∏ Í∞ÄÎä•
          startLevel(game.level, false, game.levelSeed);
        }

        toast2("DEV OFF", 700);
      }

      function toggleDev(){
        if(state.enabled) closeDev(true);
        else openDev();
      }

      // Ï∫îÎ≤ÑÏä§ ÏûÖÎ†•
      renderer.domElement.addEventListener("contextmenu", (e)=>{ if(state.enabled) e.preventDefault(); });

      renderer.domElement.addEventListener("pointerdown", (e)=>{
        if(!state.enabled) return;

        syncToggles();

        // Ïö∞ÌÅ¥Î¶≠: ÏÇ≠Ï†ú
        if(e.button === 2){
          const p = worldFromScreen(e.clientX, e.clientY);
          const wx = snapVal(p.x), wy = snapVal(p.y);
          const sel = pickAt(wx, wy);
          if(sel){
            removeSelection(sel);
            setSelection(null);
            rebuild(false);
            toast2("Deleted", 500);
          }else{
            toast2("Not Selected Object", 500);
          }
          e.preventDefault();
          return;
        }

        // ÎØ∏ÎãàÎßµ ÎìúÎûòÍ∑∏Îäî Î≥ÑÎèÑ
        if(e.target === $mini){
          return;
        }

        const p = worldFromScreen(e.clientX, e.clientY);
        const wx = snapVal(p.x), wy = snapVal(p.y);
        if(state.tool === "select"){
          const sel = pickAt(wx, wy);
          setSelection(sel);
          toast2(sel ? `Selected: ${sel.kind}` : "Not Selected", 650);
          e.preventDefault();
          return;
        }

        if(state.tool === "platform" || state.tool === "ladder"){
          state.drag = { x0: wx, y0: wy, x1: wx, y1: wy, kind: state.tool };
          setGhostRect(wx, wy, 0.001, 0.001, true);
          e.preventDefault();
          return;
        }

        if(state.tool === "delete"){
          const sel = pickAt(wx, wy);
          if(sel){
            removeSelection(sel);
            setSelection(null);
            rebuild(false);
            toast2("Delete", 500);
          }else{
            toast2("Not Selected Object", 500);
          }
          e.preventDefault();
          return;
        }

        // Ìè¨Ïù∏Ìä∏ Î∞∞Ïπò
        placePoint(state.tool, wx, wy);
        e.preventDefault();
      });

      renderer.domElement.addEventListener("pointermove", (e)=>{
        if(!state.enabled) return;
        if(!state.drag) return;
        const p = worldFromScreen(e.clientX, e.clientY);
        const wx = snapVal(p.x), wy = snapVal(p.y);
        state.drag.x1 = wx;
        state.drag.y1 = wy;

        const x = Math.min(state.drag.x0, state.drag.x1);
        const y = Math.min(state.drag.y0, state.drag.y1);
        const w = Math.max(0.001, Math.abs(state.drag.x1 - state.drag.x0));
        const h = Math.max(0.001, Math.abs(state.drag.y1 - state.drag.y0));
        setGhostRect(x, y, w, h, true);
      });

      renderer.domElement.addEventListener("pointerup", (e)=>{
        if(!state.enabled) return;
        if(!state.drag) return;

        const d = state.drag;
        state.drag = null;

        const x = Math.min(d.x0, d.x1);
        const y = Math.min(d.y0, d.y1);
        const w = Math.abs(d.x1 - d.x0);
        const h = Math.abs(d.y1 - d.y0);

        if(w < 0.15 || h < 0.15){
          setGhostRect(0,0,1,1,false);
          toast2("Too Small Cancel", 650);
          return;
        }

        if(d.kind === "platform"){
          state.map.platforms.push({ x, y, w, h });
          setSelection({ kind:"platform", i: state.map.platforms.length-1 });
          rebuild(false);
          toast2("Platform ADD", 650);
        }else if(d.kind === "ladder"){
          state.map.ladders.push({ x, y, w, h, topLow:y, topHigh:(y+h) });
          setSelection({ kind:"ladder", i: state.map.ladders.length-1 });
          rebuild(false);
          toast2("Ladder ADD", 650);
        }
      });

      function removeSelection(sel){
        const m = state.map;
        if(!m || !sel) return;
        if(sel.kind === "platform") m.platforms.splice(sel.i,1);
        else if(sel.kind === "ladder") m.ladders.splice(sel.i,1);
        else if(sel.kind === "coin") m.coins.splice(sel.i,1);
        else if(sel.kind === "enemy") m.enemies.splice(sel.i,1);
        else if(sel.kind === "spring") m.springs.splice(sel.i,1);
        else if(sel.kind === "spawn") { /* noop: spawnÏùÄ ÏÇ≠Ï†ú ÎåÄÏã† Ïù¥Îèô */ }
        else if(sel.kind === "goal") { /* noop */ }
      }

      function placePoint(kind, x, y){
        const m = state.map;
        if(!m) return;

        if(kind === "coin"){
          m.coins.push({ x, y });
          setSelection({ kind:"coin", i: m.coins.length-1 });
          rebuild(false);
          toast2("Coin Add", 600);
          return;
        }
        if(kind === "enemy"){
          m.enemies.push({ x, y });
          setSelection({ kind:"enemy", i: m.enemies.length-1 });
          rebuild(false);
          toast2("Slime Add", 600);
          return;
        }
        if(kind === "spring"){
          m.springs.push({ x, y });
          setSelection({ kind:"spring", i: m.springs.length-1 });
          rebuild(false);
          toast2("Spring Add", 600);
          return;
        }
        if(kind === "spawn"){
          m.spawn.x = x; m.spawn.y = y;
          setSelection({ kind:"spawn" });
          rebuild(false);
          toast2("Spawn Moved", 600);
          return;
        }
        if(kind === "goal"){
          m.goal.x = x; m.goal.y = y;
          setSelection({ kind:"goal" });
          rebuild(false);
          toast2("Goal Moved", 600);
          return;
        }

        // Í∏∞ÌÉÄ: ÏÑ†ÌÉù
        const sel = pickAt(x, y);
        if(sel){
          setSelection(sel);
          toast2(`sel: ${sel.kind}`, 600);
        }else{
          setSelection(null);
        }
      }

      // ÎØ∏ÎãàÎßµ ÎìúÎûòÍ∑∏Î°ú Ïπ¥Î©îÎùº Ïù¥Îèô
      $mini.addEventListener("pointerdown", (e)=>{
        if(!state.enabled) return;
        syncToggles();

        const pos = miniMapWorldFromEvent(e);
        if(pos && state.freeCam){
          state.camX = pos.worldX;
          state.camY = pos.worldY;
          camX = pos.worldX; camY = pos.worldY;
          camera.position.set(camX, camY, 10);
          drawMiniMap();
        }

        const rect = $mini.getBoundingClientRect();
        state.miniDrag = { x0: e.clientX - rect.left, y0: e.clientY - rect.top };
        $mini.setPointerCapture(e.pointerId);
      });
      function miniMapWorldFromEvent(e){
        const m = state.map;
        if(!m) return null;
        const rect = $mini.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * ($mini.width / rect.width);
        const my = (e.clientY - rect.top) * ($mini.height / rect.height);

        const b = computeBounds(m);
        const spanX = Math.max(1e-6, b.maxX - b.minX);
        const spanY = Math.max(1e-6, b.maxY - b.minY);
        const sx = $mini.width / spanX;
        const sy = $mini.height / spanY;
        const s = Math.min(sx, sy);
        const ox = ($mini.width - spanX*s) * 0.5;
        const oy = ($mini.height - spanY*s) * 0.5;

        const worldX = b.minX + (mx - ox) / s;
        const worldY = b.minY + (($mini.height - my) - oy) / s;
        return { worldX, worldY };
      }

      $mini.addEventListener("pointermove", (e)=>{
        if(!state.enabled || !state.miniDrag) return;
        const pos = miniMapWorldFromEvent(e);
        if(!pos) return;
        const { worldX, worldY } = pos;

        if(state.freeCam){
          state.camX = worldX;
          state.camY = worldY;
          camX = worldX; camY = worldY;
          camera.position.set(camX, camY, 10);
          drawMiniMap();
        }
      });
      $mini.addEventListener("pointerup", (e)=>{
        if(!state.enabled) return;
        state.miniDrag = null;
      });

      // Î≤ÑÌäº/ÌååÏùº Ïù¥Î≤§Ìä∏
      $toggle.addEventListener("click", ()=> toggleDev());
      $test.addEventListener("click", ()=>{
        // ÌòÑÏû¨ ÎßµÏùÑ Ìå©Ïóê Î∞òÏòÅ(Î©îÎ™®Î¶¨) ÌõÑ ÌîåÎ†àÏù¥
        commitCurrentMapToPack();
        closeDev(true);
      });

      $snap.addEventListener("change", ()=>{ syncToggles(); drawMiniMap(); });
      $grid.addEventListener("change", ()=>{ syncToggles(); rebuild(false); });
      $freeCam.addEventListener("change", ()=>{ syncToggles(); drawMiniMap(); });

      function commitCurrentMapToPack(){
        state.pack = ensurePack();
        state.pack.maps[state.mapIndex] = normalizeMap(state.map);
        activePack = normalizePack(state.pack);
      }

      $btnSave.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const ok = savePackToLocalStorage(activePack);
        toast2(ok ? "Saved (LocalStorage)" : "Save Failed", 1000);
        if(ok){
          $mapInfo.textContent = `maps:${activePack.maps.length}`;
        }
      });

      $btnNew.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const nm = normalizeMap({ name:"New Map" });
        activePack.maps.push(nm);
        state.pack = activePack;
        state.mapIndex = activePack.maps.length - 1;
        state.map = deepClone(activePack.maps[state.mapIndex]);
        setSelection(null);
        rebuild(true);
        toast2("New Map Created", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnDup.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        const cur = activePack.maps[state.mapIndex];
        const copy = normalizeMap(deepClone(cur));
        copy.id = `copy-${Date.now().toString(36)}`;
        copy.name = `${cur.name || "Map"} (copy)`;
        activePack.maps.splice(state.mapIndex+1, 0, copy);
        state.mapIndex++;
        state.map = deepClone(copy);
        setSelection(null);
        rebuild(true);
        toast2("Copy Done", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnDel.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        if(activePack.maps.length <= 1){
          toast2("At least 1 map is required.", 900);
          return;
        }
        activePack.maps.splice(state.mapIndex, 1);
        state.mapIndex = Math.max(0, state.mapIndex-1);
        state.map = deepClone(activePack.maps[state.mapIndex]);
        setSelection(null);
        rebuild(true);
        toast2("Deleted", 900);
        $mapInfo.textContent = `maps:${activePack.maps.length}`;
      });

      $btnExportMap.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        downloadJson(`${state.map.id || "map"}.json`, normalizeMap(state.map));
      });
      $btnExportPack.addEventListener("click", ()=>{
        commitCurrentMapToPack();
        downloadJson(`map_pack.json`, normalizePack(activePack));
      });

      $importFile.addEventListener("change", async ()=>{
        const f = $importFile.files && $importFile.files[0];
        $importFile.value = "";
        if(!f) return;
        try{
          const txt = await f.text();
          const obj = JSON.parse(txt);

          // pack or single map
          if(obj && typeof obj === "object" && Array.isArray(obj.maps)){
            activePack = normalizePack(obj);
            state.pack = activePack;
            state.mapIndex = 0;
            state.map = deepClone(activePack.maps[0] || normalizeMap({ name:"New Map" }));
            setSelection(null);
            rebuild(true);
            toast2("MapPack loaded!!", 1000);
            $mapInfo.textContent = `maps:${activePack.maps.length}`;
          }else{
            const m = normalizeMap(obj);
            commitCurrentMapToPack();
            activePack.maps.push(m);
            state.mapIndex = activePack.maps.length-1;
            state.map = deepClone(m);
            setSelection(null);
            rebuild(true);
            toast2("Map Added", 1000);
            $mapInfo.textContent = `maps:${activePack.maps.length}`;
          }
        }catch(_e){
          toast2("JSON Parsing Failed", 1000);
        }
      });

      function renderMapList(){
        $mapList.innerHTML = "";
        for(let i=0;i<state.pack.maps.length;i++){
          const m = state.pack.maps[i];
          const el = document.createElement("div");
          el.className = "item" + (i===state.mapIndex ? " on" : "");
          el.innerHTML = `<span>${i+1}. ${m.name || m.id}</span><span class="tag">${m.coins.length}c</span>`;
          el.addEventListener("click", ()=>{
            commitCurrentMapToPack();
            state.mapIndex = i;
            state.map = deepClone(state.pack.maps[i]);
            setSelection(null);
            rebuild(true);
            toast2(`Map Select: ${state.map.name || state.map.id}`, 700);
          });
          $mapList.appendChild(el);
        }
      }

      function stepDev(dt){
        // Ïπ¥Î©îÎùº Í≥†Ï†ï Î™®ÎìúÏùº ÎïåÎßå state.camX/Y ÏÇ¨Ïö©
        if(state.enabled && state.freeCam){
          camera.position.set(state.camX, state.camY, 10);
          camX = state.camX; camY = state.camY;
        }
        // ghostÎäî pointer Ïù¥Î≤§Ìä∏Î°ú Í∞±Ïã†Îê®
        drawMiniMap();
      }

      // Ïô∏Î∂ÄÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•Ìïú Ìï∏Îì§
      window.__DEV_EDITOR = {
        get enabled(){ return state.enabled; },
        step: stepDev,
        toggle: toggleDev
      };

      // ÌÇ§ Î∞îÏù∏Îî©
      document.addEventListener("keydown", (e)=>{
        if(e.code === "F2"){
          e.preventDefault();
          toggleDev();
        }
      });

      // Ï¥àÍ∏∞ ÏïàÎÇ¥(Ìïú Î≤àÎßå)
      toast2("F2: DEV Map Editor", 1400);
    })();


    // ÏãúÏûë
    // - Î¶¨ÏÜåÏä§ Î°úÎî© ÏôÑÎ£å ÌõÑ: showReadyToStart()ÏóêÏÑú Start Î≤ÑÌäº ÌôúÏÑ±Ìôî
    // - Í≤åÏûÑ ÏãúÏûë: Start Î≤ÑÌäº ÌÅ¥Î¶≠ ‚Üí startFromTitle()
    syncPolicyUI(); // Ï¥àÍ∏∞ UI Î∞òÏòÅ(Í≤åÏûÑ ÏãúÏûëÏùÄ Î≤ÑÌäº ÌÅ¥Î¶≠ ÌõÑ)
  </script>

  <!-- DEV MAP EDITOR UI -->
  <div id="devToast2"></div>
  <div id="devPanel" aria-hidden="true">
    <h3>DEV Map Editor <span class="tag" id="devMapInfo">F2</span></h3>

    <div class="row2">
      <button class="btn primary" id="devToggle">DEV Close(F2)</button>
      <button class="btn" id="devTest">Map Test</button>
      <span class="tag" id="devStatus">OFF</span>
    </div>

    <div class="tabPage on" data-tab="edit">
      <canvas id="devMiniMap" width="640" height="320"></canvas>
    </div>

    <div id="devTabs">
      <button class="tab on" data-tab-target="edit">EDIT</button>
      <button class="tab" data-tab-target="map">MAP</button>
      <button class="tab" data-tab-target="save">SAVE</button>
    </div>

    <div class="tabPage on" data-tab="edit">
      <div class="row2">
        <label class="tag">Snap</label>
        <input type="checkbox" id="devSnap" checked />
        <label class="tag">Grid</label>
        <input type="number" id="devGrid" value="0.5" step="0.1" min="0.1" style="width:86px;border-radius:10px;border:1px solid rgba(0,0,0,.12);padding:6px 8px;font-size:12px;" />
        <label class="tag">Fix Camera</label>
        <input type="checkbox" id="devFreeCam" checked />
      </div>

      <div id="devTools"></div>

      <div class="row2">
        <span class="tag">Sel Attr</span>
      </div>
      <div id="devProps">
        <div class="tag">Not Selected Object</div>
      </div>

      <div class="row2">
        <span class="tag">TIP</span>
        <span class="tag">Platform/Ladder: LeftClick Drag</span>
        <span class="tag">Coin/Slime/Spring/Spawn/Goal: LeftClick</span>
        <span class="tag">Del: RightClick</span>
      </div>
    </div>

    <div class="tabPage" data-tab="map">
      <div class="row2">
        <span class="tag">Map List</span>
      </div>
      <div id="devMapList"></div>

      <div class="row2">
        <button class="btn" id="devNew">New Map</button>
        <button class="btn" id="devDup">Duplicate</button>
        <button class="btn danger" id="devDel">Delete</button>
      </div>
    </div>

    <div class="tabPage" data-tab="save">
      <div class="row2">
        <button class="btn" id="devSave">Save(Browser-Storage)</button>
      </div>

      <div class="row2">
        <button class="btn" id="devExportMap">JSON Download(Map)</button>
        <button class="btn" id="devExportPack">JSON Download(Pack)</button>
        <label class="btn" for="devImportFile" style="cursor:pointer;">JSON Open</label>
        <input id="devImportFile" type="file" accept="application/json" style="display:none;" />
      </div>
    </div>
  </div>

</body>
</html>
