<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üïπÔ∏è RETRO SHOOTER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: #0f0;
            touch-action: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: 
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 255, 0, 0.03) 0px,
                    rgba(0, 255, 0, 0.03) 1px,
                    transparent 1px,
                    transparent 2px
                );
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-shadow: inset 0 0 100px rgba(0, 255, 0, 0.1);
        }

        .ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 2px,
                transparent 2px,
                transparent 4px
            );
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 0.99; }
            100% { opacity: 0.98; }
        }

        .hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #0f0;
            text-shadow: 
                0 0 5px #0f0,
                0 0 10px #0f0,
                2px 2px 0 #000;
            animation: textGlow 2s infinite;
        }

        @keyframes textGlow {
            0%, 100% { text-shadow: 0 0 5px #0f0, 0 0 10px #0f0, 2px 2px 0 #000; }
            50% { text-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 2px 2px 0 #000; }
        }

        .stats {
            background: rgba(0, 20, 0, 0.9);
            padding: 10px;
            border: 3px solid #0f0;
            box-shadow: 
                0 0 10px #0f0,
                inset 0 0 10px rgba(0, 255, 0, 0.2);
            line-height: 1.8;
        }

        .health-bar-container {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 350px;
        }

        .health-label {
            font-size: 8px;
            color: #0f0;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #0f0, 2px 2px 0 #000;
        }

        .health-bar {
            height: 20px;
            background: #001100;
            border: 3px solid #0f0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px #0f0, inset 0 0 10px #000;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff6600, #ffff00);
            transition: width 0.2s;
            box-shadow: 0 0 10px #ff0066;
            position: relative;
        }

        .health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 10px,
                rgba(255, 255, 255, 0.3) 10px,
                rgba(255, 255, 255, 0.3) 11px
            );
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        #menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at center, rgba(0, 20, 0, 0.95), rgba(0, 0, 0, 0.98)),
                repeating-linear-gradient(0deg, rgba(0, 255, 0, 0.05) 0px, rgba(0, 255, 0, 0.05) 2px, transparent 2px, transparent 4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: all;
            border: 10px solid #0f0;
            box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.2);
        }

        #menu.hidden {
            display: none;
        }

        h1 {
            font-size: 32px;
            color: #0f0;
            text-shadow: 
                0 0 10px #0f0,
                0 0 20px #0f0,
                0 0 30px #0f0,
                4px 4px 0 #000;
            margin-bottom: 10px;
            animation: titleBlink 0.8s infinite, titleFloat 3s ease-in-out infinite;
            letter-spacing: 3px;
        }

        @keyframes titleBlink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.7; }
        }

        @keyframes titleFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .arcade-text {
            font-size: 10px;
            color: #0f0;
            margin: 5px 0;
            text-shadow: 0 0 5px #0f0, 2px 2px 0 #000;
        }

        .insert-coin {
            font-size: 12px;
            color: #ff0;
            margin: 30px 0 20px 0;
            text-shadow: 0 0 10px #ff0, 2px 2px 0 #000;
            animation: blinkSlow 1s infinite;
        }

        @keyframes blinkSlow {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            padding: 15px 30px;
            margin: 10px;
            background: #0f0;
            color: #000;
            border: 3px solid #000;
            cursor: pointer;
            text-transform: uppercase;
            pointer-events: all;
            box-shadow: 
                0 0 10px #0f0,
                inset 0 0 10px rgba(0, 0, 0, 0.3);
            transition: all 0.1s;
        }

        .btn:hover {
            background: #ff0;
            box-shadow: 0 0 20px #ff0;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #warning {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background 0.1s;
            border: 0px solid #f00;
        }

        #warning.show {
            background: rgba(255, 0, 0, 0.3);
            border: 10px solid #f00;
            box-shadow: inset 0 0 50px #f00;
        }

        #combo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0;
            text-shadow: 
                0 0 20px #ff0,
                0 0 40px #ff0,
                4px 4px 0 #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
        }

        #combo.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            width: 90%;
            max-width: 400px;
            justify-content: center;
            align-items: center;
        }

        .joystick-container {
            position: relative;
            width: 120px;
            height: 120px;
            background: rgba(0, 20, 0, 0.8);
            border: 3px solid #0f0;
            border-radius: 50%;
            box-shadow: 
                0 0 10px #0f0,
                inset 0 0 20px rgba(0, 255, 0, 0.2);
            touch-action: none;
            pointer-events: all;
        }

        .joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: #0f0;
            border: 3px solid #000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #0f0;
            transition: all 0.1s;
        }

        .fire-btn {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #f00, #a00);
            border: 5px solid #ff0;
            border-radius: 50%;
            font-size: 14px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 
                0 0 20px #f00,
                inset 0 0 20px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            pointer-events: all;
            transition: all 0.1s;
            touch-action: none;
        }

        .fire-btn:active {
            transform: scale(0.9);
            box-shadow: 
                0 0 30px #f00,
                inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        @media (max-width: 768px) {
            h1 { font-size: 20px; }
            .arcade-text { font-size: 8px; }
            .btn { font-size: 10px; padding: 10px 20px; }
            .hud { font-size: 8px; }
        }

        .score-popup {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00, 2px 2px 0 #000;
            pointer-events: none;
            animation: scoreFloat 1s ease-out forwards, scoreBlink 0.15s infinite;
            z-index: 50;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5);
            }
        }

        @keyframes scoreBlink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.5; }
        }

        .boss-warning {
            position: fixed !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            color: #ff0000 !important;
            font-size: 60px !important;
            font-weight: bold !important;
            text-align: center !important;
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000, 4px 4px 0 #000 !important;
            z-index: 9999 !important;
            pointer-events: none !important;
            animation: bossWarning 3s ease-out forwards !important;
            white-space: nowrap !important;
        }

        @keyframes bossWarning {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            10% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            20% {
                transform: translate(-50%, -50%) scale(1);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }

        .item {
            position: absolute;
            font-size: 30px;
            pointer-events: none;
            animation: itemFloat 2s ease-in-out infinite, itemGlow 1s infinite;
            z-index: 45;
        }

        @keyframes itemFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }

        @keyframes itemGlow {
            0%, 100% { filter: drop-shadow(0 0 5px #0ff) drop-shadow(0 0 10px #0ff); }
            50% { filter: drop-shadow(0 0 15px #0ff) drop-shadow(0 0 25px #0ff); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui">
            <div class="scanlines"></div>
            
            <div class="hud">
                <div class="stats">
                    <div>SCORE: <span id="score">0000000</span></div>
                    <div>LEVEL: <span id="level">1</span></div>
                    <div>COMBO: x<span id="combo-text">00</span></div>
                    <div>FPS: <span id="fps">60</span></div>
                </div>
                <div class="stats">
                    <div>ENEMIES: <span id="enemies">00</span></div>
                    <div>POWER: <span id="power">1.0</span>x</div>
                    <div>RATE: <span id="rate">0.10</span>s</div>
                </div>
            </div>

            <div class="health-bar-container">
                <div class="health-label">‚ó§ SHIELD ENERGY ‚ó•</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill" style="width: 100%;"></div>
                    <div class="health-text" id="healthText">100</div>
                </div>
            </div>

            <div id="warning"></div>
            <div id="combo"></div>
        </div>

        <div id="menu">
            <h1>‚ó¢ RETRO SHOOTER ‚ó£</h1>
            <div class="arcade-text">‚ñº DESTROY ALL ENEMIES ‚ñº</div>
            <div class="arcade-text">‚ñà SURVIVAL MODE ‚ñà</div>
            <div class="insert-coin">‚ô¶ INSERT COIN ‚ô¶</div>
            <button class="btn" id="startBtn">‚ñ∂ START GAME ‚óÄ</button>
            <div class="arcade-text" style="margin-top: 30px;">CONTROLS:</div>
            <div class="arcade-text">WASD / ARROWS = MOVE</div>
            <div class="arcade-text">AUTO FIRE ENABLED</div>
        </div>

        <div class="controls">
            <div class="joystick-container" id="joystickContainer">
                <div class="joystick" id="joystick"></div>
            </div>
            <button class="fire-btn" id="fireBtn">FIRE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl', {
            antialias: false,
            depth: false,
            preserveDrawingBuffer: false,
            powerPreference: "high-performance"
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

                const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec3 a_color;
            attribute float a_size;
            attribute float a_kind;   // 0 = circle(default), 1 = pacman
            uniform vec2 u_resolution;
            uniform float u_time;
            varying vec3 v_color;
            varying float v_kind;
            void main() {
                vec2 pos = (a_position / u_resolution) * 2.0 - 1.0;
                gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);
                gl_PointSize = a_size;
                v_color = a_color;
                v_kind = a_kind;
            }
        `;
        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 v_color;
            varying float v_kind;
            uniform float u_time;
            uniform sampler2D u_enemyTexture;
            
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                // v_kind == 2.0: Ï†Å ÌÖçÏä§Ï≤ò Î†åÎçîÎßÅ
                if (v_kind > 1.5) {
                    vec4 texColor = texture2D(u_enemyTexture, gl_PointCoord);
                    if (texColor.a < 0.1) discard;
                    gl_FragColor = texColor;
                }
                // v_kind == 1.0: Ìå©Îß® (ÏÇ¨Ïö© Ïïà Ìï®)
                else if (v_kind > 0.5 && v_kind < 1.5) {
                    if (dist > 0.5) discard;
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    float mouth = 0.35 + 0.07 * abs(sin(u_time * 4.0));
                    float ang = atan(coord.y, coord.x);
                    if (coord.x > 0.0 && abs(ang) < mouth) discard;
                    gl_FragColor = vec4(v_color, alpha);
                }
                // v_kind == 0.0: ÏùºÎ∞ò ÏõêÌòï Ïä§ÌîÑÎùºÏù¥Ìä∏
                else {
                    if (dist > 0.5) discard;
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    gl_FragColor = vec4(v_color, alpha);
                }
            }
        `;
function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        const colorLoc = gl.getAttribLocation(program, 'a_color');
        const sizeLoc = gl.getAttribLocation(program, 'a_size');
        const kindLoc = gl.getAttribLocation(program, 'a_kind');
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const enemyTextureLoc = gl.getUniformLocation(program, 'u_enemyTexture');

        // Ï†Å ÌÖçÏä§Ï≤ò Î°úÎìú
    
		const enemyTexture = gl.createTexture();
		const enemyImage = new Image();
		enemyImage.crossOrigin = 'anonymous';  // Ïô∏Î∂Ä ÎèÑÎ©îÏù∏(CORS) ÌÖçÏä§Ï≤ò ÌóàÏö©
		enemyImage.onload = function () {
		  gl.bindTexture(gl.TEXTURE_2D, enemyTexture);
		  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, enemyImage);
		  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		};
		enemyImage.src = 'https://neoprizm.github.io/neo_Minesweeper/enermy.png';  // Î≥ÄÍ≤ΩÎêú Í≤ΩÎ°ú

		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		// ÌÖçÏä§Ï≤ò ÌôúÏÑ±Ìôî
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, enemyTexture);
		gl.uniform1i(enemyTextureLoc, 0);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        // ÌÖçÏä§Ï≤ò ÌôúÏÑ±Ìôî
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, enemyTexture);
        gl.uniform1i(enemyTextureLoc, 0);

        const MAX_ENTITIES = 10000;
        const positions = new Float32Array(MAX_ENTITIES * 2);
        const colors = new Float32Array(MAX_ENTITIES * 3);
        const sizes = new Float32Array(MAX_ENTITIES);
        const kinds = new Float32Array(MAX_ENTITIES);

        const positionBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();
        const sizeBuffer = gl.createBuffer();
        const kindBuffer = gl.createBuffer();

        let wasmModule = null;

        async function initWasm() {
            const wasmCode = new Uint8Array([
                0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
                0x01, 0x07, 0x01, 0x60, 0x02, 0x7d, 0x7d, 0x01, 0x7d,
                0x03, 0x02, 0x01, 0x00,
                0x07, 0x09, 0x01, 0x05, 0x61, 0x64, 0x64, 0x58, 0x59, 0x00, 0x00,
                0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x92, 0x0b
            ]);
            const wasmModule = await WebAssembly.instantiate(wasmCode);
            return wasmModule.instance.exports;
        }

        const gameState = {
            running: false,
            score: 0,
            combo: 0,
            comboTimer: 0,
            level: 1,  // Î†àÎ≤® Ï∂îÍ∞Ä
            nextLevelScore: 1000,  // Ï≤´ Î†àÎ≤®ÏùÄ 1000Ï†ê
            levelMultiplier: 3,  // Î†àÎ≤®Îãπ 3Î∞∞ Ï¶ùÍ∞Ä
            player: {
                x: 0, y: 0,
                vx: 0, vy: 0,
                size: 24,  // Í∏∞Ï°¥ 12ÏóêÏÑú 2Î∞∞ Ï¶ùÍ∞Ä
                speed: 6,
                health: 100,
                maxHealth: 100,
                bulletSizeMultiplier: 1.0,  // Ï¥ùÏïå ÌÅ¨Í∏∞ Î∞∞Ïú®
                maxBulletSize: 72  // ÏµúÎåÄ Ï¥ùÏïå ÌÅ¨Í∏∞ (Ïö∞Ï£ºÏÑ† Î≥∏Ï≤¥Ïùò 3Î∞∞)
            },
            bullets: [],
            enemies: [],
            enemyChunks: [],
            particles: [],
            items: [],  // ÏïÑÏù¥ÌÖú Î∞∞Ïó¥ Ï∂îÍ∞Ä
            stars: [],  // Î∞∞Í≤Ω Î≥Ñ Î∞∞Ïó¥
            boss: null,  // Î≥¥Ïä§
            bossBullets: [],  // Î≥¥Ïä§ Ï¥ùÏïå
            bossTimer: 0,  // Î≥¥Ïä§ ÌÉÄÏù¥Î®∏
            bossInterval: 60,  // 1Î∂Ñ (60Ï¥à)
            isBossBattle: false,  // Î≥¥Ïä§ Ï†ÑÌà¨ Ï§ëÏù∏ÏßÄ
            bossAppearCount: 0,  // Î≥¥Ïä§ Îì±Ïû• ÌöüÏàò
            shootTimer: 0,
            shootInterval: 0.1,
            enemySpawnTimer: 0,
            enemySpawnInterval: 1.0,
            gameTime: 0,  // Í≤åÏûÑ ÏãúÍ∞Ñ Ï∂îÏ†Å
            lastSpeedIncrease: 0,  // ÎßàÏßÄÎßâ ÏÜçÎèÑ Ï¶ùÍ∞Ä ÏãúÍ∞Ñ
            baseEnemySpeed: 1.0,  // Í∏∞Î≥∏ Ï†Å ÏÜçÎèÑ
            killCount: 0,  // ÌÇ¨ Ïπ¥Ïö¥Ìä∏ Ï∂îÍ∞Ä
            mouseX: 0,  // ÎßàÏö∞Ïä§ X ÏúÑÏπò
            mouseY: 0   // ÎßàÏö∞Ïä§ Y ÏúÑÏπò
        };

        let audioContext = null;
        let bgmGain = null;
        let bgmSource = null;  // bgmSource Î≥ÄÏàò Ï∂îÍ∞Ä
        let bgmPlaying = false;
        let bgmLoopTimeout = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                bgmGain = audioContext.createGain();
                bgmGain.gain.value = 0.45;
                bgmGain.connect(audioContext.destination);
            }
            return audioContext;
        }

        // Î†àÌä∏Î°ú Î©úÎ°úÎîîÎ•º 3Î∞∞ Îçî Í∏∏Í≤å ÌôïÏû•
        const melody = [
            // Ï≤´ Î≤àÏß∏ ÌååÌä∏
            { note: 523.25, duration: 0.15 }, // C5
            { note: 587.33, duration: 0.15 }, // D5
            { note: 659.25, duration: 0.15 }, // E5
            { note: 698.46, duration: 0.15 }, // F5
            { note: 783.99, duration: 0.3 },  // G5
            { note: 659.25, duration: 0.15 }, // E5
            { note: 698.46, duration: 0.15 }, // F5
            { note: 783.99, duration: 0.3 },  // G5
            { note: 880.00, duration: 0.15 }, // A5
            { note: 783.99, duration: 0.15 }, // G5
            { note: 659.25, duration: 0.15 }, // E5
            { note: 523.25, duration: 0.3 },  // C5
            
            // Îëê Î≤àÏß∏ ÌååÌä∏ (Î≥ÄÌòï)
            { note: 587.33, duration: 0.15 }, // D5
            { note: 659.25, duration: 0.15 }, // E5
            { note: 698.46, duration: 0.15 }, // F5
            { note: 783.99, duration: 0.15 }, // G5
            { note: 880.00, duration: 0.3 },  // A5
            { note: 783.99, duration: 0.15 }, // G5
            { note: 880.00, duration: 0.15 }, // A5
            { note: 987.77, duration: 0.3 },  // B5
            { note: 1046.50, duration: 0.15 }, // C6
            { note: 987.77, duration: 0.15 }, // B5
            { note: 880.00, duration: 0.15 }, // A5
            { note: 698.46, duration: 0.3 },  // F5
            
            // ÏÑ∏ Î≤àÏß∏ ÌååÌä∏ (Îçî ÎÜíÏùÄ Ïò•ÌÉÄÎ∏å)
            { note: 783.99, duration: 0.15 }, // G5
            { note: 880.00, duration: 0.15 }, // A5
            { note: 987.77, duration: 0.15 }, // B5
            { note: 1046.50, duration: 0.15 }, // C6
            { note: 1174.66, duration: 0.3 },  // D6
            { note: 1046.50, duration: 0.15 }, // C6
            { note: 987.77, duration: 0.15 }, // B5
            { note: 880.00, duration: 0.3 },  // A5
            { note: 783.99, duration: 0.15 }, // G5
            { note: 659.25, duration: 0.15 }, // E5
            { note: 523.25, duration: 0.15 }, // C5
            { note: 523.25, duration: 0.3 },  // C5
        ];

        function playBGM() {
            if (!bgmPlaying) return;
            
            const ctx = initAudio();
            let currentTime = ctx.currentTime;
            
            melody.forEach((note, i) => {
                const osc = ctx.createOscillator();
                const noteGain = ctx.createGain();
                
                osc.connect(noteGain);
                noteGain.connect(bgmGain);
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(note.note, currentTime);
                
                noteGain.gain.setValueAtTime(0, currentTime);
                noteGain.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
                noteGain.gain.exponentialRampToValueAtTime(0.01, currentTime + note.duration);
                
                osc.start(currentTime);
                osc.stop(currentTime + note.duration);
                
                currentTime += note.duration;
            });
            
            const totalDuration = melody.reduce((sum, note) => sum + note.duration, 0);
            bgmLoopTimeout = setTimeout(() => playBGM(), totalDuration * 1000);
        }

        function startBGM() {
            bgmPlaying = true;
            playBGM();
        }

        function playSound(type) {
            try {
                const ctx = initAudio();
                
                switch(type) {
                    case 'shoot':
                        const shoot = ctx.createOscillator();
                        const shootGain = ctx.createGain();
                        shoot.connect(shootGain);
                        shootGain.connect(ctx.destination);
                        shoot.type = 'sawtooth';
                        shoot.frequency.setValueAtTime(800, ctx.currentTime);
                        shoot.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.05);
                        shootGain.gain.setValueAtTime(0.08, ctx.currentTime);
                        shootGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
                        shoot.start(ctx.currentTime);
                        shoot.stop(ctx.currentTime + 0.05);
                        break;
                        
                    case 'explosion':
                        const explosion = ctx.createOscillator();
                        const explosionGain = ctx.createGain();
                        explosion.connect(explosionGain);
                        explosionGain.connect(ctx.destination);
                        explosion.type = 'sawtooth';
                        explosion.frequency.setValueAtTime(200, ctx.currentTime);
                        explosion.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.2);
                        explosionGain.gain.setValueAtTime(0.2, ctx.currentTime);
                        explosionGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                        explosion.start(ctx.currentTime);
                        explosion.stop(ctx.currentTime + 0.2);
                        break;
                        
                    case 'damage':
                        const damage = ctx.createOscillator();
                        const damageGain = ctx.createGain();
                        damage.connect(damageGain);
                        damageGain.connect(ctx.destination);
                        damage.type = 'triangle';
                        damage.frequency.setValueAtTime(300, ctx.currentTime);
                        damage.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                        damageGain.gain.setValueAtTime(0.15, ctx.currentTime);
                        damageGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                        damage.start(ctx.currentTime);
                        damage.stop(ctx.currentTime + 0.1);
                        break;
                }
            } catch(e) {
                console.log('Sound error:', e);
            }
        }

        
        // Î©îÏù∏ BGM: 'Ïä§ÌéòÏù¥Ïä§ Ïò§ÎîßÏÑ∏Ïù¥'Î°ú ÏïåÎ†§ÏßÑ ÏûêÎùºÌà¨Ïä§Ìä∏Îùº ÌÖåÎßàÏùò MIDI ÎäêÎÇå Î™®Ìã∞ÌîÑ
        function startBGM() {
            const ctx = initAudio();
            if (!ctx || bgmSource) return;

            // C-G-C ÏÇºÌôîÏùåÏù¥ Ïò•ÌÉÄÎ∏åÎ•º Ïò§Î•¥ÎÇ¥Î¶¨Î©∞ Ï†êÏßÑÏ†ÅÏúºÎ°ú Ïª§ÏßÄÎäî Îã®Ïàú Î™®Ìã∞ÌîÑ
            const seq2 = [
                {f: 65.41, d: 1.8}, {f: 98.00, d: 1.8}, {f: 130.81, d: 1.8}, // C2-G2-C3
                {f: 0.0,   d: 0.6}, // Ìú¥ÏßÄ
                {f: 65.41, d: 1.2}, {f: 98.00, d: 1.2}, {f: 130.81, d: 1.2}, // Î∞òÎ≥µ
                {f: 0.0,   d: 0.6},
                {f: 130.81, d: 1.0}, {f: 196.00, d: 1.0}, {f: 261.63, d: 2.0} // C3-G3-C4
            ];
			


          /*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  IKARUGA STAGE-3  ‚ÄúAzure & Green‚Äù ‚óè 8-Channel ¬∑ 32‚Äâs Loop
  ‚ñ∏ solemn pad + heroic brass + ticking arpeggio
  ‚ñ∏ lightweight oscillator mix (‚âà2 MB RAM @ 48 kHz)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/

/* 1. 8-Ï±ÑÎÑê ÎØπÏä§ (Ìè≠ÎÑìÏùÄ Ïä§ÌÖåÎ†àÏò§¬∑ÏùåÏÉâ) */
const channelCfg = [
  { shift:   0,  vol: 0.16, wave: 'square'   }, // Lead brass
  { shift:  +7,  vol: 0.11, wave: 'square'   }, // Perfect-5th layer
  { shift: -12,  vol: 0.14, wave: 'triangle' }, // Warm bass
  { shift: +12,  vol: 0.12, wave: 'saw'      }, // Upper pad
  { shift: -24,  vol: 0.08, wave: 'saw'      }, // Sub-bass
  { shift:  +0,  vol: 0.06, wave: 'sine'     }, // Choir pad
  { shift: +19,  vol: 0.05, wave: 'sine'     }, // Sparkle
  { shift:  +5,  vol: 0.05, wave: 'triangle' }  // 3rd-harmony
];

/* 2. ÏΩîÎìú & Î©úÎ°úÎîî ÏãúÌÄÄÏä§ (Em‚ÄìC‚ÄìG‚ÄìD minor-color) */
const Q       = 0.40;                          // quarter ‚âà 75 BPM feel
const arpeDur = 0.10;                          // 16th tick
const rootHz  = { E:164.81, C:130.81, G:196.00, D:146.83 };

const chordSeq = ['E','C','G','D'];            // 4 bars
const arpeggio = r => [r*2, r*2.5, r*3, r*2.5];// simple 4-note rise

let seq = [];
for (let bar = 0; bar < 4; bar++) {            // 4√ó ‚Üí 16 bars ‚âà 32 s
  chordSeq.forEach(ch => {
    // pad stab (whole beat)
    seq.push({ f: rootHz[ch]*2, d: Q });
    // arpeggio ticks within this beat
    arpeggio(rootHz[ch]).forEach(f => seq.push({ f, d: arpeDur }));
    seq.push({ f: 0, d: Q - (arpeDur*4) });    // fill remaining time
  });
}
const totalDuration = seq.reduce((s,n)=>s+n.d,0); // ‚âà 31.8 s

/* 3. OSC Ìï®Ïàò */
function osc(type,Œ∏){
  switch(type){
    case 'square':   return Math.sign(Math.sin(Œ∏));
    case 'triangle': return 2/Math.PI*Math.asin(Math.sin(Œ∏));
    case 'saw':      return 2*(Œ∏/(2*Math.PI)-Math.floor(Œ∏/(2*Math.PI)+.5));
    default:         return Math.sin(Œ∏);
  }
}

/* 4. Î≤ÑÌçº Ìï©ÏÑ± & Î£®ÌîÑ Ïû¨ÏÉù */
const playBGMLoop = ()=>{
  if(!gameState.running||gameState.isBossBattle) return;

  try{
    bgmSource = ctx.createBufferSource();
    const chN   = channelCfg.length;
    const sampN = Math.ceil(ctx.sampleRate*totalDuration);
    const buf   = ctx.createBuffer(chN,sampN,ctx.sampleRate);

    let cur=0;
    for(const {f,d} of seq){
      const st=Math.floor(cur*ctx.sampleRate);
      const en=Math.floor((cur+d)*ctx.sampleRate);

      for(let s=st;s<en;s++){
        const t=(s-st)/ctx.sampleRate;
        const a=Math.min(1,(t/d)*1.4);
        const env=Math.pow(a,1.25)*(1-0.15*t/d);

        channelCfg.forEach((ch,i)=>{
          const data=buf.getChannelData(i);
          if(f){
            const hz=f*Math.pow(2,ch.shift/12);
            data[s]+=osc(ch.wave,2*Math.PI*hz*t)*ch.vol*env;
          }
        });
      }
      cur+=d;
    }

    bgmSource.buffer=buf;
    bgmSource.loop=true;           // seamless 32 s loop
    bgmSource.connect(bgmGain);
    bgmSource.start();
  }catch(e){console.log('BGM error:',e);}
};

playBGMLoop();
        }

        // Î≥¥Ïä§ BGM - ÏúÑÌòëÏ†ÅÏù¥Í≥† Í∏¥Ïû•Í∞ê ÏûàÎäî ÏùåÏïÖ
        function startBossBGM() {
            try {
                const ctx = initAudio();
                if (!ctx) {
                    console.log('Audio context not available');
                    return;
                }
                
                // Í∏∞Ï°¥ BGM Ï†ïÎ¶¨
                if (bgmSource) {
                    try {
                        bgmSource.stop();
                        bgmSource.disconnect();
                    } catch(e) {}
                    bgmSource = null;
                }
                
                // ÎÇÆÍ≥† ÏúÑÌòëÏ†ÅÏù∏ ÏùåÍ≥Ñ Ìå®ÌÑ¥
                const notes = [
                    // Î∂àÍ∏∏Ìïú Î∞òÎ≥µ Ìå®ÌÑ¥ (ÎÇÆÏùÄ Ïò•ÌÉÄÎ∏å)
                    110, 110, 117, 110, 110, 117, 110, 110,
                    104, 104, 110, 104, 104, 110, 104, 104,
                    98, 98, 104, 98, 98, 104, 98, 98,
                    110, 117, 123, 117, 110, 104, 98, 104,
                    
                    // ÏÉÅÏäπÌïòÎäî Í∏¥Ïû•Í∞ê
                    110, 123, 139, 147, 156, 165, 175, 185,
                    185, 175, 165, 156, 147, 139, 123, 110,
                    
                    // Î∞òÎ≥µ - Îçî Îπ†Î•¥Í≤å
                    110, 117, 110, 117, 123, 139, 123, 117,
                    110, 104, 98, 104, 110, 117, 123, 139,
                    
                    // ÌÅ¥ÎùºÏù¥Îß•Ïä§
                    147, 139, 123, 110, 147, 139, 123, 110,
                    165, 156, 147, 139, 165, 156, 147, 139,
                    185, 175, 165, 156, 185, 175, 165, 156,
                    220, 208, 196, 185, 175, 165, 156, 147
                ];
                
                const noteDuration = 0.2;  // ÎäêÎ¶¨Í≥† Î¨¥Í±∞Ïö¥ ÌÖúÌè¨
                const totalDuration = notes.length * noteDuration;
                
                const playBossBGMLoop = () => {
                    if (!gameState.running || !gameState.isBossBattle) return;
                    
                    try {
                        bgmSource = ctx.createBufferSource();
                        const buffer = ctx.createBuffer(1, ctx.sampleRate * totalDuration, ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        
                        notes.forEach((freq, i) => {
                            const startSample = Math.floor(i * noteDuration * ctx.sampleRate);
                            const endSample = Math.floor((i + 1) * noteDuration * ctx.sampleRate);
                            
                            for (let j = startSample; j < endSample; j++) {
                                const t = (j - startSample) / ctx.sampleRate;
                                const envelope = Math.max(0, 1 - t / noteDuration);
                                
                                // Ïñ¥ÎëêÏö¥ ÌÜ§ (ÏÇ¨Í∞ÅÌåå + ÏÇºÍ∞ÅÌåå)
                                const darkTone = Math.sign(Math.sin(2 * Math.PI * freq * t)) * 0.5;
                                const subBass = Math.sin(2 * Math.PI * freq * 0.5 * t) * 0.4;
                                const rumble = Math.sin(2 * Math.PI * freq * 1.5 * t) * 0.2;
                                
                                data[j] = (darkTone + subBass + rumble) * envelope * 0.15;
                            }
                        });
                        
                        bgmSource.buffer = buffer;
                        bgmSource.connect(bgmGain);
                        bgmSource.loop = false;
                        bgmSource.onended = () => {
                            bgmSource = null;
                            if (gameState.isBossBattle) {
                                playBossBGMLoop();
                            }
                        };
                        bgmSource.start();
                    } catch(e) {
                        console.log('Boss BGM loop error:', e);
                        bgmSource = null;
                    }
                };
                
                playBossBGMLoop();
            } catch(e) {
                console.log('Boss BGM init error:', e);
            }
        }

        function stopBGM() {
            if (bgmSource) {
                try {
                    bgmSource.stop();
                    bgmSource.disconnect();
                } catch(e) {
                    console.log('BGM stop error:', e);
                }
                bgmSource = null;
            }
        }

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // ÎßàÏö∞Ïä§ ÏúÑÏπò Ï∂îÏ†Å
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
        });

        // ÌÑ∞Ïπò ÏúÑÏπòÎèÑ ÎßàÏö∞Ïä§ ÏúÑÏπòÎ°ú ÏÇ¨Ïö©
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                gameState.mouseX = e.touches[0].clientX - rect.left;
                gameState.mouseY = e.touches[0].clientY - rect.top;
            }
        });

        let joystickActive = false;
        let joystickDelta = { x: 0, y: 0 };

        const joystickContainer = document.getElementById('joystickContainer');
        const joystick = document.getElementById('joystick');

        function handleJoystick(e) {
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = touch.clientX - centerX;
            const deltaY = touch.clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 35;
            
            if (distance > maxDistance) {
                joystickDelta.x = (deltaX / distance) * maxDistance;
                joystickDelta.y = (deltaY / distance) * maxDistance;
            } else {
                joystickDelta.x = deltaX;
                joystickDelta.y = deltaY;
            }
            
            joystick.style.transform = `translate(calc(-50% + ${joystickDelta.x}px), calc(-50% + ${joystickDelta.y}px))`;
        }

        joystickContainer.addEventListener('touchstart', e => {
            joystickActive = true;
            handleJoystick(e);
        });

        joystickContainer.addEventListener('touchmove', e => {
            if (joystickActive) handleJoystick(e);
        });

        joystickContainer.addEventListener('touchend', () => {
            joystickActive = false;
            joystickDelta = { x: 0, y: 0 };
            joystick.style.transform = 'translate(-50%, -50%)';
        });

        joystickContainer.addEventListener('mousedown', e => {
            joystickActive = true;
            handleJoystick(e);
        });

        joystickContainer.addEventListener('mousemove', e => {
            if (joystickActive) handleJoystick(e);
        });

        window.addEventListener('mouseup', () => {
            joystickActive = false;
            joystickDelta = { x: 0, y: 0 };
            joystick.style.transform = 'translate(-50%, -50%)';
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('fireBtn').addEventListener('touchstart', e => e.preventDefault());

        function checkCollision(x1, y1, x2, y2, r1, r2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < (r1 + r2);
        }

        // Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Í≥ÑÏÇ∞
        let rainbowHue = 0;
        function getRainbowColor() {
            rainbowHue = (rainbowHue + 3) % 360;  // Îπ†Î•¥Í≤å Î≥ÄÌôî
            const h = rainbowHue;
            const s = 100;
            const l = 50;
            
            const c = (1 - Math.abs(2 * l / 100 - 1)) * s / 100;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l / 100 - c / 2;
            
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            return [r + m, g + m, b + m];
        }

        function shootBullet() {
            // ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú ÎßàÏö∞Ïä§ Ìè¨Ïù∏ÌÑ∞ Î∞©Ìñ•ÏúºÎ°ú Î∞úÏÇ¨
            const dx = gameState.mouseX - gameState.player.x;
            const dy = gameState.mouseY - gameState.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Í±∞Î¶¨Í∞Ä ÎÑàÎ¨¥ Í∞ÄÍπåÏö∞Î©¥ ÏúÑÏ™ΩÏúºÎ°ú Î∞úÏÇ¨
            let angle;
            if (distance < 10) {
                angle = -Math.PI / 2;  // ÏúÑÏ™Ω
            } else {
                angle = Math.atan2(dy, dx);
            }
            
            const speed = 12;
            // Ï¥ùÏïå ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (ÏµúÎåÄÍ∞í Ï†úÌïú)
            let bulletSize = 8 * gameState.player.bulletSizeMultiplier;
            bulletSize = Math.min(bulletSize, gameState.player.maxBulletSize);
            
            gameState.bullets.push({
                x: gameState.player.x,
                y: gameState.player.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: bulletSize,
                life: 3,
                color: getRainbowColor()  // Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Ï∂îÍ∞Ä
            });
            
            playSound('shoot');
        }

        // Î∞∞Í≤Ω Î≥Ñ Ï¥àÍ∏∞Ìôî
        function initStars() {
            gameState.stars = [];
            for (let i = 0; i < 150; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 2 + 0.5,
                    size: Math.random() * 2 + 1,
                    brightness: Math.random() * 0.5 + 0.5
                });
            }
        }

        // Î∞∞Í≤Ω Î≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        function updateStars(dt) {
            for (let star of gameState.stars) {
                star.y += star.speed;
                
                // ÌôîÎ©¥ ÏïÑÎûòÎ°ú Î≤óÏñ¥ÎÇòÎ©¥ ÏúÑÏóêÏÑú Îã§Ïãú ÏãúÏûë
                if (star.y > canvas.height) {
                    star.y = -5;
                    star.x = Math.random() * canvas.width;
                }
            }
        }

        function spawnEnemy() {
            const types = [
                { size: 80, health: 15, baseSpeed: 2.5, score: 1 },   // ÏûëÏùÄ Ï†Å - Îπ†Î¶Ñ
                { size: 100, health: 40, baseSpeed: 1.8, score: 2 },  
                { size: 120, health: 75, baseSpeed: 1.2, score: 3 }, 
                { size: 140, health: 125, baseSpeed: 0.8, score: 4 }, 
                { size: 160, health: 200, baseSpeed: 0.5, score: 5 }  // ÌÅ∞ Ï†Å - ÎäêÎ¶º
            ];
            
            const type = types[Math.min(Math.floor(Math.random() * 5), 4)];
            
            // 10ÎßàÎ¶¨ Ï§ë 1ÎßàÎ¶¨Îäî 1.5Î∞∞ Îπ†Î•∏ Ï†Å
            const isFastEnemy = Math.random() < 0.1;  // 10% ÌôïÎ•†
            const speedBonus = isFastEnemy ? 1.5 : 1.0;
            
            // Í∏∞Î≥∏ ÏÜçÎèÑÏóê ÏãúÍ∞ÑÏóê Îî∞Î•∏ Ï¶ùÍ∞ÄÏú® Ï†ÅÏö©
            const speedMultiplier = gameState.baseEnemySpeed * speedBonus;
            
            gameState.enemies.push({
                x: Math.random() * (canvas.width - 100) + 50,
                y: -50,
                vx: (Math.random() - 0.5) * 2 * speedMultiplier,
                vy: (Math.random() * 0.5 + type.baseSpeed) * speedMultiplier,  // ÌÅ¨Í∏∞ Í∏∞Î∞ò ÏÜçÎèÑ
                size: type.size,
                currentSize: type.size,
                minSize: type.size * 0.3,  // ÏµúÏÜå ÌÅ¨Í∏∞ = ÏõêÎûò ÌÅ¨Í∏∞Ïùò 30%
                health: type.health,
                maxHealth: type.health,
                sizeMultiplier: type.score,
                type: Math.floor(Math.random() * 5),
                score: type.score * 100,  // Ï†êÏàò Ï†ÄÏû•
                isFast: isFastEnemy  // Îπ†Î•∏ Ï†Å ÌëúÏãú
            });
        }

        // Î≥¥Ïä§ ÏÉùÏÑ±
        function spawnBoss() {
            const bossSize = Math.min(canvas.width, canvas.height) * 0.15;  // ÌôîÎ©¥Ïùò 15% (Ï†àÎ∞òÏúºÎ°ú Ï§ÑÏûÑ)
            
            // Î™®Îì† ÏùºÎ∞ò Ï†Å Ï†úÍ±∞
            gameState.enemies = [];
            gameState.isBossBattle = true;
            gameState.bossAppearCount++;  // Îì±Ïû• ÌöüÏàò Ï¶ùÍ∞Ä
            
            // Î≥¥Ïä§ Ï≤¥Î†• Í≥ÑÏÇ∞: Í∏∞Î≥∏ 1000 (2Î∞∞) √ó Î†àÎ≤® √ó (1 + 0.3 √ó Îì±Ïû•ÌöüÏàò)
            const baseHealth = 1000 * gameState.level;
            const healthMultiplier = 1 + (0.3 * (gameState.bossAppearCount - 1));
            const bossHealth = Math.floor(baseHealth * healthMultiplier);
            
            // Ï¥ùÏïå ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä: Í∏∞Î≥∏ 12 √ó (1 + 0.2 √ó Îì±Ïû•ÌöüÏàò)
            const bulletSizeMultiplier = 1 + (0.2 * (gameState.bossAppearCount - 1));
            const bossBulletSize = 12 * bulletSizeMultiplier;
            
            gameState.boss = {
                x: canvas.width / 2,
                y: -bossSize / 2,
                vx: 0,
                vy: 1.5,  // Ï¢Ä Îçî Îπ†Î•¥Í≤å Îì±Ïû•
                size: bossSize,
                currentSize: bossSize,
                health: bossHealth,
                maxHealth: bossHealth,
                shootTimer: 0,
                shootInterval: 0.5,  // Î∞úÏÇ¨ Í∞ÑÍ≤© Ï°∞Ï†ï
                moveTimer: 0,
                movePattern: 0,
                tentacles: [],  // Ï¥âÏàò/ÌååÏ∏† Ï†ïÎ≥¥
                isBoss: true,
                bulletSize: bossBulletSize  // Ï¥ùÏïå ÌÅ¨Í∏∞ Ï†ÄÏû•
            };
            
            // Ï¥âÏàò/ÌååÏ∏† ÏÉùÏÑ± (Ïò§ÏßïÏñ¥/Í≥†Îûò ÌòïÌÉú) - Îçî Î™ÖÌôïÌïòÍ≤å
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                gameState.boss.tentacles.push({
                    angle: angle,
                    distance: bossSize * 0.6,
                    size: bossSize * 0.25,
                    offset: Math.random() * Math.PI * 2
                });
            }
            
            console.log(`BOSS APPEARED! #${gameState.bossAppearCount} Level ${gameState.level} - HP: ${bossHealth} - Bullet Size: ${bossBulletSize.toFixed(1)}`);
            
            // Î≥¥Ïä§ Îì±Ïû• ÏïåÎ¶º - ÏÉàÎ°úÏö¥ ÌÅ¥ÎûòÏä§ ÏÇ¨Ïö©
            const popup = document.createElement('div');
            popup.className = 'boss-warning';
            popup.textContent = '‚ö†Ô∏è BOSS BATTLE! ‚ö†Ô∏è';
            
            document.body.appendChild(popup);  // bodyÏóê ÏßÅÏ†ë Ï∂îÍ∞Ä
            setTimeout(() => popup.remove(), 3000);
            
            // Î≥¥Ïä§ BGMÏúºÎ°ú Ï†ÑÌôò (ÏïàÏ†ÑÌïòÍ≤å)
            try {
                stopBGM();
                setTimeout(() => {
                    try {
                        startBossBGM();
                    } catch(e) {
                        console.log('Boss BGM start error:', e);
                    }
                }, 200);
            } catch(e) {
                console.log('BGM transition error:', e);
            }
        }

        // Î≥¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
        function updateBoss(dt) {
            if (!gameState.boss) return;
            
            const boss = gameState.boss;
            
            // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (boss.y < 100) {
                boss.y += boss.vy;
                return;
            }
            
            // Ïù¥Îèô Ìå®ÌÑ¥
            boss.moveTimer += dt;
            if (boss.moveTimer > 3) {
                boss.moveTimer = 0;
                boss.movePattern = (boss.movePattern + 1) % 3;
            }
            
            // Ï¢åÏö∞ Ïù¥Îèô
            switch(boss.movePattern) {
                case 0: // ÏôºÏ™Ω
                    boss.vx = -2;
                    break;
                case 1: // Ïò§Î•∏Ï™Ω
                    boss.vx = 2;
                    break;
                case 2: // Ï†ïÏßÄ
                    boss.vx = 0;
                    break;
            }
            
            boss.x += boss.vx;
            boss.x = Math.max(boss.size / 2, Math.min(canvas.width - boss.size / 2, boss.x));
            
            // Ï¥ùÏïå Î∞úÏÇ¨
            boss.shootTimer += dt;
            if (boss.shootTimer >= boss.shootInterval) {
                boss.shootTimer = 0;
                
                // ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•Ìï¥ 3Î∞©Ìñ• ÌÉÑÎßâ
                for (let i = -1; i <= 1; i++) {
                    const dx = gameState.player.x - boss.x;
                    const dy = gameState.player.y - boss.y;
                    const angle = Math.atan2(dy, dx) + (i * 0.3);
                    const speed = 4;
                    
                    gameState.bossBullets.push({
                        x: boss.x,
                        y: boss.y + boss.size / 3,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: boss.bulletSize,  // Ï¶ùÍ∞ÄÎêú Ï¥ùÏïå ÌÅ¨Í∏∞ ÏÇ¨Ïö©
                        life: 5
                    });
                }
                
                playSound('shoot');
            }
            
            // Ï¥âÏàò Ïï†ÎãàÎ©îÏù¥ÏÖò
            boss.tentacles.forEach(t => {
                t.offset += dt * 2;
            });
        }

        function createParticles(x, y, count, color, sizeMultiplier = 1) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                gameState.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: (Math.random() * 4 + 2) * sizeMultiplier,  // ÌÅ¨Í∏∞ Î∞∞Ïú® Ï†ÅÏö©
                    life: 1,
                    color: color
                });
            }
        }

        // Ìè≠Ï£Ω Ïù¥ÌéôÌä∏ ÏÉùÏÑ± - Î∂àÍΩÉ ÏÉâÏÉÅÏúºÎ°ú
        function createFireworkEffect(x, y, sizeMultiplier = 1) {
            const fireColors = [
                [1, 0.9, 0],      // Î∞ùÏùÄ ÎÖ∏Îûë (Ï§ëÏã¨)
                [1, 0.7, 0],      // Ï£ºÌô©-ÎÖ∏Îûë
                [1, 0.5, 0],      // Ï£ºÌô©
                [1, 0.3, 0],      // ÏßÑÌïú Ï£ºÌô©
                [0.9, 0.2, 0],    // Ï£ºÌô©-Îπ®Í∞ï
                [0.8, 0.1, 0],    // Ïñ¥ÎëêÏö¥ Îπ®Í∞ï
                [0.6, 0, 0]       // Í≤ÄÎ∂âÏùÄÏÉâ
            ];
            
            // Ï≤´ Î≤àÏß∏ Ìè≠Î∞ú - Î∞ùÏùÄ Ï§ëÏã¨Î∂Ä
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const speed = (Math.random() * 8 + 5) * sizeMultiplier * 0.5;
                // Ï§ëÏã¨ÏóêÏÑú Î∞îÍπ•ÏúºÎ°ú Í∞àÏàòÎ°ù Ïñ¥ÎëêÏö¥ ÏÉâ
                const colorIndex = Math.min(Math.floor(Math.random() * 4), 3);
                const color = fireColors[colorIndex];
                
                gameState.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: (Math.random() * 6 + 3) * sizeMultiplier,
                    life: 1.5,
                    color: color
                });
            }
            
            // Îëê Î≤àÏß∏ Ìè≠Î∞ú (ÏïΩÍ∞Ñ ÏßÄÏó∞) - Îçî Ïñ¥ÎëêÏö¥ Ïô∏Í≥Ω
            setTimeout(() => {
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 6 + 3) * sizeMultiplier * 0.5;
                    // Î∞îÍπ•Ï™Ω Ïñ¥ÎëêÏö¥ ÏÉâÏÉÅ
                    const colorIndex = Math.min(Math.floor(Math.random() * 3) + 3, 6);
                    const color = fireColors[colorIndex];
                    
                    gameState.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: (Math.random() * 5 + 2) * sizeMultiplier,
                        life: 1.2,
                        color: color
                    });
                }
            }, 100);
        }

        // Ï†êÏàò ÌåùÏóÖ ÌëúÏãú
        function showScorePopup(x, y, score) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${score}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            
            document.getElementById('gameContainer').appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1000);
        }

        // ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
        function spawnItem(x, y) {
            const item = document.createElement('div');
            item.className = 'item';
            item.textContent = '‚≠ê';
            item.style.left = `${x}px`;
            item.style.top = `${y}px`;
            
            document.getElementById('gameContainer').appendChild(item);
            
            gameState.items.push({
                x: x,
                y: y,
                element: item,
                vx: 0,
                vy: 2  // Ï≤úÏ≤úÌûà ÏïÑÎûòÎ°ú Ïù¥Îèô
            });
        }

        // ÏïÑÏù¥ÌÖú ÏàòÏßë Ï≤¥ÌÅ¨
        function checkItemCollection() {
            gameState.items = gameState.items.filter(item => {
                const dx = item.x - gameState.player.x;
                const dy = item.y - gameState.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
                if (distance < 40) {
                    // Ï¥ùÏïå ÌÅ¨Í∏∞ 0.5Î∞∞ Ï¶ùÍ∞Ä
                    gameState.player.bulletSizeMultiplier += 0.5;
                    
                    // Î∞úÏÇ¨ ÏÜçÎèÑ 0.5Î∞∞ Îπ†Î•¥Í≤å (intervalÏùÑ Ï†àÎ∞òÏúºÎ°ú)
                    gameState.shootInterval = Math.max(0.02, gameState.shootInterval * 0.5);
                    
                    // ÏãúÍ∞Å Ìö®Í≥º
                    createParticles(item.x, item.y, 20, [0, 1, 1]);
                    playSound('shoot');
                    
                    // ÏïåÎ¶º ÌëúÏãú
                    const popup = document.createElement('div');
                    popup.className = 'score-popup';
                    popup.textContent = 'POWER UP!';
                    popup.style.left = `${item.x}px`;
                    popup.style.top = `${item.y}px`;
                    popup.style.color = '#00ffff';
                    popup.style.textShadow = '0 0 10px #00ffff, 2px 2px 0 #000';
                    document.getElementById('gameContainer').appendChild(popup);
                    setTimeout(() => popup.remove(), 1000);
                    
                    console.log(`Power Up! Bullet size: ${gameState.player.bulletSizeMultiplier.toFixed(1)}x, Fire interval: ${gameState.shootInterval.toFixed(3)}s`);
                    
                    // DOMÏóêÏÑú Ï†úÍ±∞
                    item.element.remove();
                    return false;
                }
                
                // ÏïÑÏù¥ÌÖú ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
                item.y += item.vy;
                item.element.style.top = `${item.y}px`;
                
                // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞
                if (item.y > canvas.height + 50) {
                    item.element.remove();
                    return false;
                }
                
                return true;
            });
        }

        // Î†àÎ≤®ÏóÖ Ï≤¥ÌÅ¨ Î∞è Ï≤òÎ¶¨
        function checkLevelUp() {
            if (gameState.score >= gameState.nextLevelScore) {
                gameState.level++;
                gameState.nextLevelScore = Math.floor(gameState.nextLevelScore * gameState.levelMultiplier);  // 3Î∞∞Ïî© Ï¶ùÍ∞Ä
                
                // Ï≤¥Î†• ÌíÄ ÌöåÎ≥µ
                gameState.player.health = gameState.player.maxHealth;
                
                // ÎØ∏ÏÇ¨Ïùº ÌÅ¨Í∏∞ 0.5Î∞∞ Ï¶ùÍ∞Ä
                gameState.player.bulletSizeMultiplier += 0.5;
                
                // Ï†Å ÏÜçÎèÑ 10% Ï¶ùÍ∞Ä
                gameState.baseEnemySpeed *= 1.1;
                
                // ÌôîÎ†§Ìïú Î†àÎ≤®ÏóÖ Ïù¥ÌéôÌä∏
                createFireworkEffect(gameState.player.x, gameState.player.y);
                createParticles(gameState.player.x, gameState.player.y, 50, [1, 1, 0]);
                
                // Î†àÎ≤®ÏóÖ ÏÇ¨Ïö¥Îìú
                playSound('explosion');
                
                // Î†àÎ≤®ÏóÖ Î©îÏãúÏßÄ
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = `LEVEL ${gameState.level}!`;
                popup.style.left = `${gameState.player.x}px`;
                popup.style.top = `${gameState.player.y - 50}px`;
                popup.style.color = '#ffff00';
                popup.style.fontSize = '30px';
                popup.style.textShadow = '0 0 20px #ffff00, 3px 3px 0 #000';
                document.getElementById('gameContainer').appendChild(popup);
                setTimeout(() => popup.remove(), 2000);
                
                console.log(`Level Up! Level ${gameState.level} - Next: ${gameState.nextLevelScore} - Enemy speed: ${gameState.baseEnemySpeed.toFixed(2)}x`);
            }
        }

        function createEnemyChunks(enemy, hitX, hitY) {
            const chunkCount = Math.floor(5 * enemy.sizeMultiplier);
            for (let i = 0; i < chunkCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1;
                gameState.enemyChunks.push({
                    x: hitX,
                    y: hitY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 3 + 1,
                    life: 1
                });
            }
        }

        function showCombo() {
            const comboDiv = document.getElementById('combo');
            comboDiv.textContent = `COMBO x${gameState.combo}!`;
            comboDiv.classList.add('show');
            setTimeout(() => comboDiv.classList.remove('show'), 500);
        }

        function updateGame(dt) {
            if (!gameState.running) return;

            // Î∞∞Í≤Ω Î≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            updateStars(dt);

            // Í≤åÏûÑ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
            gameState.gameTime += dt;
            
            // 3Î∂ÑÎßàÎã§ Î≥¥Ïä§ ÏÜåÌôò Ï≤¥ÌÅ¨
            gameState.bossTimer += dt;
            if (gameState.bossTimer >= gameState.bossInterval && !gameState.boss) {
                spawnBoss();
                gameState.bossTimer = 0;
            }
            
            // 2Î∂Ñ(120Ï¥à)ÎßàÎã§ Ï†Å ÏÜçÎèÑ 10% Ï¶ùÍ∞Ä
            const speedIncreaseInterval = 120;  // 2Î∂Ñ
            if (gameState.gameTime - gameState.lastSpeedIncrease >= speedIncreaseInterval) {
                gameState.baseEnemySpeed *= 1.1;  // 10% Ï¶ùÍ∞Ä
                gameState.lastSpeedIncrease = gameState.gameTime;
                console.log(`Speed increased! New speed: ${gameState.baseEnemySpeed.toFixed(2)}x`);
            }

            let vx = 0, vy = 0;
            if (keys['w'] || keys['arrowup']) vy = -1;
            if (keys['s'] || keys['arrowdown']) vy = 1;
            if (keys['a'] || keys['arrowleft']) vx = -1;
            if (keys['d'] || keys['arrowright']) vx = 1;

            if (joystickActive) {
                vx += joystickDelta.x / 35;
                vy += joystickDelta.y / 35;
            }

            if (vx !== 0 || vy !== 0) {
                const dist = Math.sqrt(vx * vx + vy * vy);
                gameState.player.vx = (vx / dist) * gameState.player.speed;
                gameState.player.vy = (vy / dist) * gameState.player.speed;
            } else {
                gameState.player.vx *= 0.9;
                gameState.player.vy *= 0.9;
            }

            gameState.player.x += gameState.player.vx;
            gameState.player.y += gameState.player.vy;
            gameState.player.x = Math.max(20, Math.min(canvas.width - 20, gameState.player.x));
            gameState.player.y = Math.max(20, Math.min(canvas.height - 150, gameState.player.y));

            gameState.shootTimer += dt;
            if (gameState.shootTimer >= gameState.shootInterval) {
                shootBullet();
                gameState.shootTimer = 0;
            }

            gameState.enemySpawnTimer += dt;
            if (gameState.enemySpawnTimer >= gameState.enemySpawnInterval && !gameState.isBossBattle) {
                spawnEnemy();
                gameState.enemySpawnTimer = 0;
                gameState.enemySpawnInterval = Math.max(0.3, gameState.enemySpawnInterval * 0.98);
            }

            gameState.bullets = gameState.bullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life -= dt * 0.5;
                // Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
                b.color = getRainbowColor();
                return b.life > 0 && b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50;
            });

            gameState.enemies = gameState.enemies.filter(e => {
                e.x += e.vx;
                e.y += e.vy;

                if (checkCollision(e.x, e.y, gameState.player.x, gameState.player.y, e.currentSize / 2, gameState.player.size)) {
                    const damage = Math.floor(5 * e.sizeMultiplier);
                    gameState.player.health -= damage;
                    createParticles(e.x, e.y, 15, [1, 0, 0]);
                    playSound('damage');
                    
                    if (gameState.player.health <= 0) {
                        endGame();
                    }
                    
                    document.getElementById('warning').classList.add('show');
                    setTimeout(() => document.getElementById('warning').classList.remove('show'), 500);
                    return false;
                }

                for (let b of gameState.bullets) {
                    if (checkCollision(b.x, b.y, e.x, e.y, 4, e.currentSize / 2)) {
                        // Ï¥ùÏïå ÌÅ¨Í∏∞Ïóê ÎπÑÎ°ÄÌïú Îç∞ÎØ∏ÏßÄ (Í∏∞Î≥∏ 10 + ÌÅ¨Í∏∞ Î≥¥ÎÑàÏä§)
                        const damage = 10 * (b.size / 8);  // Í∏∞Î≥∏ ÌÅ¨Í∏∞(8) ÎåÄÎπÑ ÎπÑÏú®Î°ú Îç∞ÎØ∏ÏßÄ
                        e.health -= damage;
                        b.life = 0;
                        
                        const healthRatio = e.health / e.maxHealth;
                        e.currentSize = e.size * healthRatio;
                        
                        // ÏµúÏÜå ÌÅ¨Í∏∞Ïóê ÎèÑÎã¨ÌñàÎäîÏßÄ Ï≤¥ÌÅ¨
                        if (e.currentSize <= e.minSize || e.health <= 0) {
                            // ÌÅ¨Í∏∞ Î∞∞Ïú® Í≥ÑÏÇ∞ (Í∏∞Î≥∏ ÌÅ¨Í∏∞ 60 Í∏∞Ï§Ä)
                            const particleSizeMultiplier = e.size / 60;
                            
                            // Ìè≠Ï£Ω Ïù¥ÌéôÌä∏ (ÌÅ¨Í∏∞ ÎπÑÎ°Ä) - Î∂àÍΩÉ ÏÉâÏÉÅ
                            createFireworkEffect(e.x, e.y, particleSizeMultiplier);
                            
                            // Ï∂îÍ∞Ä Î∂àÍΩÉ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± (Ïñ¥ÎëêÏö¥ Ïô∏Í≥Ω)
                            const darkParticleCount = Math.floor(20 * particleSizeMultiplier);
                            for (let i = 0; i < darkParticleCount; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = Math.random() * 4 + 1;
                                // Í≤ÄÎ∂âÏùÄ ÏÉâÏÉÅ
                                const darkRed = 0.4 + Math.random() * 0.3;
                                gameState.particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: (Math.random() * 5 + 3) * particleSizeMultiplier,
                                    life: 1.2,
                                    color: [darkRed, 0, 0],  // Ïñ¥ÎëêÏö¥ Îπ®Í∞ï
                                    isSquare: true  // ÏÇ¨Í∞ÅÌòï ÌëúÏãú
                                });
                            }
                            
                            playSound('explosion');
                            
                            const baseScore = e.score;
                            const finalScore = baseScore * (gameState.combo + 1);
                            gameState.score += finalScore;
                            gameState.combo++;
                            gameState.comboTimer = 2;
                            
                            // ÌÇ¨ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
                            gameState.killCount++;
                            
                            // 10ÌÇ¨ÎßàÎã§ ÏïÑÏù¥ÌÖú ÎìúÎ°≠
                            if (gameState.killCount % 10 === 0) {
                                spawnItem(e.x, e.y);
                            }
                            
                            // Ï†êÏàò ÌåùÏóÖ ÌëúÏãú
                            showScorePopup(e.x, e.y, finalScore);
                            showCombo();
                            
                            return false;
                        }
                        
                        createEnemyChunks(e, b.x, b.y);
                        break;
                    }
                }
                return true;
            });

            gameState.enemyChunks = gameState.enemyChunks.filter(c => {
                c.x += c.vx; c.y += c.vy;
                c.vx *= 0.97; c.vy *= 0.97;
                c.life -= dt * 0.8;
                return c.life > 0;
            });

            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.95; p.vy *= 0.95;
                p.life -= dt * 2;
                return p.life > 0;
            });

            gameState.comboTimer -= dt;
            if (gameState.comboTimer <= 0) gameState.combo = 0;

            // Î≥¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
            if (gameState.boss) {
                updateBoss(dt);
                
                // Î≥¥Ïä§ÏôÄ ÌîåÎ†àÏù¥Ïñ¥ Ï∂©Îèå
                if (checkCollision(gameState.boss.x, gameState.boss.y, gameState.player.x, gameState.player.y, 
                                   gameState.boss.size / 2, gameState.player.size)) {
                    const damage = 20;
                    gameState.player.health -= damage;
                    createParticles(gameState.player.x, gameState.player.y, 20, [1, 0, 0], 2);
                    playSound('damage');
                    
                    if (gameState.player.health <= 0) {
                        endGame();
                    }
                    
                    document.getElementById('warning').classList.add('show');
                    setTimeout(() => document.getElementById('warning').classList.remove('show'), 500);
                }
                
                // Î≥¥Ïä§ÏôÄ Ï¥ùÏïå Ï∂©Îèå
                for (let b of gameState.bullets) {
                    if (checkCollision(b.x, b.y, gameState.boss.x, gameState.boss.y, 4, gameState.boss.size / 2)) {
                        const damage = 10 * (b.size / 8);
                        gameState.boss.health -= damage;
                        b.life = 0;
                        
                        const healthRatio = gameState.boss.health / gameState.boss.maxHealth;
                        gameState.boss.currentSize = gameState.boss.size * healthRatio;
                        
                        createParticles(b.x, b.y, 10, [1, 0.5, 0], 2);
                        
                        // Î≥¥Ïä§ Ï≤òÏπò
                        if (gameState.boss.health <= 0) {
                            const particleSizeMultiplier = gameState.boss.size / 60;
                            createFireworkEffect(gameState.boss.x, gameState.boss.y, particleSizeMultiplier * 3);
                            playSound('explosion');
                            
                            const bossScore = 5000 * gameState.level;
                            gameState.score += bossScore;
                            showScorePopup(gameState.boss.x, gameState.boss.y, bossScore);
                            
                            // ÏïÑÏù¥ÌÖú 5Í∞ú ÎìúÎ°≠
                            for (let i = 0; i < 5; i++) {
                                const offsetX = (Math.random() - 0.5) * 100;
                                const offsetY = (Math.random() - 0.5) * 100;
                                spawnItem(gameState.boss.x + offsetX, gameState.boss.y + offsetY);
                            }
                            
                            gameState.boss = null;
                            gameState.bossBullets = [];
                            gameState.isBossBattle = false;
                            
                            // ÏùºÎ∞ò BGMÏúºÎ°ú Î≥µÍ∑Ä (ÏïàÏ†ÑÌïòÍ≤å)
                            try {
                                stopBGM();
                                setTimeout(() => {
                                    try {
                                        startBGM();
                                    } catch(e) {
                                        console.log('BGM restart error:', e);
                                    }
                                }, 200);
                            } catch(e) {
                                console.log('BGM transition error:', e);
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            // Î≥¥Ïä§ Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏
            gameState.bossBullets = gameState.bossBullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life -= dt * 0.3;
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
                if (checkCollision(b.x, b.y, gameState.player.x, gameState.player.y, b.size / 2, gameState.player.size)) {
                    gameState.player.health -= gameState.player.maxHealth * 0.1;  // 10% Îç∞ÎØ∏ÏßÄ
                    createParticles(b.x, b.y, 15, [1, 0.5, 0], 1.5);
                    playSound('damage');
                    
                    if (gameState.player.health <= 0) {
                        endGame();
                    }
                    
                    document.getElementById('warning').classList.add('show');
                    setTimeout(() => document.getElementById('warning').classList.remove('show'), 500);
                    
                    return false;
                }
                
                return b.life > 0 && b.y < canvas.height + 50;
            });

            // ÏïÑÏù¥ÌÖú ÏàòÏßë Ï≤¥ÌÅ¨
            checkItemCollection();

            // Î†àÎ≤®ÏóÖ Ï≤¥ÌÅ¨
            checkLevelUp();

            updateUI();
        }

        function updateUI() {
            document.getElementById('score').textContent = String(Math.floor(gameState.score)).padStart(7, '0');
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('combo-text').textContent = String(gameState.combo).padStart(2, '0');
            document.getElementById('enemies').textContent = String(gameState.enemies.length).padStart(2, '0');
            document.getElementById('power').textContent = gameState.player.bulletSizeMultiplier.toFixed(1);
            const hp = Math.max(0, Math.floor((gameState.player.health / gameState.player.maxHealth) * 100));
            document.getElementById('healthFill').style.width = `${hp}%`;
            document.getElementById('healthText').textContent = Math.max(0, Math.floor(gameState.player.health));
        }

        function render() {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            let idx = 0;

            // Î∞∞Í≤Ω Î≥Ñ Î†åÎçîÎßÅ (Í∞ÄÏû• Î®ºÏ†Ä)
            for (let star of gameState.stars) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = star.x;
                positions[idx * 2 + 1] = star.y;
                colors[idx * 3] = star.brightness;
                colors[idx * 3 + 1] = star.brightness;
                colors[idx * 3 + 2] = star.brightness;
                sizes[idx] = star.size;
                kinds[idx] = 0.0;
                idx++;
            }


            // ÌîåÎ†àÏù¥Ïñ¥Î•º 'ÏäàÌçºÎß®' ÎäêÎÇåÏùò ÌûàÏñ¥Î°úÎ°ú Î†åÎçîÎßÅ (Ï†ê Ïä§ÌîÑÎùºÏù¥Ìä∏ Ï°∞Ìï©)
            // 1) ÎßùÌÜ† (Ï¢å/Ïö∞ Îí§Ï™Ω)
            if (idx < MAX_ENTITIES) {
                positions[idx * 2] = gameState.player.x - 10;
                positions[idx * 2 + 1] = gameState.player.y + 16;
                colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.0; colors[idx * 3 + 2] = 0.0; // Îπ®Í∞ï
                sizes[idx] = gameState.player.size * 0.9;
                kinds[idx] = 0.0;
                idx++;
            }
            if (idx < MAX_ENTITIES) {
                positions[idx * 2] = gameState.player.x + 10;
                positions[idx * 2 + 1] = gameState.player.y + 14;
                colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.0; colors[idx * 3 + 2] = 0.0; // Îπ®Í∞ï
                sizes[idx] = gameState.player.size * 0.8;
                kinds[idx] = 0.0;
                idx++;
            }
            // 2) Î™∏ÌÜµ(ÌååÎûÄ ÏäàÌä∏)
            if (idx < MAX_ENTITIES) {
                positions[idx * 2] = gameState.player.x;
                positions[idx * 2 + 1] = gameState.player.y;
                colors[idx * 3] = 0.0; colors[idx * 3 + 1] = 0.3; colors[idx * 3 + 2] = 1.0; // ÌååÎûë
                sizes[idx] = gameState.player.size * 1.1;
                kinds[idx] = 0.0;
                idx++;
            }
            // 3) Í∞ÄÏä¥ Ïó†Î∏îÎüº(ÎÖ∏Îûë Ï†ê)
            if (idx < MAX_ENTITIES) {
                positions[idx * 2] = gameState.player.x;
                positions[idx * 2 + 1] = gameState.player.y - 3;
                colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.9; colors[idx * 3 + 2] = 0.0; // ÎÖ∏Îûë
                sizes[idx] = gameState.player.size * 0.35;
                kinds[idx] = 0.0;
                idx++;
            }
            // 4) Î®∏Î¶¨(ÏÇ¥ÏÉâ)
            if (idx < MAX_ENTITIES) {
                positions[idx * 2] = gameState.player.x;
                positions[idx * 2 + 1] = gameState.player.y - 14;
                colors[idx * 3] = 1.0; colors[idx * 3 + 1] = 0.8; colors[idx * 3 + 2] = 0.6; // ÏÇ¥ÏÉâ
                sizes[idx] = gameState.player.size * 0.6;
                kinds[idx] = 0.0;
                idx++;
            }


            for (let b of gameState.bullets) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = b.x; positions[idx * 2 + 1] = b.y;
                colors[idx * 3] = b.color[0]; colors[idx * 3 + 1] = b.color[1]; colors[idx * 3 + 2] = b.color[2];
                sizes[idx] = b.size;
                kinds[idx] = 0.0;
                idx++;
            }

            for (let e of gameState.enemies) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = e.x; positions[idx * 2 + 1] = e.y;
                
                // ÏÉâÏÉÅÏùÄ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏßÄÎßå Î≤ÑÌçºÎ•º ÏúÑÌï¥ ÏÑ§Ï†ï
                colors[idx * 3] = 1; 
                colors[idx * 3 + 1] = 1; 
                colors[idx * 3 + 2] = 1;
                
                sizes[idx] = e.currentSize;
                kinds[idx] = 2.0; // ÌÖçÏä§Ï≤ò Î†åÎçîÎßÅ
                idx++;
            }

            // Î≥¥Ïä§ Î†åÎçîÎßÅ (Í≥†Îûò/Ïò§ÏßïÏñ¥ ÌòïÌÉú)
            if (gameState.boss) {
                const boss = gameState.boss;
                
                // Î≥¥Ïä§ Ï§ëÏã¨Î∂Ä (Î™∏ÌÜµ)
                if (idx < MAX_ENTITIES) {
                    positions[idx * 2] = boss.x;
                    positions[idx * 2 + 1] = boss.y;
                    colors[idx * 3] = 0.8; colors[idx * 3 + 1] = 0; colors[idx * 3 + 2] = 0.8;  // Î≥¥ÎùºÏÉâ
                    sizes[idx] = boss.currentSize;
                    kinds[idx] = 0.0;
                idx++;
                }
                
                // Ï¥âÏàò/ÌååÏ∏† Î†åÎçîÎßÅ
                for (let t of boss.tentacles) {
                    if (idx >= MAX_ENTITIES) break;
                    const tentacleX = boss.x + Math.cos(t.angle + t.offset) * t.distance;
                    const tentacleY = boss.y + Math.sin(t.angle + t.offset) * t.distance;
                    
                    positions[idx * 2] = tentacleX;
                    positions[idx * 2 + 1] = tentacleY;
                    colors[idx * 3] = 0.6; colors[idx * 3 + 1] = 0; colors[idx * 3 + 2] = 0.6;  // Ïñ¥ÎëêÏö¥ Î≥¥Îùº
                    sizes[idx] = t.size;
                    kinds[idx] = 0.0;
                idx++;
                }
            }

            // Î≥¥Ïä§ Ï¥ùÏïå Î†åÎçîÎßÅ
            for (let b of gameState.bossBullets) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = b.x; positions[idx * 2 + 1] = b.y;
                colors[idx * 3] = 1; colors[idx * 3 + 1] = 0; colors[idx * 3 + 2] = 0;  // Îπ®Í∞ÑÏÉâ
                sizes[idx] = b.size;
                kinds[idx] = 0.0;
                idx++;
            }

            for (let c of gameState.enemyChunks) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = c.x; positions[idx * 2 + 1] = c.y;
                colors[idx * 3] = 0.7; colors[idx * 3 + 1] = 0.2; colors[idx * 3 + 2] = 0.2;
                sizes[idx] = c.size;
                idx++;
            }

            for (let p of gameState.particles) {
                if (idx >= MAX_ENTITIES) break;
                positions[idx * 2] = p.x; positions[idx * 2 + 1] = p.y;
                colors[idx * 3] = p.color[0]; colors[idx * 3 + 1] = p.color[1]; colors[idx * 3 + 2] = p.color[2];
                sizes[idx] = p.size;
                kinds[idx] = 0.0;
                idx++;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(sizeLoc);
            gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, 0, 0);

            // kinds
            gl.bindBuffer(gl.ARRAY_BUFFER, kindBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, kinds, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(kindLoc);
            gl.vertexAttribPointer(kindLoc, 1, gl.FLOAT, false, 0, 0);
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, performance.now() / 1000.0);
            gl.drawArrays(gl.POINTS, 0, idx);
        }

        function endGame() {
            gameState.running = false;
            stopBGM();
            setTimeout(() => {
                alert(`GAME OVER!\n\nSCORE: ${String(Math.floor(gameState.score)).padStart(7, '0')}\nMAX COMBO: x${gameState.combo}`);
                location.reload();
            }, 100);
        }

        let lastTime = 0;
        let frameCount = 0;
        let fpsTime = 0;

        function gameLoop(time) {
            if (!time) time = 0;
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            if (gameState.running) {
                updateGame(dt);
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        async function startGame() {
            await initWasm();
            initAudio();
            
            gameState.running = true;
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height / 2;
            gameState.gameTime = 0;
            gameState.lastSpeedIncrease = 0;
            gameState.baseEnemySpeed = 0.6;  // Í∏∞Î≥∏ ÏÜçÎèÑÎ•º ÎÇÆÏ∂§ (Í∏∞Ï°¥ 1.0ÏóêÏÑú 0.6ÏúºÎ°ú)
            gameState.killCount = 0;
            gameState.level = 1;
            gameState.nextLevelScore = 1000;  // Ï≤´ Î†àÎ≤® 1000Ï†ê
            gameState.player.bulletSizeMultiplier = 1.0;
            gameState.shootInterval = 0.1;  // Î∞úÏÇ¨ ÏÜçÎèÑ Ï¥àÍ∏∞Ìôî
            gameState.bossTimer = 0;  // Î≥¥Ïä§ ÌÉÄÏù¥Î®∏ Ï¥àÍ∏∞Ìôî
            gameState.isBossBattle = false;  // Î≥¥Ïä§ Ï†ÑÌà¨ ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞Ìôî
            gameState.bossAppearCount = 0;  // Î≥¥Ïä§ Îì±Ïû• ÌöüÏàò Ï¥àÍ∏∞Ìôî
            gameState.mouseX = canvas.width / 2;  // Ï¥àÍ∏∞ ÎßàÏö∞Ïä§ ÏúÑÏπò
            gameState.mouseY = 0;  // ÏúÑÏ™ΩÏùÑ Ìñ•ÌïòÎèÑÎ°ù
            
            // Î∞∞Í≤Ω Î≥Ñ Ï¥àÍ∏∞Ìôî
            initStars();
            
            document.getElementById('menu').classList.add('hidden');
            
            if (audioContext) audioContext.resume();
            
            startBGM();
            
            gameLoop(0);
        }
    </script>
</body>
</html>